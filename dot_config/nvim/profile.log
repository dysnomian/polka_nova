SCRIPT  /Users/liss/.polka/config/nvim/ftplugin/vim.vim
Sourced 2 times
Total time:   0.001086
 Self time:   0.001086

count  total (s)   self (s)
    2              0.000033 let b:ale_linters = ['vint']

SCRIPT  /usr/local/Cellar/neovim/HEAD-c6cd608/share/nvim/runtime/ftplugin/vim.vim
Sourced 2 times
Total time:   0.002248
 Self time:   0.002248

count  total (s)   self (s)
                            " Vim filetype plugin
                            " Language:	Vim
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2018 Aug 07
                            
                            " Only do this when not done yet for this buffer
    2              0.000034 if exists("b:did_ftplugin")
                              finish
                            endif
                            
                            " Don't load another plugin for this buffer
    2              0.000010 let b:did_ftplugin = 1
                            
    2              0.000022 let s:cpo_save = &cpo
    2              0.000028 set cpo-=C
                            
    2              0.000013 if !exists('*VimFtpluginUndo')
                              func VimFtpluginUndo()
                                setl fo< isk< com< tw< commentstring< keywordprg<
                                if exists('b:did_add_maps')
                                  silent! nunmap <buffer> [[
                                  silent! vunmap <buffer> [[
                                  silent! nunmap <buffer> ]]
                                  silent! vunmap <buffer> ]]
                                  silent! nunmap <buffer> []
                                  silent! vunmap <buffer> []
                                  silent! nunmap <buffer> ][
                                  silent! vunmap <buffer> ][
                                  silent! nunmap <buffer> ]"
                                  silent! vunmap <buffer> ]"
                                  silent! nunmap <buffer> ["
                                  silent! vunmap <buffer> ["
                                 endif
                                unlet! b:match_ignorecase b:match_words b:match_skip b:did_add_maps
                              endfunc
                            endif
                            
    2              0.000007 let b:undo_ftplugin = "call VimFtpluginUndo()"
                            
                            " Set 'formatoptions' to break comment lines but not other lines,
                            " and insert the comment leader when hitting <CR> or using "o".
    2              0.000032 setlocal fo-=t fo+=croql
                            
                            " To allow tag lookup via CTRL-] for autoload functions, '#' must be a
                            " keyword character.  E.g., for netrw#Nread().
    2              0.000069 setlocal isk+=#
                            
                            " Use :help to lookup the keyword under the cursor with K.
    2              0.000009 setlocal keywordprg=:help
                            
                            " Set 'comments' to format dashed lists in comments
    2              0.000014 setlocal com=sO:\"\ -,mO:\"\ \ ,eO:\"\",:\"
                            
                            " Format comments to be up to 78 characters long
    2              0.000007 if &tw == 0
    2              0.000047   setlocal tw=78
    2              0.000002 endif
                            
                            " Comments start with a double quote
    2              0.000009 setlocal commentstring=\"%s
                            
                            " Prefer Vim help instead of manpages.
    2              0.000006 setlocal keywordprg=:help
                            
    2              0.000013 if !exists("no_plugin_maps") && !exists("no_vim_maps")
    2              0.000024   let b:did_add_maps = 1
                            
                              " Move around functions.
    2              0.000092   nnoremap <silent><buffer> [[ m':call search('^\s*fu\%[nction]\>', "bW")<CR>
    2              0.000042   vnoremap <silent><buffer> [[ m':<C-U>exe "normal! gv"<Bar>call search('^\s*fu\%[nction]\>', "bW")<CR>
    2              0.000028   nnoremap <silent><buffer> ]] m':call search('^\s*fu\%[nction]\>', "W")<CR>
    2              0.000034   vnoremap <silent><buffer> ]] m':<C-U>exe "normal! gv"<Bar>call search('^\s*fu\%[nction]\>', "W")<CR>
    2              0.000025   nnoremap <silent><buffer> [] m':call search('^\s*endf\%[unction]\>', "bW")<CR>
    2              0.000028   vnoremap <silent><buffer> [] m':<C-U>exe "normal! gv"<Bar>call search('^\s*endf\%[unction]\>', "bW")<CR>
    2              0.000023   nnoremap <silent><buffer> ][ m':call search('^\s*endf\%[unction]\>', "W")<CR>
    2              0.000025   vnoremap <silent><buffer> ][ m':<C-U>exe "normal! gv"<Bar>call search('^\s*endf\%[unction]\>', "W")<CR>
                            
                              " Move around comments
    2              0.000023   nnoremap <silent><buffer> ]" :call search('^\(\s*".*\n\)\@<!\(\s*"\)', "W")<CR>
    2              0.000025   vnoremap <silent><buffer> ]" :<C-U>exe "normal! gv"<Bar>call search('^\(\s*".*\n\)\@<!\(\s*"\)', "W")<CR>
    2              0.000026   nnoremap <silent><buffer> [" :call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")<CR>
    2              0.000026   vnoremap <silent><buffer> [" :<C-U>exe "normal! gv"<Bar>call search('\%(^\s*".*\n\)\%(^\s*"\)\@!', "bW")<CR>
    2              0.000002 endif
                            
                            " Let the matchit plugin know what items can be matched.
    2              0.000009 if exists("loaded_matchit")
    2              0.000005   let b:match_ignorecase = 0
    2              0.000041   let b:match_words =
                            	\ '\<fu\%[nction]\>:\<retu\%[rn]\>:\<endf\%[unction]\>,' .
                             	\ '\<\(wh\%[ile]\|for\)\>:\<brea\%[k]\>:\<con\%[tinue]\>:\<end\(w\%[hile]\|fo\%[r]\)\>,' .
                            	\ '\<if\>:\<el\%[seif]\>:\<en\%[dif]\>,' .
                            	\ '\<try\>:\<cat\%[ch]\>:\<fina\%[lly]\>:\<endt\%[ry]\>,' .
                            	\ '\<aug\%[roup]\s\+\%(END\>\)\@!\S:\<aug\%[roup]\s\+END\>,'
                              " Ignore syntax region commands and settings, any 'en*' would clobber
                              " if-endif.
                              " - set spl=de,en
                              " - au! FileType javascript syntax region foldBraces start=/{/ end=/}/ â€¦
    2              0.000031   let b:match_skip = 'synIDattr(synID(line("."),col("."),1),"name")
                                    \ =~? "comment\\|string\\|vimSynReg\\|vimSet"'
    2              0.000002 endif
                            
    2              0.000019 let &cpo = s:cpo_save
    2              0.000006 unlet s:cpo_save
                            
                            " removed this, because 'cpoptions' is a global option.
                            " setlocal cpo+=M		" makes \%( match \)

SCRIPT  /usr/local/Cellar/neovim/HEAD-c6cd608/share/nvim/runtime/indent/vim.vim
Sourced 2 times
Total time:   0.001379
 Self time:   0.001379

count  total (s)   self (s)
                            " Vim indent file
                            " Language:	Vim script
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last Change:	2016 Jun 27
                            
                            " Only load this indent file when no other was loaded.
    2              0.000023 if exists("b:did_indent")
                              finish
                            endif
    2              0.000008 let b:did_indent = 1
                            
    2              0.000019 setlocal indentexpr=GetVimIndent()
    2              0.000012 setlocal indentkeys+==end,=else,=cat,=fina,=END,0\\,0=\"\\\ 
                            
    2              0.000006 let b:undo_indent = "setl indentkeys< indentexpr<"
                            
                            " Only define the function once.
    2              0.000010 if exists("*GetVimIndent")
    2              0.000003   finish
                            endif
                            let s:keepcpo= &cpo
                            set cpo&vim
                            
                            function GetVimIndent()
                              let ignorecase_save = &ignorecase
                              try
                                let &ignorecase = 0
                                return GetVimIndentIntern()
                              finally
                                let &ignorecase = ignorecase_save
                              endtry
                            endfunc
                            
                            let s:lineContPat = '^\s*\(\\\|"\\ \)'
                            
                            function GetVimIndentIntern()
                              " Find a non-blank line above the current line.
                              let lnum = prevnonblank(v:lnum - 1)
                            
                              " If the current line doesn't start with '\' or '"\ ' and below a line that
                              " starts with '\' or '"\ ', use the indent of the line above it.
                              let cur_text = getline(v:lnum)
                              if cur_text !~ s:lineContPat
                                while lnum > 0 && getline(lnum) =~ s:lineContPat
                                  let lnum = lnum - 1
                                endwhile
                              endif
                            
                              " At the start of the file use zero indent.
                              if lnum == 0
                                return 0
                              endif
                              let prev_text = getline(lnum)
                            
                              " Add a 'shiftwidth' after :if, :while, :try, :catch, :finally, :function
                              " and :else.  Add it three times for a line that starts with '\' or '"\ '
                              " after a line that doesn't (or g:vim_indent_cont if it exists).
                              let ind = indent(lnum)
                              if cur_text =~ s:lineContPat && v:lnum > 1 && prev_text !~ s:lineContPat
                                if exists("g:vim_indent_cont")
                                  let ind = ind + g:vim_indent_cont
                                else
                                  let ind = ind + shiftwidth() * 3
                                endif
                              elseif prev_text =~ '^\s*aug\%[roup]\s\+' && prev_text !~ '^\s*aug\%[roup]\s\+[eE][nN][dD]\>'
                                let ind = ind + shiftwidth()
                              else
                                " A line starting with :au does not increment/decrement indent.
                                if prev_text !~ '^\s*au\%[tocmd]'
                                  let i = match(prev_text, '\(^\||\)\s*\(if\|wh\%[ile]\|for\|try\|cat\%[ch]\|fina\%[lly]\|fu\%[nction]\|el\%[seif]\)\>')
                                  if i >= 0
                            	let ind += shiftwidth()
                            	if strpart(prev_text, i, 1) == '|' && has('syntax_items')
                            	      \ && synIDattr(synID(lnum, i, 1), "name") =~ '\(Comment\|String\)$'
                            	  let ind -= shiftwidth()
                            	endif
                                  endif
                                endif
                              endif
                            
                              " If the previous line contains an "end" after a pipe, but not in an ":au"
                              " command.  And not when there is a backslash before the pipe.
                              " And when syntax HL is enabled avoid a match inside a string.
                              let i = match(prev_text, '[^\\]|\s*\(ene\@!\)')
                              if i > 0 && prev_text !~ '^\s*au\%[tocmd]'
                                if !has('syntax_items') || synIDattr(synID(lnum, i + 2, 1), "name") !~ '\(Comment\|String\)$'
                                  let ind = ind - shiftwidth()
                                endif
                              endif
                            
                            
                              " Subtract a 'shiftwidth' on a :endif, :endwhile, :catch, :finally, :endtry,
                              " :endfun, :else and :augroup END.
                              if cur_text =~ '^\s*\(ene\@!\|cat\|fina\|el\|aug\%[roup]\s\+[eE][nN][dD]\)'
                                let ind = ind - shiftwidth()
                              endif
                            
                              return ind
                            endfunction
                            
                            let &cpo = s:keepcpo
                            unlet s:keepcpo
                            
                            " vim:sw=2

SCRIPT  /usr/local/Cellar/neovim/HEAD-c6cd608/share/nvim/runtime/syntax/vim.vim
Sourced 2 times
Total time:   0.029706
 Self time:   0.029706

count  total (s)   self (s)
                            " Vim syntax file
                            
                            " #############################################################################
                            " #############################################################################
                            " Note: Be careful when merging the upstream version of this file.
                            "       Much of this is generated by scripts/genvimvim.lua
                            "       (installs to $VIMRUNTIME/syntax/vim/generated.vim)
                            " #############################################################################
                            " #############################################################################
                            
                            " Quit when a syntax file was already loaded {{{2
    2              0.000020 if exists("b:current_syntax")
                              finish
                            endif
    2              0.000019 let s:keepcpo= &cpo
    2              0.000019 set cpo&vim
                            
                            " vimTodo: contains common special-notices for comments {{{2
                            " Use the vimCommentGroup cluster to add your own.
    2              0.000059 syn keyword vimTodo contained	COMBAK	FIXME	TODO	XXX
    2              0.000049 syn cluster vimCommentGroup	contains=vimTodo,@Spell
                            
                            " Special and plugin vim commands {{{2
    2              0.000036 syn match   vimCommand contained	"\<z[-+^.=]\=\>"
    2              0.000031 syn keyword vimOnlyCommand contained	fix[del] op[en] sh[ell] P[rint]
    2              0.000044 syn keyword vimStdPlugin contained	DiffOrig Man N[ext] S TOhtml XMLent XMLns
                            
                            " Vim-specific options {{{2
    2              0.000059 syn keyword vimOnlyOption contained	biosk bioskey cp compatible consk conskey cm cryptmethod edcompatible guipty key macatsui mzq mzquantum osfiletype oft renderoptions rop st shelltype sn shortname tenc termencoding ta textauto tx textmode tf ttyfast ttym ttymouse tbi ttybuiltin wiv weirdinvert
                            
                            " Turn-off setting variants
    2              0.000034 syn keyword vimOnlyOption contained	nobiosk nobioskey noconsk noconskey nocp nocompatible noguipty nomacatsui nosn noshortname nota notextauto notx notextmode notf nottyfast notbi nottybuiltin nowiv noweirdinvert
                            
                            " Invertible setting variants
    2              0.000027 syn keyword vimOnlyOption contained	invbiosk invbioskey invconsk invconskey invcp invcompatible invguipty invmacatsui invsn invshortname invta invtextauto invtx invtextmode invtf invttyfast invtbi invttybuiltin invwiv invweirdinvert
                            " termcap codes (which can also be set) {{{2
    2              0.000313 syn keyword vimTermOption contained	t_8b t_AB t_al t_bc t_ce t_cl t_Co t_Cs t_CV t_db t_DL t_F1 t_F2 t_F3 t_F4 t_F5 t_F6 t_F7 t_F8 t_F9 t_fs t_IE t_IS t_k1 t_K1 t_k2 t_k3 t_K3 t_k4 t_K4 t_k5 t_K5 t_k6 t_K6 t_k7 t_K7 t_k8 t_K8 t_k9 t_K9 t_KA t_kb t_kB t_KB t_KC t_kd t_kD t_KD t_ke t_KE t_KF t_KG t_kh t_KH t_kI t_KI t_KJ t_KK t_kl t_KL t_kN t_kP t_kr t_ks t_ku t_le t_mb t_md t_me t_mr t_ms t_nd t_op t_RB t_RI t_RV t_Sb t_se t_Sf t_SI t_so t_sr t_SR t_te t_ti t_ts t_u7 t_ue t_us t_ut t_vb t_ve t_vi t_vs t_WP t_WS t_xn t_xs t_ZH t_ZR
    2              0.000041 syn keyword vimTermOption contained	t_8f t_AF t_AL t_cd t_Ce t_cm t_cs t_CS t_da t_dl t_EI
    2              0.000029 syn match   vimTermOption contained	"t_%1"
    2              0.000024 syn match   vimTermOption contained	"t_#2"
    2              0.000020 syn match   vimTermOption contained	"t_#4"
    2              0.000055 syn match   vimTermOption contained	"t_@7"
    2              0.000022 syn match   vimTermOption contained	"t_*7"
    2              0.000021 syn match   vimTermOption contained	"t_&8"
    2              0.000019 syn match   vimTermOption contained	"t_%i"
    2              0.000018 syn match   vimTermOption contained	"t_k;"
                            
                            " unsupported settings: these are supported by vi but don't do anything in vim {{{2
    2              0.000042 syn keyword vimErrSetting contained	hardtabs ht w1200 w300 w9600 
                            "}}}2
    2              0.000003 syn case ignore
                            " Highlight commonly used Groupnames {{{2
    2              0.000052 syn keyword vimGroup contained	Comment Constant String Character Number Boolean Float Identifier Function Statement Conditional Repeat Label Operator Keyword Exception PreProc Include Define Macro PreCondit Type StorageClass Structure Typedef Special SpecialChar Tag Delimiter SpecialComment Debug Underlined Ignore Error Todo 
                            
                            " Default highlighting groups {{{2
    2              0.000079 syn keyword vimHLGroup contained	ColorColumn Cursor CursorColumn CursorIM CursorLine CursorLineNr DiffAdd DiffChange DiffDelete DiffText Directory EndOfBuffer ErrorMsg FoldColumn Folded IncSearch LineNr MatchParen Menu ModeMsg MoreMsg NonText Normal Pmenu PmenuSbar PmenuSel PmenuThumb Question Scrollbar Search SignColumn SpecialKey SpellBad SpellCap SpellLocal SpellRare StatusLine StatusLineNC TabLine TabLineFill TabLineSel Title Tooltip VertSplit Visual WarningMsg WildMenu 
    2              0.001207 syn match vimHLGroup contained	"Conceal"
    2              0.000068 syn keyword vimOnlyHLGroup contained	VisualNOS
    2              0.000021 syn keyword nvimHLGroup contained	Substitute TermCursor TermCursorNC QuickFixLine
                            "}}}2
    2              0.000003 syn case match
                            " Special Vim Highlighting (not automatic) {{{1
                            
                            " Set up folding commands
    2              0.000020 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# '[aflmpPrt]'
                             if g:vimsyn_folding =~# 'a'
                              com! -nargs=* VimFolda <args> fold
                             else
                              com! -nargs=* VimFolda <args>
                             endif
                             if g:vimsyn_folding =~# 'f'
                              com! -nargs=* VimFoldf <args> fold
                             else
                              com! -nargs=* VimFoldf <args>
                             endif
                             if g:vimsyn_folding =~# 'l'
                              com! -nargs=* VimFoldl <args> fold
                             else
                              com! -nargs=* VimFoldl <args>
                             endif
                             if g:vimsyn_folding =~# 'm'
                              com! -nargs=* VimFoldm <args> fold
                             else
                              com! -nargs=* VimFoldm <args>
                             endif
                             if g:vimsyn_folding =~# 'p' 
                              com! -nargs=* VimFoldp <args> fold 
                             else 
                              com! -nargs=* VimFoldp <args> 
                             endif
                             if g:vimsyn_folding =~# 'P'
                              com! -nargs=* VimFoldP <args> fold
                             else
                              com! -nargs=* VimFoldP <args>
                             endif
                             if g:vimsyn_folding =~# 'r'
                              com! -nargs=* VimFoldr <args> fold
                             else
                              com! -nargs=* VimFoldr <args>
                             endif
                             if g:vimsyn_folding =~# 't'
                              com! -nargs=* VimFoldt <args> fold
                             else
                              com! -nargs=* VimFoldt <args>
                             endif
                            else
    2              0.000035  com! -nargs=*	VimFolda	<args>
    2              0.000013  com! -nargs=*	VimFoldf	<args>
    2              0.000010  com! -nargs=*	VimFoldl	<args>
    2              0.000010  com! -nargs=*	VimFoldm	<args>
    2              0.000010  com! -nargs=*	VimFoldp	<args>
    2              0.000010  com! -nargs=*	VimFoldP	<args>
    2              0.000040  com! -nargs=*	VimFoldr	<args>
    2              0.000011  com! -nargs=*	VimFoldt	<args>
    2              0.000002 endif
                            
                            " commands not picked up by the generator (due to non-standard format)
    2              0.000025 syn keyword vimCommand contained	py3
                            
                            " Deprecated variable options {{{2
    2              0.000010 if exists("g:vim_minlines")
                             let g:vimsyn_minlines= g:vim_minlines
                            endif
    2              0.000006 if exists("g:vim_maxlines")
                             let g:vimsyn_maxlines= g:vim_maxlines
                            endif
    2              0.000006 if exists("g:vimsyntax_noerror")
                             let g:vimsyn_noerror= g:vimsyntax_noerror
                            endif
                            
                            " Variable options {{{2
    2              0.000005 if exists("g:vim_maxlines")
                             let s:vimsyn_maxlines= g:vim_maxlines
                            else
    2              0.000011  let s:vimsyn_maxlines= 60
    2              0.000002 endif
                            
                            " Numbers {{{2
                            " =======
    2              0.000122 syn match vimNumber	"\<\d\+\%(\.\d\+\%([eE][+-]\=\d\+\)\=\)\=" skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment
    2              0.000107 syn match vimNumber	"-\d\+\%(\.\d\+\%([eE][+-]\=\d\+\)\=\)\="  skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment
    2              0.000096 syn match vimNumber	"\<0[xX]\x\+"		       skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment
    2              0.000195 syn match vimNumber	"\%(^\|\A\)\zs#\x\{6}"             	       skipwhite nextgroup=vimGlobal,vimSubst,vimCommand,vimComment
                            
                            " All vimCommands are contained by vimIsCommands. {{{2
    2              0.000370 syn match vimCmdSep	"[:|]\+"	skipwhite nextgroup=vimAddress,vimAutoCmd,vimEcho,vimIsCommand,vimExtCmd,vimFilter,vimLet,vimMap,vimMark,vimSet,vimSyntax,vimUserCmd
    2              0.000052 syn match vimIsCommand	"\<\h\w*\>"	contains=vimCommand
    2              0.000032 syn match vimVar	      contained	"\<\h[a-zA-Z0-9#_]*\>"
    2              0.000024 syn match vimVar		"\<[bwglstav]:\h[a-zA-Z0-9#_]*\>"
    2              0.000043 syn match vimVar	      	"\s\zs&\a\+\>"
    2              0.000024 syn match vimFBVar      contained   "\<[bwglstav]:\h[a-zA-Z0-9#_]*\>"
    2              0.000017 syn keyword vimCommand  contained	in
                            
                            " Insertions And Appends: insert append {{{2
                            " =======================
    2              0.000064 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=a\%[ppend]$"		matchgroup=vimCommand end="^\.$""
    2              0.000059 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=c\%[hange]$"		matchgroup=vimCommand end="^\.$""
    2              0.000050 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=i\%[nsert]$"		matchgroup=vimCommand end="^\.$""
    2              0.000109 syn region vimInsert	matchgroup=vimCommand start="^[: \t]*\(\d\+\(,\d\+\)\=\)\=starti\%[nsert]$"	matchgroup=vimCommand end="^\.$""
                            
                            " Behave! {{{2
                            " =======
    2              0.000073 syn match   vimBehave	"\<be\%[have]\>" skipwhite nextgroup=vimBehaveModel,vimBehaveError
    2              0.000018 syn keyword vimBehaveModel contained	mswin	xterm
    2              0.000021 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_nobehaveerror")
    2              0.000024  syn match   vimBehaveError contained	"[^ ]\+"
    2              0.000004 endif
                            
                            " Filetypes {{{2
                            " =========
    2              0.000101 syn match   vimFiletype	"\<filet\%[ype]\(\s\+\I\i*\)*"	skipwhite contains=vimFTCmd,vimFTOption,vimFTError
    2              0.000016 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_vimFTError")
    2              0.000016  syn match   vimFTError  contained	"\I\i*"
    2              0.000002 endif
    2              0.000109 syn keyword vimFTCmd    contained	filet[ype]
    2              0.000014 syn keyword vimFTOption contained	detect indent off on plugin
                            
                            " Augroup : vimAugroupError removed because long augroups caused sync'ing problems. {{{2
                            " ======= : Trade-off: Increasing synclines with slower editing vs augroup END error checking.
    2              0.000554 syn cluster vimAugroupList	contains=vimAugroup,vimIsCommand,vimCommand,vimUserCmd,vimExecute,vimNotFunc,vimFuncName,vimFunction,vimFunctionError,vimLineComment,vimMap,vimSpecFile,vimOper,vimNumber,vimOperParen,vimComment,vimString,vimSubst,vimMark,vimRegister,vimAddress,vimFilter,vimCmplxRepeat,vimComment,vimLet,vimSet,vimAutoCmd,vimRegion,vimSynLine,vimNotation,vimCtrlChar,vimFuncVar,vimContinue,vimSetEqual,vimOption
    2              0.000042 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# 'a'
                             syn region  vimAugroup	fold matchgroup=vimAugroupKey start="\<aug\%[roup]\>\ze\s\+\K\k*" end="\<aug\%[roup]\>\ze\s\+[eE][nN][dD]\>"	contains=vimAutoCmd,@vimAugroupList
                            else
    2              0.000047  syn region  vimAugroup	matchgroup=vimAugroupKey start="\<aug\%[roup]\>\ze\s\+\K\k*" end="\<aug\%[roup]\>\ze\s\+[eE][nN][dD]\>"		contains=vimAutoCmd,@vimAugroupList
    2              0.000002 endif
    2              0.000048 syn match   vimAugroup	"aug\%[roup]!"	contains=vimAugroupKey
    2              0.000010 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_noaugrouperror")
    2              0.000033  syn match   vimAugroupError	"\<aug\%[roup]\>\s\+[eE][nN][dD]\>"
    2              0.000006 endif
    2              0.000021 syn keyword vimAugroupKey contained	aug[roup]
                            
                            " Operators: {{{2
                            " =========
    2              0.000181 syn cluster	vimOperGroup	contains=vimEnvvar,vimFunc,vimFuncVar,vimOper,vimOperParen,vimNumber,vimString,vimRegister,vimContinue
    2              0.000053 syn match	vimOper	"\%#=1\(==\|!=\|>=\|<=\|=\~\|!\~\|>\|<\|=\)[?#]\{0,2}"	skipwhite nextgroup=vimString,vimSpecFile
    2              0.000044 syn match	vimOper	"\(\<is\>\|\<isnot\>\)[?#]\{0,2}"		skipwhite nextgroup=vimString,vimSpecFile
    2              0.000060 syn match	vimOper	"||\|&&\|[-+.]"			skipwhite nextgroup=vimString,vimSpecFile
    2              0.000041 syn region	vimOperParen 	matchgroup=vimParenSep	start="(" end=")" contains=@vimOperGroup
    2              0.000066 syn region	vimOperParen	matchgroup=vimSep		start="{" end="}" contains=@vimOperGroup nextgroup=vimVar,vimFuncVar
    2              0.000012 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_noopererror")
    2              0.000013  syn match	vimOperError	")"
    2              0.000002 endif
                            
                            " Functions : Tag is provided for those who wish to highlight tagged functions {{{2
                            " =========
    2              0.000083 syn cluster	vimFuncList	contains=vimCommand,vimFunctionError,vimFuncKey,Tag,vimFuncSID
    2              0.000564 syn cluster	vimFuncBodyList	contains=vimAbb,vimAddress,vimAugroupKey,vimAutoCmd,vimCmplxRepeat,vimComment,vimContinue,vimCtrlChar,vimEcho,vimEchoHL,vimExecute,vimIsCommand,vimFBVar,vimFunc,vimFunction,vimFuncVar,vimGlobal,vimHighlight,vimIsCommand,vimLet,vimLineComment,vimMap,vimMark,vimNorm,vimNotation,vimNotFunc,vimNumber,vimOper,vimOperParen,vimRegion,vimRegister,vimSearch,vimSet,vimSpecFile,vimString,vimSubst,vimSynLine,vimUnmap,vimUserCommand
    2              0.000078 syn match	vimFunction	"\<fu\%[nction]!\=\s\+\%(<[sS][iI][dD]>\|[sSgGbBwWtTlL]:\)\=\%(\i\|[#.]\|{.\{-1,}}\)*\ze\s*("	contains=@vimFuncList nextgroup=vimFuncBody
                            
    2              0.000015 if exists("g:vimsyn_folding") && g:vimsyn_folding =~# 'f'
                             syn region	vimFuncBody  contained	fold start="\ze\s*("	matchgroup=vimCommand end="\<\(endf\>\|endfu\%[nction]\>\)"		contains=@vimFuncBodyList
                            else
    2              0.000047  syn region	vimFuncBody  contained	start="\ze\s*("	matchgroup=vimCommand end="\<\(endf\>\|endfu\%[nction]\>\)"		contains=@vimFuncBodyList
    2              0.000003 endif
    2              0.000026 syn match	vimFuncVar   contained	"a:\(\K\k*\|\d\+\)"
    2              0.000021 syn match	vimFuncSID   contained	"\c<sid>\|\<s:"
    2              0.000018 syn keyword	vimFuncKey   contained	fu[nction]
    2              0.000060 syn match	vimFuncBlank contained	"\s\+"
                            
    2              0.000012 syn keyword	vimPattern   contained	start	skip	end
                            
                            " Special Filenames, Modifiers, Extension Removal: {{{2
                            " ===============================================
    2              0.000041 syn match	vimSpecFile	"<c\(word\|WORD\)>"	nextgroup=vimSpecFileMod,vimSubst
    2              0.000042 syn match	vimSpecFile	"<\([acs]file\|amatch\|abuf\)>"	nextgroup=vimSpecFileMod,vimSubst
    2              0.000041 syn match	vimSpecFile	"\s%[ \t:]"ms=s+1,me=e-1	nextgroup=vimSpecFileMod,vimSubst
    2              0.000040 syn match	vimSpecFile	"\s%$"ms=s+1	nextgroup=vimSpecFileMod,vimSubst
    2              0.000040 syn match	vimSpecFile	"\s%<"ms=s+1,me=e-1	nextgroup=vimSpecFileMod,vimSubst
    2              0.000044 syn match	vimSpecFile	"#\d\+\|[#%]<\>"	nextgroup=vimSpecFileMod,vimSubst
    2              0.000016 syn match	vimSpecFileMod	"\(:[phtre]\)\+"	contained
                            
                            " User-Specified Commands: {{{2
                            " =======================
    2              0.000415 syn cluster	vimUserCmdList	contains=vimAddress,vimSyntax,vimHighlight,vimAutoCmd,vimCmplxRepeat,vimComment,vimCtrlChar,vimEscapeBrace,vimFilter,vimFunc,vimFuncName,vimFunction,vimFunctionError,vimIsCommand,vimMark,vimNotation,vimNumber,vimOper,vimRegion,vimRegister,vimLet,vimSet,vimSetEqual,vimSetString,vimSpecFile,vimString,vimSubst,vimSubstRep,vimSubstRange,vimSynLine
    2              0.000013 syn keyword	vimUserCommand	contained	com[mand]
    2              0.000072 syn match	vimUserCmd	"\<com\%[mand]!\=\>.*$"	contains=vimUserAttrb,vimUserAttrbError,vimUserCommand,@vimUserCmdList
    2              0.000015 syn match	vimUserAttrbError	contained	"-\a\+\ze\s"
    2              0.000050 syn match	vimUserAttrb	contained	"-nargs=[01*?+]"	contains=vimUserAttrbKey,vimOper
    2              0.000078 syn match	vimUserAttrb	contained	"-complete="		contains=vimUserAttrbKey,vimOper nextgroup=vimUserAttrbCmplt,vimUserCmdError
    2              0.000062 syn match	vimUserAttrb	contained	"-range\(=%\|=\d\+\)\="	contains=vimNumber,vimOper,vimUserAttrbKey
    2              0.000108 syn match	vimUserAttrb	contained	"-count\(=\d\+\)\="	contains=vimNumber,vimOper,vimUserAttrbKey
    2              0.000041 syn match	vimUserAttrb	contained	"-bang\>"		contains=vimOper,vimUserAttrbKey
    2              0.000038 syn match	vimUserAttrb	contained	"-bar\>"		contains=vimOper,vimUserAttrbKey
    2              0.000037 syn match	vimUserAttrb	contained	"-buffer\>"		contains=vimOper,vimUserAttrbKey
    2              0.000038 syn match	vimUserAttrb	contained	"-register\>"		contains=vimOper,vimUserAttrbKey
    2              0.000014 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_nousercmderror")
    2              0.000013  syn match	vimUserCmdError	contained	"\S\+\>"
    2              0.000002 endif
    2              0.000002 syn case ignore
    2              0.000072 syn keyword	vimUserAttrbKey   contained	bar	ban[g]	cou[nt]	ra[nge] com[plete]	n[args]	re[gister]
    2              0.000042 syn keyword	vimUserAttrbCmplt contained	augroup buffer behave color command compiler cscope dir environment event expression file file_in_path filetype function help highlight history locale mapping menu option packadd shellcmd sign syntax syntime tag tag_listfiles user var
    2              0.000040 syn keyword	vimUserAttrbCmplt contained	custom customlist nextgroup=vimUserAttrbCmpltFunc,vimUserCmdError
    2              0.000037 syn match	vimUserAttrbCmpltFunc contained	",\%([sS]:\|<[sS][iI][dD]>\)\=\%(\h\w*\%(#\h\w*\)\+\|\h\w*\)"hs=s+1 nextgroup=vimUserCmdError
                            
    2              0.000003 syn case match
    2              0.000020 syn match	vimUserAttrbCmplt contained	"custom,\u\w*"
                            
                            " Lower Priority Comments: after some vim commands... {{{2
                            " =======================
    2              0.000047 syn match	vimComment	excludenl +\s"[^\-:.%#=*].*$+lc=1	contains=@vimCommentGroup,vimCommentString
    2              0.000034 syn match	vimComment	+\<endif\s\+".*$+lc=5	contains=@vimCommentGroup,vimCommentString
    2              0.000029 syn match	vimComment	+\<else\s\+".*$+lc=4	contains=@vimCommentGroup,vimCommentString
    2              0.000020 syn region	vimCommentString	contained oneline start='\S\s\+"'ms=e	end='"'
                            
                            " Environment Variables: {{{2
                            " =====================
    2              0.000012 syn match	vimEnvvar	"\$\I\i*"
    2              0.000012 syn match	vimEnvvar	"\${\I\i*}"
                            
                            " In-String Specials: {{{2
                            " Try to catch strings, if nothing else matches (therefore it must precede the others!)
                            "  vimEscapeBrace handles ["]  []"] (ie. "s don't terminate string inside [])
    2              0.000054 syn region	vimEscapeBrace	oneline   contained transparent start="[^\\]\(\\\\\)*\[\zs\^\=\]\=" skip="\\\\\|\\\]" end="]"me=e-1
    2              0.000012 syn match	vimPatSepErr	contained	"\\)"
    2              0.000011 syn match	vimPatSep	contained	"\\|"
    2              0.000033 syn region	vimPatSepZone	oneline   contained   matchgroup=vimPatSepZ start="\\%\=\ze(" skip="\\\\" end="\\)\|[^\]['"]"	contains=@vimStringGroup
    2              0.000027 syn region	vimPatRegion	contained transparent matchgroup=vimPatSepR start="\\[z%]\=(" end="\\)"	contains=@vimSubstList oneline
    2              0.000011 syn match	vimNotPatSep	contained	"\\\\"
    2              0.000070 syn cluster	vimStringGroup	contains=vimEscapeBrace,vimPatSep,vimNotPatSep,vimPatSepErr,vimPatSepZone,@Spell
    2              0.000033 syn region	vimString	oneline keepend	start=+[^a-zA-Z>!\\@]"+lc=1 skip=+\\\\\|\\"+ matchgroup=vimStringEnd end=+"+	contains=@vimStringGroup
    2              0.000018 syn region	vimString	oneline keepend	start=+[^a-zA-Z>!\\@]'+lc=1 end=+'+
    2              0.000041 syn region	vimString	oneline	start=+=!+lc=1	skip=+\\\\\|\\!+ end=+!+	contains=@vimStringGroup
    2              0.000029 syn region	vimString	oneline	start="=+"lc=1	skip="\\\\\|\\+" end="+"	contains=@vimStringGroup
    2              0.000024 syn region	vimString	oneline	start="\s/\s*\A"lc=1 skip="\\\\\|\\+" end="/"	contains=@vimStringGroup
    2              0.000049 syn match	vimString	contained	+"[^"]*\\$+	skipnl nextgroup=vimStringCont
    2              0.000016 syn match	vimStringCont	contained	+\(\\\\\|.\)\{-}[^\\]"+
                            
                            " Substitutions: {{{2
                            " =============
    2              0.000078 syn cluster	vimSubstList	contains=vimPatSep,vimPatRegion,vimPatSepErr,vimSubstTwoBS,vimSubstRange,vimNotation
    2              0.000041 syn cluster	vimSubstRepList	contains=vimSubstSubstr,vimSubstTwoBS,vimNotation
    2              0.000018 syn cluster	vimSubstList	add=vimCollection
    2              0.000039 syn match	vimSubst	"\(:\+\s*\|^\s*\||\s*\)\<\%(\<s\%[ubstitute]\>\|\<sm\%[agic]\>\|\<sno\%[magic]\>\)[:#[:alpha:]]\@!" nextgroup=vimSubstPat
    2              0.000030 syn match	vimSubst	"\%(^\|[^\\]\)\<s\%[ubstitute]\>[:#[:alpha:]]\@!"	nextgroup=vimSubstPat contained
    2              0.000027 syn match	vimSubst	"/\zs\<s\%[ubstitute]\>\ze/"		nextgroup=vimSubstPat
    2              0.000031 syn match	vimSubst	"\(:\+\s*\|^\s*\)s\ze#.\{-}#.\{-}#"		nextgroup=vimSubstPat
    2              0.000026 syn match	vimSubst1       contained	"\<s\%[ubstitute]\>"	nextgroup=vimSubstPat
    2              0.000024 syn match	vimSubst2       contained	"s\%[ubstitute]\>"	nextgroup=vimSubstPat
    2              0.000049 syn region	vimSubstPat     contained	matchgroup=vimSubstDelim start="\z([^a-zA-Z( \t[\]&]\)"rs=s+1 skip="\\\\\|\\\z1" end="\z1"re=e-1,me=e-1	 contains=@vimSubstList	nextgroup=vimSubstRep4	oneline
    2              0.000065 syn region	vimSubstRep4    contained	matchgroup=vimSubstDelim start="\z(.\)" skip="\\\\\|\\\z1" end="\z1" matchgroup=vimNotation end="<[cC][rR]>" contains=@vimSubstRepList	nextgroup=vimSubstFlagErr	oneline
    2              0.000034 syn region	vimCollection   contained transparent	start="\\\@<!\[" skip="\\\[" end="\]"	contains=vimCollClass
    2              0.000012 syn match	vimCollClassErr contained	"\[:.\{-\}:\]"
    2              0.000030 syn match	vimCollClass    contained transparent	"\%#=1\[:\(alnum\|alpha\|blank\|cntrl\|digit\|graph\|lower\|print\|punct\|space\|upper\|xdigit\|return\|tab\|escape\|backspace\):\]"
    2              0.000011 syn match	vimSubstSubstr  contained	"\\z\=\d"
    2              0.000033 syn match	vimSubstTwoBS   contained	"\\\\"
    2              0.000030 syn match	vimSubstFlagErr contained	"[^< \t\r|]\+" contains=vimSubstFlags
    2              0.000013 syn match	vimSubstFlags   contained	"[&cegiIpr]\+"
                            
                            " 'String': {{{2
    2              0.000014 syn match	vimString	"[^(,]'[^']\{-}\zs'"
                            
                            " Marks, Registers, Addresses, Filters: {{{2
    2              0.000066 syn match	vimMark	"'[a-zA-Z0-9]\ze[-+,!]"	nextgroup=vimOper,vimMarkNumber,vimSubst
    2              0.000112 syn match	vimMark	"'[<>]\ze[-+,!]"		nextgroup=vimOper,vimMarkNumber,vimSubst
    2              0.000052 syn match	vimMark	",\zs'[<>]\ze"		nextgroup=vimOper,vimMarkNumber,vimSubst
    2              0.000055 syn match	vimMark	"[!,:]\zs'[a-zA-Z0-9]"	nextgroup=vimOper,vimMarkNumber,vimSubst
    2              0.000053 syn match	vimMark	"\<norm\%[al]\s\zs'[a-zA-Z0-9]"	nextgroup=vimOper,vimMarkNumber,vimSubst
    2              0.000038 syn match	vimMarkNumber	"[-+]\d\+"		contained contains=vimOper nextgroup=vimSubst2
    2              0.000013 syn match	vimPlainMark contained	"'[a-zA-Z0-9]"
                            
    2              0.000020 syn match	vimRegister	'[^,;[{: \t]\zs"[a-zA-Z0-9.%#:_\-/]\ze[^a-zA-Z_":0-9]'
    2              0.000014 syn match	vimRegister	'\<norm\s\+\zs"[a-zA-Z0-9]'
    2              0.000013 syn match	vimRegister	'\<normal\s\+\zs"[a-zA-Z0-9]'
    2              0.000012 syn match	vimRegister	'@"'
    2              0.000013 syn match	vimPlainRegister contained	'"[a-zA-Z0-9\-:.%#*+=]'
                            
    2              0.000025 syn match	vimAddress	",\zs[.$]"	skipwhite nextgroup=vimSubst1
    2              0.000037 syn match	vimAddress	"%\ze\a"	skipwhite nextgroup=vimString,vimSubst1
                            
    2              0.000028 syn match	vimFilter contained	"^!.\{-}\(|\|$\)"		contains=vimSpecFile
    2              0.000066 syn match	vimFilter contained	"\A!.\{-}\(|\|$\)"ms=s+1	contains=vimSpecFile,vimFunction,vimFuncName,vimOperParen
                            
                            " Complex repeats (:h complex-repeat) {{{2
    2              0.000015 syn match	vimCmplxRepeat	'[^a-zA-Z_/\\()]q[0-9a-zA-Z"]\>'lc=1
    2              0.000017 syn match	vimCmplxRepeat	'@[0-9a-z".=@:]\ze\($\|[^a-zA-Z]\>\)'
                            
                            " Set command and associated set-options (vimOptions) with comment {{{2
    2              0.000133 syn region	vimSet		matchgroup=vimCommand start="\<\%(setl\%[ocal]\|setg\%[lobal]\|se\%[t]\)\>" skip="\%(\\\\\)*\\." end="$" end="|" matchgroup=vimNotation end="<[cC][rR]>" keepend oneline contains=vimSetEqual,vimOption,vimErrSetting,vimComment,vimSetString,vimSetMod
    2              0.000076 syn region	vimSetEqual	contained	start="[=:]\|[-+^]=" skip="\\\\\|\\\s" end="[| \t]\|$"me=e-1	contains=vimCtrlChar,vimSetSep,vimNotation,vimEnvvar oneline
    2              0.000035 syn region	vimSetString	contained	start=+="+hs=s+1	skip=+\\\\\|\\"+  end=+"+		contains=vimCtrlChar
    2              0.000034 syn match	vimSetSep	contained	"[,:]" skipwhite nextgroup=vimCommand
    2              0.000021 syn match	vimSetMod	contained	"&vim\=\|[!&?<]\|all&"
                            
                            " Let {{{2
                            " ===
    2              0.000139 syn keyword	vimLet	let	unl[et]	skipwhite nextgroup=vimVar,vimFuncVar
                            
                            " Abbreviations {{{2
                            " =============
    2              0.000102 syn keyword vimAbb	ab[breviate] ca[bbrev] inorea[bbrev] cnorea[bbrev] norea[bbrev] ia[bbrev] skipwhite nextgroup=vimMapMod,vimMapLhs
                            
                            " Autocmd {{{2
                            " =======
    2              0.000062 syn match	vimAutoEventList	contained	"\(!\s\+\)\=\(\a\+,\)*\a\+"	contains=vimAutoEvent,nvimAutoEvent nextgroup=vimAutoCmdSpace
    2              0.000026 syn match	vimAutoCmdSpace	contained	"\s\+"	nextgroup=vimAutoCmdSfxList
    2              0.000012 syn match	vimAutoCmdSfxList	contained	"\S*"
    2              0.000034 syn keyword	vimAutoCmd	au[tocmd] do[autocmd] doautoa[ll]	skipwhite nextgroup=vimAutoEventList
                            
                            " Echo and Execute -- prefer strings! {{{2
                            " ================
    2              0.000089 syn region	vimEcho	oneline excludenl matchgroup=vimCommand start="\<ec\%[ho]\>" skip="\(\\\\\)*\\|" end="$\||" contains=vimFunc,vimFuncVar,vimString,vimVar
    2              0.000316 syn region	vimExecute	oneline excludenl matchgroup=vimCommand start="\<exe\%[cute]\>" skip="\(\\\\\)*\\|" end="$\||\|<[cC][rR]>" contains=vimFuncVar,vimIsCommand,vimOper,vimNotation,vimOperParen,vimString,vimVar
    2              0.000090 syn match	vimEchoHL	"echohl\="	skipwhite nextgroup=vimGroup,vimHLGroup,vimEchoHLNone,vimOnlyHLGroup,nvimHLGroup
    2              0.000005 syn case ignore
    2              0.000011 syn keyword	vimEchoHLNone	none
    2              0.000002 syn case match
                            
                            " Maps {{{2
                            " ====
    2              0.000053 syn match	vimMap		"\<map\>!\=\ze\s*[^(]" skipwhite nextgroup=vimMapMod,vimMapLhs
    2              0.000102 syn keyword	vimMap		cm[ap] cno[remap] im[ap] ino[remap] lm[ap] ln[oremap] nm[ap] nn[oremap] no[remap] om[ap] ono[remap] smap snor[emap] vm[ap] vn[oremap] xm[ap] xn[oremap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    2              0.000051 syn keyword	nvimMap		tn[oremap] tm[ap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    2              0.000013 syn keyword	vimMap		mapc[lear] smapc[lear]
    2              0.000069 syn keyword	vimUnmap		cu[nmap] iu[nmap] lu[nmap] nun[map] ou[nmap] sunm[ap] unm[ap] unm[ap] vu[nmap] xu[nmap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    2              0.000045 syn keyword	nvimUnmap 		tunm[ap] skipwhite nextgroup=vimMapBang,vimMapMod,vimMapLhs
    2              0.000052 syn match	vimMapLhs	contained	"\S\+"			contains=vimNotation,vimCtrlChar skipwhite nextgroup=vimMapRhs
    2              0.000035 syn match	vimMapBang	contained	"!"			skipwhite nextgroup=vimMapMod,vimMapLhs
    2              0.000098 syn match	vimMapMod	contained	"\%#=1\c<\(buffer\|expr\|\(local\)\=leader\|nowait\|plug\|script\|sid\|unique\|silent\)\+>" contains=vimMapModKey,vimMapModErr skipwhite nextgroup=vimMapMod,vimMapLhs
    2              0.000053 syn match	vimMapRhs	contained	".*" contains=vimNotation,vimCtrlChar	skipnl nextgroup=vimMapRhsExtend
    2              0.000031 syn match	vimMapRhsExtend	contained	"^\s*\\.*$"			contains=vimContinue
    2              0.000003 syn case ignore
    2              0.000017 syn keyword	vimMapModKey	contained	buffer	expr	leader	localleader	nowait	plug	script	sid	silent	unique
    2              0.000002 syn case match
                            
                            " Menus {{{2
                            " =====
    2              0.000056 syn cluster	vimMenuList contains=vimMenuBang,vimMenuPriority,vimMenuName,vimMenuMod
    2              0.000054 syn keyword	vimCommand	am[enu] an[oremenu] aun[menu] cme[nu] cnoreme[nu] cunme[nu] ime[nu] inoreme[nu] iunme[nu] me[nu] nme[nu] nnoreme[nu] noreme[nu] nunme[nu] ome[nu] onoreme[nu] ounme[nu] unme[nu] vme[nu] vnoreme[nu] vunme[nu] skipwhite nextgroup=@vimMenuList
    2              0.000043 syn match	vimMenuName	"[^ \t\\<]\+"	contained nextgroup=vimMenuNameMore,vimMenuMap
    2              0.000025 syn match	vimMenuPriority	"\d\+\(\.\d\+\)*"	contained skipwhite nextgroup=vimMenuName
    2              0.000066 syn match	vimMenuNameMore	"\c\\\s\|<tab>\|\\\."	contained nextgroup=vimMenuName,vimMenuNameMore contains=vimNotation
    2              0.000043 syn match	vimMenuMod    contained	"\c<\(script\|silent\)\+>"  skipwhite contains=vimMapModKey,vimMapModErr nextgroup=@vimMenuList
    2              0.000022 syn match	vimMenuMap	"\s"	contained skipwhite nextgroup=vimMenuRhs
    2              0.000051 syn match	vimMenuRhs	".*$"	contained contains=vimString,vimComment,vimIsCommand
    2              0.000013 syn match	vimMenuBang	"!"	contained skipwhite nextgroup=@vimMenuList
                            
                            " Angle-Bracket Notation (tnx to Michael Geddes) {{{2
                            " ======================
    2              0.000005 syn case ignore
    2              0.000077 syn match	vimNotation	"\%#=1\(\\\|<lt>\)\=<\([scamd]-\)\{0,4}x\=\(f\d\{1,2}\|[^ \t:]\|cmd\|cr\|lf\|linefeed\|return\|k\=del\%[ete]\|bs\|backspace\|tab\|esc\|right\|left\|help\|undo\|insert\|ins\|mouse\|k\=home\|k\=end\|kplus\|kminus\|kdivide\|kmultiply\|kenter\|kpoint\|space\|k\=\(page\)\=\(\|down\|up\|k\d\>\)\)>" contains=vimBracket
    2              0.000081 syn match	vimNotation	"\%#=1\(\\\|<lt>\)\=<\([scam2-4]-\)\{0,4}\(right\|left\|middle\)\(mouse\)\=\(drag\|release\)\=>"	contains=vimBracket
    2              0.000032 syn match	vimNotation	"\%#=1\(\\\|<lt>\)\=<\(bslash\|plug\|sid\|space\|bar\|nop\|nul\|lt\)>"			contains=vimBracket
    2              0.000033 syn match	vimNotation	'\(\\\|<lt>\)\=<C-R>[0-9a-z"%#:.\-=]'he=e-1				contains=vimBracket
    2              0.000036 syn match	vimNotation	'\%#=1\(\\\|<lt>\)\=<\%(q-\)\=\(line[12]\|count\|bang\|reg\|args\|mods\|f-args\|f-mods\|lt\)>'	contains=vimBracket
    2              0.000031 syn match	vimNotation	"\%#=1\(\\\|<lt>\)\=<\([cas]file\|abuf\|amatch\|cword\|cWORD\|client\)>"		contains=vimBracket
    2              0.000012 syn match	vimBracket contained	"[\\<>]"
    2              0.000002 syn case match
                            
                            " User Function Highlighting {{{2
                            " (following Gautam Iyer's suggestion)
                            " ==========================
    2              0.000063 syn match vimFunc		"\%(\%([sSgGbBwWtTlL]:\|<[sS][iI][dD]>\)\=\%(\w\+\.\)*\I[a-zA-Z0-9_.]*\)\ze\s*("		contains=vimFuncName,vimUserFunc,vimExecute
    2              0.000036 syn match vimUserFunc contained	"\%(\%([sSgGbBwWtTlL]:\|<[sS][iI][dD]>\)\=\%(\w\+\.\)*\I[a-zA-Z0-9_.]*\)\|\<\u[a-zA-Z0-9.]*\>\|\<if\>"	contains=vimNotation
    2              0.000023 syn match vimNotFunc	"\<if\>\|\<el\%[seif]\>\|\<return\>\|\<while\>"
                            
                            " Errors And Warnings: {{{2
                            " ====================
    2              0.000020 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimfunctionerror")
    2              0.000045  syn match	vimFunctionError	"\s\zs[a-z0-9]\i\{-}\ze\s*("			contained contains=vimFuncKey,vimFuncBlank
                            " syn match	vimFunctionError	"\s\zs\%(<[sS][iI][dD]>\|[sSgGbBwWtTlL]:\)\d\i\{-}\ze\s*("	contained contains=vimFuncKey,vimFuncBlank
    2              0.000013  syn match	vimElseIfErr	"\<else\s\+if\>"
    2              0.000014  syn match	vimBufnrWarn	/\<bufnr\s*(\s*["']\.['"]\s*)/
    2              0.000003 endif
                            
                            " Norm {{{2
                            " ====
    2              0.000025 syn match	vimNorm		"\<norm\%[al]!\=" skipwhite nextgroup=vimNormCmds
    2              0.000016 syn match	vimNormCmds contained	".*$"
                            
                            " Syntax {{{2
                            "=======
    2              0.000042 syn match	vimGroupList	contained	"@\=[^ \t,]*"	contains=vimGroupSpecial,vimPatSep
    2              0.000067 syn match	vimGroupList	contained	"@\=[^ \t,]*,"	nextgroup=vimGroupList contains=vimGroupSpecial,vimPatSep
    2              0.000012 syn keyword	vimGroupSpecial	contained	ALL	ALLBUT	CONTAINED	TOP
    2              0.000010 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsynerror")
    2              0.000012  syn match	vimSynError	contained	"\i\+"
    2              0.000023  syn match	vimSynError	contained	"\i\+="	nextgroup=vimGroupList
    2              0.000002 endif
    2              0.000027 syn match	vimSynContains	contained	"\<contain\(s\|edin\)="	nextgroup=vimGroupList
    2              0.000027 syn match	vimSynKeyContainedin	contained	"\<containedin="	nextgroup=vimGroupList
    2              0.000023 syn match	vimSynNextgroup	contained	"nextgroup="	nextgroup=vimGroupList
                            
    2              0.000054 syn match	vimSyntax	"\<sy\%[ntax]\>"	contains=vimCommand skipwhite nextgroup=vimSynType,vimComment
    2              0.000052 syn match	vimAuSyntax	contained	"\s+sy\%[ntax]"	contains=vimCommand skipwhite nextgroup=vimSynType,vimComment
    2              0.000027 syn cluster vimFuncBodyList add=vimSyntax
                            
                            " Syntax: case {{{2
    2              0.000033 syn keyword	vimSynType	contained	case	skipwhite nextgroup=vimSynCase,vimSynCaseError
    2              0.000010 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsyncaseerror")
    2              0.000011  syn match	vimSynCaseError	contained	"\i\+"
    2              0.000002 endif
    2              0.000009 syn keyword	vimSynCase	contained	ignore	match
                            
                            " Syntax: clear {{{2
    2              0.000021 syn keyword	vimSynType	contained	clear	skipwhite nextgroup=vimGroupList
                            
                            " Syntax: cluster {{{2
    2              0.000021 syn keyword	vimSynType	contained	cluster	skipwhite nextgroup=vimClusterName
    2              0.000085 syn region	vimClusterName	contained	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" matchgroup=vimSep end="$\||" contains=vimGroupAdd,vimGroupRem,vimSynContains,vimSynError
    2              0.000023 syn match	vimGroupAdd	contained	"add="	nextgroup=vimGroupList
    2              0.000022 syn match	vimGroupRem	contained	"remove="	nextgroup=vimGroupList
    2              0.000039 syn cluster vimFuncBodyList add=vimSynType,vimGroupAdd,vimGroupRem
                            
                            " Syntax: iskeyword {{{2
    2              0.000038 syn keyword	vimSynType	contained	iskeyword	skipwhite nextgroup=vimIskList
    2              0.000028 syn match	vimIskList	contained	'\S\+'	contains=vimIskSep
    2              0.000011 syn match	vimIskSep	contained	','
                            
                            " Syntax: include {{{2
    2              0.000020 syn keyword	vimSynType	contained	include	skipwhite nextgroup=vimGroupList
    2              0.000017 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: keyword {{{2
    2              0.000082 syn cluster	vimSynKeyGroup	contains=vimSynNextgroup,vimSynKeyOpt,vimSynKeyContainedin
    2              0.000021 syn keyword	vimSynType	contained	keyword	skipwhite nextgroup=vimSynKeyRegion
    2              0.000037 syn region	vimSynKeyRegion	contained oneline keepend	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" matchgroup=vimSep end="|\|$" contains=@vimSynKeyGroup
    2              0.000108 syn match	vimSynKeyOpt	contained	"\%#=1\<\(conceal\|contained\|transparent\|skipempty\|skipwhite\|skipnl\)\>"
    2              0.000019 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: match {{{2
    2              0.000084 syn cluster	vimSynMtchGroup	contains=vimMtchComment,vimSynContains,vimSynError,vimSynMtchOpt,vimSynNextgroup,vimSynRegPat,vimNotation
    2              0.000021 syn keyword	vimSynType	contained	match	skipwhite nextgroup=vimSynMatchRegion
    2              0.000035 syn region	vimSynMatchRegion	contained keepend	matchgroup=vimGroupName start="\h\w*" matchgroup=vimSep end="|\|$" contains=@vimSynMtchGroup
    2              0.000025 syn match	vimSynMtchOpt	contained	"\%#=1\<\(conceal\|transparent\|contained\|excludenl\|keepend\|skipempty\|skipwhite\|display\|extend\|skipnl\|fold\)\>"
    2              0.000008 if has("conceal")
    2              0.000027  syn match	vimSynMtchOpt	contained	"\<cchar="	nextgroup=vimSynMtchCchar
    2              0.000041  syn match	vimSynMtchCchar	contained	"\S"
    2              0.000002 endif
    2              0.000018 syn cluster vimFuncBodyList add=vimSynMtchGroup
                            
                            " Syntax: off and on {{{2
    2              0.000012 syn keyword	vimSynType	contained	enable	list	manual	off	on	reset
                            
                            " Syntax: region {{{2
    2              0.000101 syn cluster	vimSynRegPatGroup	contains=vimPatSep,vimNotPatSep,vimSynPatRange,vimSynNotPatRange,vimSubstSubstr,vimPatRegion,vimPatSepErr,vimNotation
    2              0.000059 syn cluster	vimSynRegGroup	contains=vimSynContains,vimSynNextgroup,vimSynRegOpt,vimSynReg,vimSynMtchGrp
    2              0.000041 syn keyword	vimSynType	contained	region	skipwhite nextgroup=vimSynRegion
    2              0.000030 syn region	vimSynRegion	contained keepend	matchgroup=vimGroupName start="\h\w*" skip="\\\\\|\\|" end="|\|$" contains=@vimSynRegGroup
    2              0.000028 syn match	vimSynRegOpt	contained	"\%#=1\<\(conceal\(ends\)\=\|transparent\|contained\|excludenl\|skipempty\|skipwhite\|display\|keepend\|oneline\|extend\|skipnl\|fold\)\>"
    2              0.000030 syn match	vimSynReg	contained	"\(start\|skip\|end\)="he=e-1	nextgroup=vimSynRegPat
    2              0.000068 syn match	vimSynMtchGrp	contained	"matchgroup="	nextgroup=vimGroup,vimHLGroup,vimOnlyHLGroup,nvimHLGroup
    2              0.000049 syn region	vimSynRegPat	contained extend	start="\z([-`~!@#$%^&*_=+;:'",./?]\)"  skip="\\\\\|\\\z1"  end="\z1"  contains=@vimSynRegPatGroup skipwhite nextgroup=vimSynPatMod,vimSynReg
    2              0.000020 syn match	vimSynPatMod	contained	"\%#=1\(hs\|ms\|me\|hs\|he\|rs\|re\)=[se]\([-+]\d\+\)\="
    2              0.000027 syn match	vimSynPatMod	contained	"\%#=1\(hs\|ms\|me\|hs\|he\|rs\|re\)=[se]\([-+]\d\+\)\=," nextgroup=vimSynPatMod
    2              0.000011 syn match	vimSynPatMod	contained	"lc=\d\+"
    2              0.000040 syn match	vimSynPatMod	contained	"lc=\d\+," nextgroup=vimSynPatMod
    2              0.000024 syn region	vimSynPatRange	contained	start="\["	skip="\\\\\|\\]"   end="]"
    2              0.000011 syn match	vimSynNotPatRange	contained	"\\\\\|\\\["
    2              0.000012 syn match	vimMtchComment	contained	'"[^"]\+$'
    2              0.000019 syn cluster vimFuncBodyList add=vimSynType
                            
                            " Syntax: sync {{{2
                            " ============
    2              0.000086 syn keyword vimSynType	contained	sync	skipwhite	nextgroup=vimSyncC,vimSyncLines,vimSyncMatch,vimSyncError,vimSyncLinebreak,vimSyncLinecont,vimSyncRegion
    2              0.000011 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimsyncerror")
    2              0.000011  syn match	vimSyncError	contained	"\i\+"
    2              0.000002 endif
    2              0.000011 syn keyword	vimSyncC	contained	ccomment	clear	fromstart
    2              0.000020 syn keyword	vimSyncMatch	contained	match	skipwhite	nextgroup=vimSyncGroupName
    2              0.000025 syn keyword	vimSyncRegion	contained	region	skipwhite	nextgroup=vimSynReg
    2              0.000053 syn match	vimSyncLinebreak	contained	"\<linebreaks="	skipwhite	nextgroup=vimNumber
    2              0.000032 syn keyword	vimSyncLinecont	contained	linecont	skipwhite	nextgroup=vimSynRegPat
    2              0.000049 syn match	vimSyncLines	contained	"\(min\|max\)\=lines="	nextgroup=vimNumber
    2              0.000033 syn match	vimSyncGroupName	contained	"\h\w*"	skipwhite	nextgroup=vimSyncKey
    2              0.000035 syn match	vimSyncKey	contained	"\<groupthere\|grouphere\>"	skipwhite nextgroup=vimSyncGroup
    2              0.000047 syn match	vimSyncGroup	contained	"\h\w*"	skipwhite	nextgroup=vimSynRegPat,vimSyncNone
    2              0.000012 syn keyword	vimSyncNone	contained	NONE
                            
                            " Additional IsCommand, here by reasons of precedence {{{2
                            " ====================
    2              0.000104 syn match	vimIsCommand	"<Bar>\s*\a\+"	transparent contains=vimCommand,vimNotation
                            
                            " Highlighting {{{2
                            " ============
    2              0.000056 syn cluster	vimHighlightCluster		contains=vimHiLink,vimHiClear,vimHiKeyList,vimComment
    2              0.000014 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_novimhictermerror")
    2              0.000020  syn match	vimHiCtermError	contained	"\D\i*"
    2              0.000023 endif
    2              0.000054 syn match	vimHighlight	"\<hi\%[ghlight]\>"	skipwhite nextgroup=vimHiBang,@vimHighlightCluster
    2              0.000080 syn match	vimHiBang	contained	"!"	skipwhite nextgroup=@vimHighlightCluster
                            
    2              0.000012 syn match	vimHiGroup	contained	"\i\+"
    2              0.000018 syn case ignore
    2              0.000020 syn keyword	vimHiAttrib	contained	none bold inverse italic nocombine reverse standout strikethrough underline undercurl
    2              0.000012 syn keyword	vimFgBgAttrib	contained	none bg background fg foreground
    2              0.000002 syn case match
    2              0.000080 syn match	vimHiAttribList	contained	"\i\+"	contains=vimHiAttrib
    2              0.000073 syn match	vimHiAttribList	contained	"\i\+,"he=e-1	contains=vimHiAttrib nextgroup=vimHiAttribList
    2              0.000007 syn case ignore
    2              0.000147 syn keyword	vimHiCtermColor	contained	black blue brown cyan darkblue darkcyan darkgray darkgreen darkgrey darkmagenta darkred darkyellow gray green grey lightblue lightcyan lightgray lightgreen lightgrey lightmagenta lightred magenta red white yellow
    2              0.000018 syn match	vimHiCtermColor	contained	"\<color\d\{1,3}\>"
                            
    2              0.000002 syn case match
    2              0.000017 syn match	vimHiFontname	contained	"[a-zA-Z\-*]\+"
    2              0.000019 syn match	vimHiGuiFontname	contained	"'[a-zA-Z\-* ]\+'"
    2              0.000012 syn match	vimHiGuiRgb	contained	"#\x\{6}"
                            
                            " Highlighting: hi group key=arg ... {{{2
    2              0.000200 syn cluster	vimHiCluster contains=vimGroup,vimHiGroup,vimHiTerm,vimHiCTerm,vimHiStartStop,vimHiCtermFgBg,vimHiGui,vimHiGuiFont,vimHiGuiFgBg,vimHiKeyError,vimNotation
    2              0.000040 syn region	vimHiKeyList	contained oneline start="\i\+" skip="\\\\\|\\|" end="$\||"	contains=@vimHiCluster
    2              0.000040 if !exists("g:vimsyn_noerror") && !exists("g:vimsyn_vimhikeyerror")
    2              0.000018  syn match	vimHiKeyError	contained	"\i\+="he=e-1
    2              0.000003 endif
    2              0.000034 syn match	vimHiTerm	contained	"\cterm="he=e-1		nextgroup=vimHiAttribList
    2              0.000192 syn match	vimHiStartStop	contained	"\c\(start\|stop\)="he=e-1	nextgroup=vimHiTermcap,vimOption
    2              0.000038 syn match	vimHiCTerm	contained	"\ccterm="he=e-1		nextgroup=vimHiAttribList
    2              0.000070 syn match	vimHiCtermFgBg	contained	"\ccterm[fb]g="he=e-1	nextgroup=vimHiNmbr,vimHiCtermColor,vimFgBgAttrib,vimHiCtermError
    2              0.000032 syn match	vimHiGui	contained	"\cgui="he=e-1		nextgroup=vimHiAttribList
    2              0.000030 syn match	vimHiGuiFont	contained	"\cfont="he=e-1		nextgroup=vimHiFontname
    2              0.000104 syn match	vimHiGuiFgBg	contained	"\cgui\%([fb]g\|sp\)="he=e-1	nextgroup=vimHiGroup,vimHiGuiFontname,vimHiGuiRgb,vimFgBgAttrib
    2              0.000026 syn match	vimHiTermcap	contained	"\S\+"		contains=vimNotation
    2              0.000010 syn match	vimHiNmbr	contained	'\d\+'
                            
                            " Highlight: clear {{{2
    2              0.000022 syn keyword	vimHiClear	contained	clear	nextgroup=vimHiGroup
                            
                            " Highlight: link {{{2
                            " see tst24 (hi def vs hi) (Jul 06, 2018)
                            "syn region	vimHiLink	contained oneline matchgroup=vimCommand start="\(\<hi\%[ghlight]\s\+\)\@<=\(\(def\%[ault]\s\+\)\=link\>\|\<def\>\)" end="$"	contains=vimHiGroup,vimGroup,vimHLGroup,vimNotation
    2              0.000049 syn region	vimHiLink	contained oneline matchgroup=vimCommand start="\(\<hi\%[ghlight]\s\+\)\@<=\(\(def\%[ault]\s\+\)\=link\>\|\<def\>\)" end="$"	contains=@vimHiCluster
    2              0.000021 syn cluster vimFuncBodyList add=vimHiLink
                            
                            " Control Characters {{{2
                            " ==================
    2              0.000013 syn match	vimCtrlChar	"[--]"
                            
                            " Beginners - Patterns that involve ^ {{{2
                            " =========
    2              0.000051 syn match	vimLineComment	+^[ \t:]*".*$+	contains=@vimCommentGroup,vimCommentString,vimCommentTitle
    2              0.000047 syn match	vimCommentTitle	'"\s*\%([sS]:\|\h\w*#\)\=\u\w*\(\s\+\u\w*\)*:'hs=s+1	contained contains=vimCommentTitleLeader,vimTodo,@vimCommentGroup
    2              0.000012 syn match	vimContinue	"^\s*\\"
    2              0.000041 syn region	vimString	start="^\s*\\\z(['"]\)" skip='\\\\\|\\\z1' end="\z1" oneline keepend contains=@vimStringGroup,vimContinue
    2              0.000031 syn match	vimCommentTitleLeader	'"\s\+'ms=s+1	contained
                            
                            " Searches And Globals: {{{2
                            " ====================
    2              0.000033 syn match	vimSearch	'^\s*[/?].*'		contains=vimSearchDelim
    2              0.000022 syn match	vimSearchDelim	'^\s*\zs[/?]\|[/?]$'	contained
    2              0.000051 syn region	vimGlobal	matchgroup=Statement start='\<g\%[lobal]!\=/'  skip='\\.' end='/'	skipwhite nextgroup=vimSubst
    2              0.000050 syn region	vimGlobal	matchgroup=Statement start='\<v\%[global]!\=/' skip='\\.' end='/'	skipwhite nextgroup=vimSubst
                            
                            " Scripts  : perl,ruby : Benoit Cerrina {{{2
                            " =======    python,tcl: Johannes Zellner
                            "            lua
                            
                            " Allows users to specify the type of embedded script highlighting
                            " they want:  (perl/python/ruby/tcl support)
                            "   g:vimsyn_embed == 0   : don't embed any scripts
                            "   g:vimsyn_embed =~# 'l' : embed lua
                            "   g:vimsyn_embed =~# 'm' : embed mzscheme
                            "   g:vimsyn_embed =~# 'p' : embed perl
                            "   g:vimsyn_embed =~# 'P' : embed python
                            "   g:vimsyn_embed =~# 'r' : embed ruby
                            "   g:vimsyn_embed =~# 't' : embed tcl
    2              0.000030 if !exists("g:vimsyn_embed")
                             let g:vimsyn_embed= 0
                            endif
                            
                            " [-- lua --] {{{3
    2              0.000092 let s:luapath= fnameescape(expand("<sfile>:p:h")."/lua.vim")
    2              0.001219 if !filereadable(s:luapath)
                             for s:luapath in split(globpath(&rtp,"syntax/lua.vim"),"\n")
                              if filereadable(fnameescape(s:luapath))
                               let s:luapath= fnameescape(s:luapath)
                               break
                              endif
                             endfor
                            endif
    2              0.000022 if g:vimsyn_embed =~# 'l' && filereadable(s:luapath)
                             unlet! b:current_syntax
                             syn cluster vimFuncBodyList	add=vimLuaRegion
                             exe "syn include @vimLuaScript ".s:luapath
                             VimFoldl syn region vimLuaRegion matchgroup=vimScriptDelim start=+lua\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimLuaScript
                             VimFoldl syn region vimLuaRegion matchgroup=vimScriptDelim start=+lua\s*<<\s*$+ end=+\.$+		contains=@vimLuaScript
                             syn cluster vimFuncBodyList	add=vimLuaRegion
                            else
    2              0.000075  syn region vimEmbedError start=+lua\s*<<\s*\z(.*\)$+ end=+^\z1$+
    2              0.000046  syn region vimEmbedError start=+lua\s*<<\s*$+ end=+\.$+
    2              0.000003 endif
    2              0.000007 unlet s:luapath
                            
                            " [-- perl --] {{{3
    2              0.000085 let s:perlpath= fnameescape(expand("<sfile>:p:h")."/perl.vim")
    2              0.001032 if !filereadable(s:perlpath)
                             for s:perlpath in split(globpath(&rtp,"syntax/perl.vim"),"\n")
                              if filereadable(fnameescape(s:perlpath))
                               let s:perlpath= fnameescape(s:perlpath)
                               break
                              endif
                             endfor
                            endif
    2              0.000017 if g:vimsyn_embed =~# 'p' && filereadable(s:perlpath)
                             unlet! b:current_syntax
                             syn cluster vimFuncBodyList	add=vimPerlRegion
                             let s:foldmethod = &l:foldmethod
                             exe "syn include @vimPerlScript ".s:perlpath
                             let &l:foldmethod = s:foldmethod
                             VimFoldp syn region vimPerlRegion  matchgroup=vimScriptDelim start=+pe\%[rl]\s*<<\s*\z(\S*\)\ze\(\s*["#].*\)\=$+ end=+^\z1\ze\(\s*[#"].*\)\=$+	contains=@vimPerlScript
                             VimFoldp syn region vimPerlRegion	matchgroup=vimScriptDelim start=+pe\%[rl]\s*<<\s*$+ end=+\.$+			contains=@vimPerlScript
                             syn cluster vimFuncBodyList	add=vimPerlRegion
                            else
    2              0.000041  syn region vimEmbedError start=+pe\%[rl]\s*<<\s*\z(.*\)$+ end=+^\z1$+
    2              0.000026  syn region vimEmbedError start=+pe\%[rl]\s*<<\s*$+ end=+\.$+
    2              0.000002 endif
    2              0.000004 unlet s:perlpath
                            
                            " [-- ruby --] {{{3
    2              0.000061 let s:rubypath= fnameescape(expand("<sfile>:p:h")."/ruby.vim")
    2              0.000468 if !filereadable(s:rubypath)
                             for s:rubypath in split(globpath(&rtp,"syntax/ruby.vim"),"\n")
                              if filereadable(fnameescape(s:rubypath))
                               let s:rubypath= fnameescape(s:rubypath)
                               break
                              endif
                             endfor
                            endif
    2              0.000021 if g:vimsyn_embed =~# 'r' && filereadable(s:rubypath)
                             syn cluster vimFuncBodyList	add=vimRubyRegion
                             unlet! b:current_syntax
                             let s:foldmethod = &l:foldmethod
                             exe "syn include @vimRubyScript ".s:rubypath
                             let &l:foldmethod = s:foldmethod
                             VimFoldr syn region vimRubyRegion	matchgroup=vimScriptDelim start=+rub[y]\s*<<\s*\z(\S*\)\ze\(\s*#.*\)\=$+ end=+^\z1\ze\(\s*".*\)\=$+	contains=@vimRubyScript
                             syn region vimRubyRegion	matchgroup=vimScriptDelim start=+rub[y]\s*<<\s*$+ end=+\.$+			contains=@vimRubyScript
                             syn cluster vimFuncBodyList	add=vimRubyRegion
                            else
    2              0.000031  syn region vimEmbedError start=+rub[y]\s*<<\s*\z(.*\)$+ end=+^\z1$+
    2              0.000021  syn region vimEmbedError start=+rub[y]\s*<<\s*$+ end=+\.$+
    2              0.000033 endif
    2              0.000008 unlet s:rubypath
                            
                            " [-- python --] {{{3
    2              0.000086 let s:pythonpath= fnameescape(expand("<sfile>:p:h")."/python.vim")
    2              0.000487 if !filereadable(s:pythonpath)
                             for s:pythonpath in split(globpath(&rtp,"syntax/python.vim"),"\n")
                              if filereadable(fnameescape(s:pythonpath))
                               let s:pythonpath= fnameescape(s:pythonpath)
                               break
                              endif
                             endfor
                            endif
    2              0.000016 if g:vimsyn_embed =~# 'P' && filereadable(s:pythonpath)
                             unlet! b:current_syntax
                             syn cluster vimFuncBodyList	add=vimPythonRegion
                             exe "syn include @vimPythonScript ".s:pythonpath
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+py\%[thon]3\=\s*<<\s*\z(\S*\)\ze\(\s*#.*\)\=$+ end=+^\z1\ze\(\s*".*\)\=$+	contains=@vimPythonScript
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+py\%[thon]3\=\s*<<\s*$+ end=+\.$+			contains=@vimPythonScript
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+Py\%[thon]2or3\s*<<\s*\z(\S*\)\ze\(\s*#.*\)\=$+ end=+^\z1\ze\(\s*".*\)\=$+	contains=@vimPythonScript
                             VimFoldP syn region vimPythonRegion matchgroup=vimScriptDelim start=+Py\%[thon]2or3\=\s*<<\s*$+ end=+\.$+			contains=@vimPythonScript
                             syn cluster vimFuncBodyList	add=vimPythonRegion
                            else
    2              0.000040  syn region vimEmbedError start=+py\%[thon]3\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
    2              0.000052  syn region vimEmbedError start=+py\%[thon]3\=\s*<<\s*$+ end=+\.$+
    2              0.000003 endif
    2              0.000006 unlet s:pythonpath
                            
                            " [-- tcl --] {{{3
    2              0.000027 if has("win32") || has("win95") || has("win64") || has("win16")
                             " apparently has("tcl") has been hanging vim on some windows systems with cygwin
                             let s:trytcl= (&shell !~ '\<\%(bash\>\|4[nN][tT]\|\<zsh\)\>\%(\.exe\)\=$')
                            else
    2              0.000008  let s:trytcl= 1
    2              0.000002 endif
    2              0.000003 if s:trytcl
    2              0.000068  let s:tclpath= fnameescape(expand("<sfile>:p:h")."/tcl.vim")
    2              0.000589  if !filereadable(s:tclpath)
                              for s:tclpath in split(globpath(&rtp,"syntax/tcl.vim"),"\n")
                               if filereadable(fnameescape(s:tclpath))
                                let s:tclpath= fnameescape(s:tclpath)
                                break
                               endif
                              endfor
                             endif
    2              0.000026  if g:vimsyn_embed =~# 't' && filereadable(s:tclpath)
                              unlet! b:current_syntax
                              syn cluster vimFuncBodyList	add=vimTclRegion
                              exe "syn include @vimTclScript ".s:tclpath
                              VimFoldt syn region vimTclRegion matchgroup=vimScriptDelim start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimTclScript
                              VimFoldt syn region vimTclRegion matchgroup=vimScriptDelim start=+tc[l]\=\s*<<\s*$+ end=+\.$+	contains=@vimTclScript
                              syn cluster vimFuncBodyList	add=vimTclScript
                             else
    2              0.000061   syn region vimEmbedError start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
    2              0.000035   syn region vimEmbedError start=+tc[l]\=\s*<<\s*$+ end=+\.$+
    2              0.000003  endif
    2              0.000006  unlet s:tclpath
    2              0.000002 else
                             syn region vimEmbedError start=+tc[l]\=\s*<<\s*\z(.*\)$+ end=+^\z1$+
                             syn region vimEmbedError start=+tc[l]\=\s*<<\s*$+ end=+\.$+
                            endif
    2              0.000006 unlet s:trytcl
                            
                            " [-- mzscheme --] {{{3
    2              0.000112 let s:mzschemepath= fnameescape(expand("<sfile>:p:h")."/scheme.vim")
    2              0.000167 if !filereadable(s:mzschemepath)
                             for s:mzschemepath in split(globpath(&rtp,"syntax/mzscheme.vim"),"\n")
                              if filereadable(fnameescape(s:mzschemepath))
                               let s:mzschemepath= fnameescape(s:mzschemepath)
                               break
                              endif
                             endfor
                            endif
    2              0.000061 if g:vimsyn_embed =~# 'm' && filereadable(s:mzschemepath)
                             unlet! b:current_syntax
                             let s:iskKeep= &isk
                             syn cluster vimFuncBodyList	add=vimMzSchemeRegion
                             exe "syn include @vimMzSchemeScript ".s:mzschemepath
                             let &isk= s:iskKeep
                             unlet s:iskKeep
                             VimFoldm syn region vimMzSchemeRegion matchgroup=vimScriptDelim start=+mz\%[scheme]\s*<<\s*\z(.*\)$+ end=+^\z1$+	contains=@vimMzSchemeScript
                             VimFoldm syn region vimMzSchemeRegion matchgroup=vimScriptDelim start=+mz\%[scheme]\s*<<\s*$+ end=+\.$+		contains=@vimMzSchemeScript
                             syn cluster vimFuncBodyList	add=vimMzSchemeRegion
                            else
    2              0.000038  syn region vimEmbedError start=+mz\%[scheme]\s*<<\s*\z(.*\)$+ end=+^\z1$+
    2              0.000046  syn region vimEmbedError start=+mz\%[scheme]\s*<<\s*$+ end=+\.$+
    2              0.000002 endif
    2              0.000013 unlet s:mzschemepath
                            
                            " Synchronize (speed) {{{2
                            "============
    2              0.000007 if exists("g:vimsyn_minlines")
                             exe "syn sync minlines=".g:vimsyn_minlines
                            endif
    2              0.000012 exe "syn sync maxlines=".s:vimsyn_maxlines
    2              0.000008 syn sync linecont	"^\s\+\\"
    2              0.000065 syn sync match vimAugroupSyncA	groupthere NONE	"\<aug\%[roup]\>\s\+[eE][nN][dD]"
                            
                            " ====================
                            " Highlighting Settings {{{2
                            " ====================
                            
    2              0.000009 if !exists("skip_vim_syntax_inits")
    2              0.000006  if !exists("g:vimsyn_noerror")
    2              0.000043   hi def link vimBehaveError	vimError
    2              0.000047   hi def link vimCollClassErr	vimError
    2              0.000029   hi def link vimErrSetting	vimError
    2              0.000036   hi def link vimEmbedError	Normal
    2              0.000025   hi def link vimFTError	vimError
    2              0.000023   hi def link vimFunctionError	vimError
    2              0.000021   hi def link vimFunc         	vimError
    2              0.000019   hi def link vimHiAttribList	vimError
    2              0.000020   hi def link vimHiCtermError	vimError
    2              0.000017   hi def link vimHiKeyError	vimError
    2              0.000015   hi def link vimKeyCodeError	vimError
    2              0.000017   hi def link vimMapModErr	vimError
    2              0.000018   hi def link vimSubstFlagErr	vimError
    2              0.000016   hi def link vimSynCaseError	vimError
    2              0.000017   hi def link vimBufnrWarn	vimWarn
    2              0.000003  endif
                            
    2              0.000022  hi def link vimAbb	vimCommand
    2              0.000023  hi def link vimAddress	vimMark
    2              0.000019  hi def link vimAugroupError	vimError
    2              0.000021  hi def link vimAugroupKey	vimCommand
    2              0.000019  hi def link vimAuHighlight	vimHighlight
    2              0.000018  hi def link vimAutoCmdOpt	vimOption
    2              0.000021  hi def link vimAutoCmd	vimCommand
    2              0.000053  hi def link vimAutoEvent	Type
    2              0.000020  hi def link vimAutoSet	vimCommand
    2              0.000021  hi def link vimBehaveModel	vimBehave
    2              0.000020  hi def link vimBehave	vimCommand
    2              0.000027  hi def link vimBracket	Delimiter
    2              0.000027  hi def link vimCmplxRepeat	SpecialChar
    2              0.000050  hi def link vimCommand	Statement
    2              0.000024  hi def link vimComment	Comment
    2              0.000023  hi def link vimCommentString	vimString
    2              0.000040  hi def link vimCommentTitle	PreProc
    2              0.000020  hi def link vimCondHL	vimCommand
    2              0.000024  hi def link vimContinue	Special
    2              0.000026  hi def link vimCtrlChar	SpecialChar
    2              0.000020  hi def link vimEchoHLNone	vimGroup
    2              0.000020  hi def link vimEchoHL	vimCommand
    2              0.000022  hi def link vimElseIfErr	Error
    2              0.000016  hi def link vimElseif	vimCondHL
    2              0.000022  hi def link vimEnvvar	PreProc
    2              0.000022  hi def link vimError	Error
    2              0.000022  hi def link vimFBVar	vimVar
    2              0.000017  hi def link vimFgBgAttrib	vimHiAttrib
    2              0.000023  hi def link vimFold	Folded
    2              0.000021  hi def link vimFTCmd	vimCommand
    2              0.000020  hi def link vimFTOption	vimSynType
    2              0.000021  hi def link vimFuncKey	vimCommand
    2              0.000024  hi def link vimFuncName	Function
    2              0.000023  hi def link vimFuncSID	Special
    2              0.000025  hi def link vimFuncVar	Identifier
    2              0.000019  hi def link vimGroupAdd	vimSynOption
    2              0.000039  hi def link vimGroupName	vimGroup
    2              0.000024  hi def link vimGroupRem	vimSynOption
    2              0.000022  hi def link vimGroupSpecial	Special
    2              0.000057  hi def link vimGroup	Type
    2              0.000024  hi def link vimHiAttrib	PreProc
    2              0.000020  hi def link vimHiClear	vimHighlight
    2              0.000018  hi def link vimHiCtermFgBg	vimHiTerm
    2              0.000016  hi def link vimHiCTerm	vimHiTerm
    2              0.000021  hi def link vimHighlight	vimCommand
    2              0.000018  hi def link vimHiGroup	vimGroupName
    2              0.000015  hi def link vimHiGuiFgBg	vimHiTerm
    2              0.000015  hi def link vimHiGuiFont	vimHiTerm
    2              0.000059  hi def link vimHiGuiRgb	vimNumber
    2              0.000016  hi def link vimHiGui	vimHiTerm
    2              0.000027  hi def link vimHiNmbr	Number
    2              0.000017  hi def link vimHiStartStop	vimHiTerm
    2              0.000021  hi def link vimHiTerm	Type
    2              0.000022  hi def link vimHLGroup	vimGroup
    2              0.000020  hi def link vimHLMod	PreProc
    2              0.000021  hi def link vimInsert	vimString
    2              0.000024  hi def link vimIskSep	Delimiter
    2              0.000020  hi def link vimKeyCode	vimSpecFile
    2              0.000022  hi def link vimKeyword	Statement
    2              0.000022  hi def link vimLet	vimCommand
    2              0.000022  hi def link vimLineComment	vimComment
    2              0.000020  hi def link vimMapBang	vimCommand
    2              0.000019  hi def link vimMapModKey	vimFuncSID
    2              0.000017  hi def link vimMapMod	vimBracket
    2              0.000021  hi def link vimMap	vimCommand
    2              0.000025  hi def link vimMark	Number
    2              0.000020  hi def link vimMarkNumber	vimNumber
    2              0.000019  hi def link vimMenuMod	vimMapMod
    2              0.000017  hi def link vimMenuNameMore	vimMenuName
    2              0.000020  hi def link vimMenuName	PreProc
    2              0.000020  hi def link vimMtchComment	vimComment
    2              0.000067  hi def link vimNorm	vimCommand
    2              0.000025  hi def link vimNotation	Special
    2              0.000023  hi def link vimNotFunc	vimCommand
    2              0.000020  hi def link vimNotPatSep	vimString
    2              0.000024  hi def link vimNumber	Number
    2              0.000025  hi def link vimOperError	Error
    2              0.000023  hi def link vimOper	Operator
    2              0.000016  hi def link vimOption	PreProc
    2              0.000016  hi def link vimParenSep	Delimiter
    2              0.000030  hi def link vimPatSepErr	vimError
    2              0.000013  hi def link vimPatSepR	vimPatSep
    2              0.000016  hi def link vimPatSep	SpecialChar
    2              0.000016  hi def link vimPatSepZone	vimString
    2              0.000020  hi def link vimPatSepZ	vimPatSep
    2              0.000022  hi def link vimPattern	Type
    2              0.000019  hi def link vimPlainMark	vimMark
    2              0.000020  hi def link vimPlainRegister	vimRegister
    2              0.000024  hi def link vimRegister	SpecialChar
    2              0.000020  hi def link vimScriptDelim	Comment
    2              0.000020  hi def link vimSearchDelim	Statement
    2              0.000022  hi def link vimSearch	vimString
    2              0.000023  hi def link vimSep	Delimiter
    2              0.000019  hi def link vimSetMod	vimOption
    2              0.000020  hi def link vimSetSep	Statement
    2              0.000021  hi def link vimSetString	vimString
    2              0.000023  hi def link vimSpecFile	Identifier
    2              0.000020  hi def link vimSpecFileMod	vimSpecFile
    2              0.000020  hi def link vimSpecial	Type
    2              0.000020  hi def link vimStatement	Statement
    2              0.000020  hi def link vimStringCont	vimString
    2              0.000024  hi def link vimString	String
    2              0.000021  hi def link vimStringEnd	vimString
    2              0.000048  hi def link vimSubst1	vimSubst
    2              0.000019  hi def link vimSubstDelim	Delimiter
    2              0.000021  hi def link vimSubstFlags	Special
    2              0.000025  hi def link vimSubstSubstr	SpecialChar
    2              0.000021  hi def link vimSubstTwoBS	vimString
    2              0.000022  hi def link vimSubst	vimCommand
    2              0.000023  hi def link vimSynCaseError	Error
    2              0.000020  hi def link vimSynCase	Type
    2              0.000016  hi def link vimSyncC	Type
    2              0.000034  hi def link vimSyncError	Error
    2              0.000014  hi def link vimSyncGroupName	vimGroupName
    2              0.000012  hi def link vimSyncGroup	vimGroupName
    2              0.000021  hi def link vimSyncKey	Type
    2              0.000024  hi def link vimSyncNone	Type
    2              0.000017  hi def link vimSynContains	vimSynOption
    2              0.000022  hi def link vimSynError	Error
    2              0.000020  hi def link vimSynKeyContainedin	vimSynContains
    2              0.000016  hi def link vimSynKeyOpt	vimSynOption
    2              0.000016  hi def link vimSynMtchGrp	vimSynOption
    2              0.000016  hi def link vimSynMtchOpt	vimSynOption
    2              0.000016  hi def link vimSynNextgroup	vimSynOption
    2              0.000018  hi def link vimSynNotPatRange	vimSynRegPat
    2              0.000021  hi def link vimSynOption	Special
    2              0.000020  hi def link vimSynPatRange	vimString
    2              0.000017  hi def link vimSynRegOpt	vimSynOption
    2              0.000018  hi def link vimSynRegPat	vimString
    2              0.000022  hi def link vimSynReg	Type
    2              0.000022  hi def link vimSyntax	vimCommand
    2              0.000036  hi def link vimSynType	vimSpecial
    2              0.000023  hi def link vimTodo	Todo
    2              0.000020  hi def link vimUnmap	vimMap
    2              0.000022  hi def link vimUserAttrbCmpltFunc	Special
    2              0.000051  hi def link vimUserAttrbCmplt	vimSpecial
    2              0.000022  hi def link vimUserAttrbKey	vimOption
    2              0.000015  hi def link vimUserAttrb	vimSpecial
    2              0.000026  hi def link vimUserAttrbError	Error
    2              0.000025  hi def link vimUserCmdError	Error
    2              0.000022  hi def link vimUserCommand	vimCommand
    2              0.000026  hi def link vimUserFunc	Normal
    2              0.000027  hi def link vimVar	Identifier
    2              0.000026  hi def link vimWarn	WarningMsg
                            
    2              0.000033  hi def link nvimAutoEvent	vimAutoEvent
    2              0.000024  hi def link nvimHLGroup	vimHLGroup
    2              0.000021  hi def link nvimMap	vimMap
    2              0.000021  hi def link nvimUnmap	vimUnmap
    2              0.000003 endif
                            
                            " Current Syntax Variable: {{{2
    2              0.000018 let b:current_syntax = "vim"
                            
                            " ---------------------------------------------------------------------
                            " Cleanup: {{{1
    2              0.000018 delc VimFolda
    2              0.000008 delc VimFoldf
    2              0.000009 delc VimFoldl
    2              0.000025 delc VimFoldm
    2              0.000011 delc VimFoldp
    2              0.000008 delc VimFoldP
    2              0.000006 delc VimFoldr
    2              0.000006 delc VimFoldt
    2              0.000045 let &cpo = s:keepcpo
    2              0.000008 unlet s:keepcpo
                            " vim:ts=18  fdm=marker

SCRIPT  /usr/local/Cellar/neovim/HEAD-c6cd608/share/nvim/runtime/syntax/vim/generated.vim
Sourced 2 times
Total time:   0.012109
 Self time:   0.012109

count  total (s)   self (s)
    2              0.003906 syn keyword vimCommand contained  a[ppend] ab[breviate] abc[lear] abo[veleft] al[l] am[enu] an[oremenu] ar[gs] arga[dd] argd[elete] argdo arge[dit] argg[lobal] argl[ocal] argu[ment] as[cii] aun[menu] b[uffer] bN[ext] ba[ll] bad[d] bd[elete] be[have] bel[owright] bf[irst] bl[ast] bm[odified] bn[ext] bo[tright] bp[revious] br[ewind] brea[k] breaka[dd] breakd[el] breakl[ist] bro[wse] bu[ffers] bufd[o] bun[load] bw[ipeout] c[hange] cN[ext] cNf[ile] ca[bbrev] cabc[lear] cad[dbuffer] cadde[xpr] caddf[ile] cal[l] cat[ch] cb[uffer] cbo[ttom] cc ccl[ose] cd cdo ce[nter] cex[pr] cf[ile] cfd[o] cfi[rst] cg[etfile] cgetb[uffer] cgete[xpr] ch[dir] cha[nges] che[ckhealth] checkp[ath] checkt[ime] chi[story] cl[ist] cla[st] clo[se] cle[arjumps] cm[ap] cmapc[lear] cme[nu] cn[ext] cnew[er] cnf[ile] cno[remap] cnorea[bbrev] cnorem[enu] co[py] col[der] colo[rscheme]
    2              0.000469 syn keyword vimCommand contained  com[mand] comc[lear] comp[iler] con[tinue] conf[irm] cop[en] cp[revious] cpf[ile] cq[uit] cr[ewind] cs[cope] cst[ag] cu[nmap] cuna[bbrev] cunm[enu] cw[indow] d[elete] delm[arks] deb[ug] debugg[reedy] del[command] delf[unction] di[splay] dif[fupdate] diffg[et] diffo[ff] diffp[atch] diffpu[t] diffs[plit] difft[his] dig[raphs] dj[ump] dl[ist] dr[op] ds[earch] dsp[lit] e[dit] ea[rlier] ec[ho] echoe[rr] echoh[l] echom[sg] echon el[se] elsei[f] em[enu] en[dif] endf[unction] endfo[r] endt[ry] endw[hile] ene[w] ex exe[cute] exi[t] exu[sage] f[ile] files filet[ype] filt[er] fin[d] fina[lly] fini[sh] fir[st] fo[ld] foldc[lose] foldd[oopen] folddoc[losed] foldo[pen] for fu[nction] g[lobal] go[to] gr[ep] grepa[dd] gu[i] gv[im] h[elp] helpc[lose] helpg[rep] helpt[ags] ha[rdcopy] hi[ghlight] hid[e] his[tory] i[nsert] ia[bbrev]
    2              0.000494 syn keyword vimCommand contained  iabc[lear] if ij[ump] il[ist] im[ap] imapc[lear] ime[nu] in[oremap] inorea[bbrev] inorem[enu] int[ro] is[earch] isp[lit] iu[nmap] iuna[bbrev] iunm[enu] j[oin] ju[mps] k ke[epmarks] keepj[umps] keepp[atterns] keepa[lt] l[ist] lN[ext] lNf[ile] la[st] lan[guage] lad[dexpr] laddb[uffer] laddf[ile] lat[er] lb[uffer] lbo[ttom] lc[d] lch[dir] lcl[ose] lcs[cope] ld[o] le[ft] lefta[bove] let lex[pr] lf[ile] lfd[o] lfi[rst] lg[etfile] lgetb[uffer] lgete[xpr] lgr[ep] lgrepa[dd] lh[elpgrep] lhi[story] ll lla[st] lli[st] lm[ap] lmapc[lear] lmak[e] ln[oremap] lne[xt] lnew[er] lnf[ile] lo[adview] loadk[eymap] loc[kmarks] lockv[ar] lol[der] lop[en] lp[revious] lpf[ile] lr[ewind] lt[ag] lu[nmap] lua luad[o] luaf[ile] lv[imgrep] lvimgrepa[dd] lw[indow] ls m[ove] ma[rk] mak[e] map mapc[lear] mar[ks] mat[ch] me[nu] menut[ranslate]
    2              0.001392 syn keyword vimCommand contained  mes[sages] mk[exrc] mks[ession] mksp[ell] mkv[imrc] mkvie[w] mo[de] mz[scheme] mzf[ile] n[ext] new nm[ap] nmapc[lear] nme[nu] nn[oremap] nnoreme[nu] no[remap] noa[utocmd] noh[lsearch] nor[eabbrev] norem[enu] nos[wapfile] nor[mal] nu[mber] nun[map] nunme[nu] o[ldfiles] om[ap] omapc[lear] ome[nu] on[ly] ono[remap] onoreme[nu] op[tions] ou[nmap] ounme[nu] ow[nsyntax] p[rint] pa[ckadd] packl[oadall] pc[lose] pe[rl] perld[o] ped[it] po[p] popu[p] pp[op] pr[eserve] prev[ious] pro[file] profd[el] ps[earch] pt[ag] ptN[ext] ptf[irst] ptj[ump] ptl[ast] ptn[ext] ptp[revious] ptr[ewind] pts[elect] pu[t] pw[d] py[thon] pyd[o] pyf[ile] py3 py3d[o] pyt[hon3] py3[file] pyx pyxd[o] pyt[honx] pyx[file] q[uit] quita[ll] qa[ll] r[ead] rec[over] red[o] redi[r] redr[aw] redraws[tatus] reg[isters] res[ize] ret[ab] retu[rn] rew[ind]
    2              0.000359 syn keyword vimCommand contained  ri[ght] rightb[elow] rs[hada] ru[ntime] rund[o] rub[y] rubyd[o] rubyf[ile] rv[iminfo] s[ubstitute] sN[ext] sa[rgument] sal[l] san[dbox] sav[eas] sb[uffer] sbN[ext] sba[ll] sbf[irst] sbl[ast] sbm[odified] sbn[ext] sbp[revious] sbr[ewind] sc[riptnames] scripte[ncoding] scs[cope] se[t] setf[iletype] setg[lobal] setl[ocal] sf[ind] sfir[st] si[malt] sig[n] sil[ent] sl[eep] sla[st] sm[agic] smap smapc[lear] sme[nu] sn[ext] sno[magic] snor[emap] snoreme[nu] so[urce] sor[t] sp[lit] spe[llgood] spelld[ump] spelli[nfo] spellr[epall] spellu[ndo] spellw[rong] spr[evious] sr[ewind] st[op] sta[g] star[tinsert] startg[replace] startr[eplace] sto[pinsert] stj[ump] sts[elect] su[nhide] sunm[ap] sunme[nu] sus[pend] sv[iew] sw[apname] sy[ntax] synti[me] sync[bind] t tc[d] tch[dir] tN[ext] ta[g] tags tab tabc[lose] tabd[o] tabe[dit]
    2              0.000301 syn keyword vimCommand contained  tabf[ind] tabfir[st] tabm[ove] tabl[ast] tabn[ext] tabnew tabo[nly] tabp[revious] tabN[ext] tabr[ewind] tabs tc[l] tcld[o] tclf[ile] te[rminal] tf[irst] th[row] tj[ump] tl[ast] tm[ap] tmapc[lear] tme[nu] tn[ext] tno[remap] to[pleft] tp[revious] tr[ewind] try ts[elect] tu[nmap] tunme[nu] u[ndo] undoj[oin] undol[ist] una[bbreviate] unh[ide] unl[et] unlo[ckvar] unm[ap] unme[nu] uns[ilent] up[date] v[global] ve[rsion] verb[ose] vert[ical] vi[sual] vie[w] vim[grep] vimgrepa[dd] viu[sage] vm[ap] vmapc[lear] vme[nu] vn[oremap] vne[w] vno[remenu] vs[plit] vu[nmap] vunme[nu] w[rite] wN[ext] wa[ll] wh[ile] wi[nsize] winc[md] wind[o] winp[os] wn[ext] wp[revious] wq wqa[ll] ws[hada] wu[ndo] wv[iminfo] x[it] xa[ll] xm[ap] xmapc[lear] xme[nu] xn[oremap] xnoreme[nu] xu[nmap] xunme[nu] y[ank] N[ext]
                            
    2              0.000239 syn keyword vimOption contained  aleph al arabic arab invarabic noarabic invarab noarab arabicshape arshape invarabicshape noarabicshape invarshape noarshape allowrevins ari invallowrevins noallowrevins invari noari ambiwidth ambw autochdir acd invautochdir noautochdir invacd noacd autoindent ai invautoindent noautoindent invai noai autoread ar invautoread noautoread invar noar autowrite aw invautowrite noautowrite invaw noaw autowriteall awa invautowriteall noautowriteall invawa noawa background bg backspace bs backup bk invbackup nobackup invbk nobk backupcopy bkc backupdir bdir backupext bex backupskip bsk belloff bo binary bin invbinary nobinary invbin nobin bomb invbomb nobomb breakat brk breakindent bri invbreakindent nobreakindent invbri nobri breakindentopt briopt browsedir bsdir bufhidden bh buflisted bl invbuflisted nobuflisted invbl nobl
    2              0.000153 syn keyword vimOption contained  buftype bt casemap cmp cdpath cd cedit channel charconvert ccv cindent cin invcindent nocindent invcin nocin cinkeys cink cinoptions cino cinwords cinw clipboard cb cmdheight ch cmdwinheight cwh colorcolumn cc columns co comments com commentstring cms complete cpt concealcursor cocu conceallevel cole completefunc cfu completeopt cot confirm cf invconfirm noconfirm invcf nocf copyindent ci invcopyindent nocopyindent invci noci cpoptions cpo cscopepathcomp cspc cscopeprg csprg cscopequickfix csqf cscoperelative csre invcscoperelative nocscoperelative invcsre nocsre cscopetag cst invcscopetag nocscopetag invcst nocst cscopetagorder csto cscopeverbose csverb invcscopeverbose nocscopeverbose invcsverb nocsverb cursorbind crb invcursorbind nocursorbind invcrb nocrb cursorcolumn cuc invcursorcolumn nocursorcolumn invcuc nocuc
    2              0.000652 syn keyword vimOption contained  cursorline cul invcursorline nocursorline invcul nocul debug define def delcombine deco invdelcombine nodelcombine invdeco nodeco dictionary dict diff invdiff nodiff diffexpr dex diffopt dip digraph dg invdigraph nodigraph invdg nodg directory dir display dy eadirection ead emoji emo invemoji noemoji invemo noemo encoding enc endofline eol invendofline noendofline inveol noeol equalalways ea invequalalways noequalalways invea noea equalprg ep errorbells eb inverrorbells noerrorbells inveb noeb errorfile ef errorformat efm eventignore ei expandtab et invexpandtab noexpandtab invet noet exrc ex invexrc noexrc invex noex fileencoding fenc fileencodings fencs fileformat ff fileformats ffs fileignorecase fic invfileignorecase nofileignorecase invfic nofic filetype ft fillchars fcs fixendofline fixeol invfixendofline nofixendofline invfixeol nofixeol
    2              0.000155 syn keyword vimOption contained  foldclose fcl foldcolumn fdc foldenable fen invfoldenable nofoldenable invfen nofen foldexpr fde foldignore fdi foldlevel fdl foldlevelstart fdls foldmarker fmr foldmethod fdm foldminlines fml foldnestmax fdn foldopen fdo foldtext fdt formatexpr fex formatoptions fo formatlistpat flp formatprg fp fsync fs invfsync nofsync invfs nofs gdefault gd invgdefault nogdefault invgd nogd grepformat gfm grepprg gp guicursor gcr guifont gfn guifontset gfs guifontwide gfw guioptions go guitablabel gtl guitabtooltip gtt helpfile hf helpheight hh helplang hlg hidden hid invhidden nohidden invhid nohid highlight hl history hi hkmap hk invhkmap nohkmap invhk nohk hkmapp hkp invhkmapp nohkmapp invhkp nohkp hlsearch hls invhlsearch nohlsearch invhls nohls icon invicon noicon iconstring ignorecase ic invignorecase noignorecase invic noic
    2              0.000105 syn keyword vimOption contained  imcmdline imc invimcmdline noimcmdline invimc noimc imdisable imd invimdisable noimdisable invimd noimd iminsert imi imsearch ims inccommand icm include inc includeexpr inex incsearch is invincsearch noincsearch invis nois indentexpr inde indentkeys indk infercase inf invinfercase noinfercase invinf noinf insertmode im invinsertmode noinsertmode invim noim isfname isf isident isi iskeyword isk isprint isp joinspaces js invjoinspaces nojoinspaces invjs nojs keymap kmp keymodel km keywordprg kp langmap lmap langmenu lm langnoremap lnr invlangnoremap nolangnoremap invlnr nolnr langremap lrm invlangremap nolangremap invlrm nolrm laststatus ls lazyredraw lz invlazyredraw nolazyredraw invlz nolz linebreak lbr invlinebreak nolinebreak invlbr nolbr lines linespace lsp lisp invlisp nolisp lispwords lw list invlist nolist
    2              0.000111 syn keyword vimOption contained  listchars lcs loadplugins lpl invloadplugins noloadplugins invlpl nolpl magic invmagic nomagic makeef mef makeencoding menc makeprg mp matchpairs mps matchtime mat maxcombine mco maxfuncdepth mfd maxmapdepth mmd maxmempattern mmp menuitems mis mkspellmem msm modeline ml invmodeline nomodeline invml noml modelines mls modifiable ma invmodifiable nomodifiable invma noma modified mod invmodified nomodified invmod nomod more invmore nomore mouse mousefocus mousef invmousefocus nomousefocus invmousef nomousef mousehide mh invmousehide nomousehide invmh nomh mousemodel mousem mouseshape mouses mousetime mouset nrformats nf number nu invnumber nonumber invnu nonu numberwidth nuw omnifunc ofu opendevice odev invopendevice noopendevice invodev noodev operatorfunc opfunc packpath pp paragraphs para paste invpaste nopaste
    2              0.000125 syn keyword vimOption contained  pastetoggle pt patchexpr pex patchmode pm path pa preserveindent pi invpreserveindent nopreserveindent invpi nopi previewheight pvh previewwindow pvw invpreviewwindow nopreviewwindow invpvw nopvw printdevice pdev printencoding penc printexpr pexpr printfont pfn printheader pheader printmbcharset pmbcs printmbfont pmbfn printoptions popt prompt invprompt noprompt pumheight ph pumblend pb pyxversion pyx quoteescape qe readonly ro invreadonly noreadonly invro noro redrawtime rdt regexpengine re relativenumber rnu invrelativenumber norelativenumber invrnu nornu remap invremap noremap report revins ri invrevins norevins invri nori rightleft rl invrightleft norightleft invrl norl rightleftcmd rlc ruler ru invruler noruler invru noru rulerformat ruf runtimepath rtp scroll scr scrollback scbk scrollbind scb invscrollbind noscrollbind invscb noscb
    2              0.000652 syn keyword vimOption contained  scrolljump sj scrolloff so scrollopt sbo sections sect secure invsecure nosecure selection sel selectmode slm sessionoptions ssop shada sd shadafile sdf shell sh shellcmdflag shcf shellpipe sp shellquote shq shellredir srr shellslash ssl invshellslash noshellslash invssl nossl shelltemp stmp invshelltemp noshelltemp invstmp nostmp shellxquote sxq shellxescape sxe shiftround sr invshiftround noshiftround invsr nosr shiftwidth sw shortmess shm showbreak sbr showcmd sc invshowcmd noshowcmd invsc nosc showfulltag sft invshowfulltag noshowfulltag invsft nosft showmatch sm invshowmatch noshowmatch invsm nosm showmode smd invshowmode noshowmode invsmd nosmd showtabline stal sidescroll ss sidescrolloff siso signcolumn scl smartcase scs invsmartcase nosmartcase invscs noscs smartindent si invsmartindent nosmartindent invsi nosi
    2              0.000232 syn keyword vimOption contained  smarttab sta invsmarttab nosmarttab invsta nosta softtabstop sts spell invspell nospell spellcapcheck spc spellfile spf spelllang spl spellsuggest sps splitbelow sb invsplitbelow nosplitbelow invsb nosb splitright spr invsplitright nosplitright invspr nospr startofline sol invstartofline nostartofline invsol nosol statusline stl suffixes su suffixesadd sua swapfile swf invswapfile noswapfile invswf noswf switchbuf swb synmaxcol smc syntax syn tabline tal tabpagemax tpm tabstop ts tagbsearch tbs invtagbsearch notagbsearch invtbs notbs tagcase tc taglength tl tagrelative tr invtagrelative notagrelative invtr notr tags tag tagstack tgst invtagstack notagstack invtgst notgst termbidi tbidi invtermbidi notermbidi invtbidi notbidi termencoding tenc termguicolors tgc invtermguicolors notermguicolors invtgc notgc terse invterse noterse
    2              0.000134 syn keyword vimOption contained  textwidth tw thesaurus tsr tildeop top invtildeop notildeop invtop notop timeout to invtimeout notimeout invto noto timeoutlen tm title invtitle notitle titlelen titleold titlestring ttimeout invttimeout nottimeout ttimeoutlen ttm undodir udir undofile udf invundofile noundofile invudf noudf undolevels ul undoreload ur updatecount uc updatetime ut verbose vbs verbosefile vfile viewdir vdir viewoptions vop viminfo vi viminfofile vif virtualedit ve visualbell vb invvisualbell novisualbell invvb novb warn invwarn nowarn whichwrap ww wildchar wc wildcharm wcm wildignore wig wildignorecase wic invwildignorecase nowildignorecase invwic nowic wildmenu wmnu invwildmenu nowildmenu invwmnu nowmnu wildmode wim wildoptions wop winaltkeys wak winhighlight winhl window wi winheight wh winfixheight wfh invwinfixheight nowinfixheight invwfh nowfh
    2              0.000070 syn keyword vimOption contained  winfixwidth wfw invwinfixwidth nowinfixwidth invwfw nowfw winminheight wmh winminwidth wmw winwidth wiw wrap invwrap nowrap wrapmargin wm wrapscan ws invwrapscan nowrapscan invws nows write invwrite nowrite writeany wa invwriteany nowriteany invwa nowa writebackup wb invwritebackup nowritebackup invwb nowb writedelay wd
                            
    2              0.000005 syn case ignore
                            
    2              0.000184 syn keyword vimAutoEvent contained  BufAdd BufDelete BufEnter BufFilePost BufFilePre BufHidden BufLeave BufNew BufNewFile BufReadCmd BufReadPost BufReadPre BufUnload BufWinEnter BufWinLeave BufWipeout BufWriteCmd BufWritePost BufWritePre ChanInfo ChanOpen CmdLineChanged CmdLineEnter CmdLineLeave CmdUndefined CmdWinEnter CmdWinLeave ColorScheme ColorSchemePre CompleteChanged CompleteDone CursorHold CursorHoldI CursorMoved CursorMovedI DiffUpdated EncodingChanged ExitPre FileAppendCmd FileAppendPost FileAppendPre FileChangedRO FileChangedShell FileChangedShellPost FileReadCmd FileReadPost FileReadPre FileType FileWriteCmd FileWritePost FileWritePre FilterReadPost FilterReadPre FilterWritePost FilterWritePre FocusGained FocusLost FuncUndefined GUIEnter GUIFailed InsertChange InsertCharPre InsertEnter InsertLeave MenuPopup OptionSet QuickFixCmdPost
    2              0.000060 syn keyword vimAutoEvent contained  QuickFixCmdPre QuitPre RemoteReply SessionLoadPost ShellCmdPost ShellFilterPost SourceCmd SourcePre SpellFileMissing StdinReadPost StdinReadPre SwapExists Syntax TabEnter TabLeave TermChanged TermResponse TextChanged TextChangedI TextChangedP TextYankPost User VimEnter VimLeave VimLeavePre VimResized VimResume VimSuspend WinEnter WinLeave WinNew BufWrite FileEncoding BufCreate BufRead
                            
    2              0.000029 syn keyword nvimAutoEvent contained  TabNewEntered TabClosed TermOpen Signal TermClose TabNew DirChanged
                            
    2              0.000014 syn case match
                            
    2              0.000102 syn keyword vimFuncName contained  ceil nvim_win_get_position lispindent nvim_buf_line_count strftime sinh sign_getplaced nvim_tabpage_get_win inputdialog jobsend settabwinvar tagfiles append getwinposx msgpackparse nvim_buf_get_commands tabpagewinnr jobclose nvim_set_current_tabpage map inputrestore nvim_buf_get_changedtick inputlist has_key sign_define resolve inputsave strcharpart nvim_buf_get_option nvim_win_set_cursor range sqrt setbufvar swapinfo winheight acos screenrow getcmdline argv pyeval nvim_get_proc_children float2nr expand nvim_get_chan_info delete round nvim_get_color_by_name dictwatcherdel funcref nvim_list_uis nvim__id_float rpcstop hasmapto rpcnotify atan2 nvim_feedkeys indent reverse nvim_buf_get_keymap screenchar setcharsearch nvim_win_get_width nvim_win_set_var jobpid nvim_get_vvar nvim_buf_get_lines gettabvar asin nvim_get_hl_by_name
    2              0.000096 syn keyword vimFuncName contained  sort nr2char getftype garbagecollect diff_filler nvim_tabpage_get_var getjumplist char2nr msgpackdump maparg foreground setfperm winlayout py3eval str2nr nvim_win_set_buf getbufline strridx invert getline reltimestr islocked json_decode shiftwidth abs reg_recording pumvisible getcompletion pathshorten getfsize matchstr extend nvim_buf_clear_highlight max nvim_tabpage_set_var serverstop setline win_findbuf nvim_win_get_tabpage nvim_win_set_height fmod nextnonblank rpcrequest nvim_win_get_config nvim__id_array foldclosedend log nvim_set_current_buf test_garbagecollect_now foldtextresult nvim_set_current_dir nvim_err_writeln sin reltimefloat bufloaded buffer_exists complete_add browse input index submatch searchpos pyxeval setloclist nvim_win_get_option atan sockconnect getcurpos changenr getreg nvim_win_get_height
    2              0.000081 syn keyword vimFuncName contained  nvim_list_tabpages assert_report nvim_get_current_win sign_getdefined nvim_set_current_line gettagstack assert_inrange setqflist nvim_win_close nvim_list_runtime_paths gettabinfo call getloclist nvim_call_dict_function getcmdwintype len glob2regpat jobstart nvim_input bufnr serverlist nvim_set_var pow nvim_get_namespaces nvim_get_current_line split bufwinid globpath getwininfo cursor cosh nvim_tabpage_is_valid getcmdtype getftime confirm argc nvim_list_wins nvim_buf_add_highlight json_encode arglistid nvim_get_current_buf nvim_replace_termcodes mkdir str2float getregtype reg_executing highlightID nvim_buf_del_var nvim__inspect_cell rename glob nvim_open_win nvim_get_current_tabpage timer_stop file_readable nvim_tabpage_del_var isdirectory assert_exception inputsecret sign_place serverstart escape getcmdpos
    2              0.000092 syn keyword vimFuncName contained  readfile screenattr hlID sign_jump matchaddpos histadd getwinvar nvim_set_keymap min iconv matcharg nvim_win_get_number clearmatches getpid buflisted matchstrpos assert_equal string haslocaldir nvim_win_get_var jobstop nvim__stats complete matchdelete join winwidth win_screenpos nvim_del_keymap getqflist copy nvim_input_mouse count nvim_command winnr filewritable jobresize nvim_buf_set_lines getwinposy strpart mode eval localtime getchangelist setcmdpos rpcstart repeat nvim_win_del_var keys bufwinnr getwinpos screencol assert_notmatch chansend win_getid gettabwinvar assert_match getbufinfo insert nvim_buf_get_name execute getbufvar or tempname foldlevel hostname foldtext getchar nvim_tabpage_list_wins synIDattr getmatches feedkeys function strgetchar xor nvim_eval type tabpagebuflist tr log10 winline trim
    2              0.000123 syn keyword vimFuncName contained  winsaveview nvim_list_chans searchpairpos winrestview system filereadable setreg foldclosed simplify timer_pause settabvar nvim_win_is_valid finddir searchdecl settagstack printf test_write_list_log buffer_number exepath reltime soundfold trunc assert_fails menu_get did_filetype complete_info nvim__id nvim_win_set_option assert_true matchadd items cos taglist nvim_call_function cindent tabpagenr jobwait sign_unplace shellescape stdioopen sha256 spellbadword nvim_buf_set_virtual_text toupper win_id2win byteidx wordcount tanh nvim_win_set_width diff_hlID libcall remove bufname synID setpos swapname get substitute histnr and complete_check assert_false strwidth win_id2tabwin stridx line hlexists assert_beeps tolower mapcheck nvim_get_commands getcwd nvim_create_buf fnameescape synIDtrans setmatches synconcealed
    2              0.000073 syn keyword vimFuncName contained  col fnamemodify nvim_win_get_cursor search histget wildmenumode tan spellsuggest nvim_get_option nvim_get_color_map undotree nvim_list_bufs exists timer_info bufexists matchlist eventhandler timer_start strdisplaywidth prevnonblank browsedir buffer_name uniq win_gotoid getcharmod virtcol nvim_buf_get_mark getfperm nvim_buf_get_var has wincol winbufnr last_buffer_nr byteidxcomp undofile matchend filter writefile visualmode nvim_buf_set_keymap nvim_buf_set_name executable match nvim_buf_is_loaded findfile nvim_win_set_config nvim_buf_get_offset values nvim__id_dictionary nvim_buf_set_option nvim_out_write getcharsearch nvim_del_current_line nvim_buf_clear_namespace line2byte nvim_select_popupmenu_item setwinvar nvim_command_output nvim_err_write chanclose nvim_get_keymap strlen synstack api_info nvim_del_var
    2              0.000058 syn keyword vimFuncName contained  nvim_get_var nvim_set_option nvim_win_get_buf deletebufline nvim_buf_is_valid byte2line empty nvim_get_mode nvim_get_proc nvim_set_vvar exp searchpair nvim_set_current_win nvim_strwidth id stdpath nvim_buf_del_keymap cscope_connection luaeval nvim_get_hl_by_id nvim_tabpage_get_number argidx assert_notequal winrestcmd add floor getpos sign_undefine getfontname libcallnr strtrans dictwatcheradd termopen nvim_parse_expression nvim_buf_get_number systemlist timer_stopall strchars nvim_buf_set_var deepcopy highlight_exists nvim_create_namespace histdel

SCRIPT  /usr/local/Cellar/neovim/HEAD-c6cd608/share/nvim/runtime/scripts.vim
Sourced 1 time
Total time:   0.001806
 Self time:   0.001806

count  total (s)   self (s)
                            " Vim support file to detect file types in scripts
                            "
                            " Maintainer:	Bram Moolenaar <Bram@vim.org>
                            " Last change:	2018 Feb 03
                            
                            " This file is called by an autocommand for every file that has just been
                            " loaded into a buffer.  It checks if the type of file can be recognized by
                            " the file contents.  The autocommand is in $VIMRUNTIME/filetype.vim.
                            "
                            " Note that the pattern matches are done with =~# to avoid the value of the
                            " 'ignorecase' option making a difference.  Where case is to be ignored use
                            " =~? instead.  Do not use =~ anywhere.
                            
                            
                            " Only do the rest when the FileType autocommand has not been triggered yet.
    1              0.000008 if did_filetype()
                              finish
                            endif
                            
                            " Load the user defined scripts file first
                            " Only do this when the FileType autocommand has not been triggered yet
    1              0.000006 if exists("myscriptsfile") && filereadable(expand(myscriptsfile))
                              execute "source " . myscriptsfile
                              if did_filetype()
                                finish
                              endif
                            endif
                            
                            " Line continuation is used here, remove 'C' from 'cpoptions'
    1              0.000013 let s:cpo_save = &cpo
    1              0.000014 set cpo&vim
                            
    1              0.000020 let s:line1 = getline(1)
                            
    1              0.000025 if s:line1 =~# "^#!"
                              " A script that starts with "#!".
                            
                              " Check for a line like "#!/usr/bin/env VAR=val bash".  Turn it into
                              " "#!/usr/bin/bash" to make matching easier.
                              if s:line1 =~# '^#!\s*\S*\<env\s'
                                let s:line1 = substitute(s:line1, '\S\+=\S\+', '', 'g')
                                let s:line1 = substitute(s:line1, '\<env\s\+', '', '')
                              endif
                            
                              " Get the program name.
                              " Only accept spaces in PC style paths: "#!c:/program files/perl [args]".
                              " If the word env is used, use the first word after the space:
                              " "#!/usr/bin/env perl [path/args]"
                              " If there is no path use the first word: "#!perl [path/args]".
                              " Otherwise get the last word after a slash: "#!/usr/bin/perl [path/args]".
                              if s:line1 =~# '^#!\s*\a:[/\\]'
                                let s:name = substitute(s:line1, '^#!.*[/\\]\(\i\+\).*', '\1', '')
                              elseif s:line1 =~# '^#!.*\<env\>'
                                let s:name = substitute(s:line1, '^#!.*\<env\>\s\+\(\i\+\).*', '\1', '')
                              elseif s:line1 =~# '^#!\s*[^/\\ ]*\>\([^/\\]\|$\)'
                                let s:name = substitute(s:line1, '^#!\s*\([^/\\ ]*\>\).*', '\1', '')
                              else
                                let s:name = substitute(s:line1, '^#!\s*\S*[/\\]\(\i\+\).*', '\1', '')
                              endif
                            
                              " tcl scripts may have #!/bin/sh in the first line and "exec wish" in the
                              " third line.  Suggested by Steven Atkinson.
                              if getline(3) =~# '^exec wish'
                                let s:name = 'wish'
                              endif
                            
                              " Bourne-like shell scripts: bash bash2 ksh ksh93 sh
                              if s:name =~# '^\(bash\d*\|\|ksh\d*\|sh\)\>'
                                call dist#ft#SetFileTypeSH(s:line1)	" defined in filetype.vim
                            
                                " csh scripts
                              elseif s:name =~# '^csh\>'
                                if exists("g:filetype_csh")
                                  call dist#ft#SetFileTypeShell(g:filetype_csh)
                                else
                                  call dist#ft#SetFileTypeShell("csh")
                                endif
                            
                                " tcsh scripts
                              elseif s:name =~# '^tcsh\>'
                                call dist#ft#SetFileTypeShell("tcsh")
                            
                                " Z shell scripts
                              elseif s:name =~# '^zsh\>'
                                set ft=zsh
                            
                                " TCL scripts
                              elseif s:name =~# '^\(tclsh\|wish\|expectk\|itclsh\|itkwish\)\>'
                                set ft=tcl
                            
                                " Expect scripts
                              elseif s:name =~# '^expect\>'
                                set ft=expect
                            
                                " Gnuplot scripts
                              elseif s:name =~# '^gnuplot\>'
                                set ft=gnuplot
                            
                                " Makefiles
                              elseif s:name =~# 'make\>'
                                set ft=make
                            
                                " Pike
                              elseif s:name =~# '^pike\%(\>\|[0-9]\)'
                                set ft=pike
                            
                                " Lua
                              elseif s:name =~# 'lua'
                                set ft=lua
                            
                                " Perl 6
                              elseif s:name =~# 'perl6'
                                set ft=perl6
                            
                                " Perl
                              elseif s:name =~# 'perl'
                                set ft=perl
                            
                                " PHP
                              elseif s:name =~# 'php'
                                set ft=php
                            
                                " Python
                              elseif s:name =~# 'python'
                                set ft=python
                            
                                " Groovy
                              elseif s:name =~# '^groovy\>'
                                set ft=groovy
                            
                                " Ruby
                              elseif s:name =~# 'ruby'
                                set ft=ruby
                            
                                " JavaScript
                              elseif s:name =~# 'node\(js\)\=\>\|js\>' || s:name =~# 'rhino\>'
                                set ft=javascript
                            
                                " BC calculator
                              elseif s:name =~# '^bc\>'
                                set ft=bc
                            
                                " sed
                              elseif s:name =~# 'sed\>'
                                set ft=sed
                            
                                " OCaml-scripts
                              elseif s:name =~# 'ocaml'
                                set ft=ocaml
                            
                                " Awk scripts
                              elseif s:name =~# 'awk\>'
                                set ft=awk
                            
                                " Website MetaLanguage
                              elseif s:name =~# 'wml'
                                set ft=wml
                            
                                " Scheme scripts
                              elseif s:name =~# 'scheme'
                                set ft=scheme
                            
                                " CFEngine scripts
                              elseif s:name =~# 'cfengine'
                                set ft=cfengine
                            
                                " Erlang scripts
                              elseif s:name =~# 'escript'
                                set ft=erlang
                            
                                " Haskell
                              elseif s:name =~# 'haskell'
                                set ft=haskell
                            
                                " Scala
                              elseif s:name =~# 'scala\>'
                                set ft=scala
                            
                                " Clojure
                              elseif s:name =~# 'clojure'
                                set ft=clojure
                            
                              endif
                              unlet s:name
                            
                            else
                              " File does not start with "#!".
                            
    1              0.000010   let s:line2 = getline(2)
    1              0.000004   let s:line3 = getline(3)
    1              0.000003   let s:line4 = getline(4)
    1              0.000003   let s:line5 = getline(5)
                            
                              " Bourne-like shell scripts: sh ksh bash bash2
    1              0.000011   if s:line1 =~# '^:$'
                                call dist#ft#SetFileTypeSH(s:line1)	" defined in filetype.vim
                            
                                " Z shell scripts
                              elseif s:line1 =~# '^#compdef\>' || s:line1 =~# '^#autoload\>' ||
                                    \ "\n".s:line1."\n".s:line2."\n".s:line3."\n".s:line4."\n".s:line5 =~# '\n\s*emulate\s\+\%(-[LR]\s\+\)\=[ckz]\=sh\>'
                                set ft=zsh
                            
                              " ELM Mail files
                              elseif s:line1 =~# '^From \([a-zA-Z][a-zA-Z_0-9\.=-]*\(@[^ ]*\)\=\|-\) .* \(19\|20\)\d\d$'
                                set ft=mail
                            
                                " Mason
                              elseif s:line1 =~# '^<[%&].*>'
                                set ft=mason
                            
                                " Vim scripts (must have '" vim' as the first line to trigger this)
                              elseif s:line1 =~# '^" *[vV]im$'
                                set ft=vim
                            
                                " MOO
                              elseif s:line1 =~# '^\*\* LambdaMOO Database, Format Version \%([1-3]\>\)\@!\d\+ \*\*$'
                                set ft=moo
                            
                                " Diff file:
                                " - "diff" in first line (context diff)
                                " - "Only in " in first line
                                " - "--- " in first line and "+++ " in second line (unified diff).
                                " - "*** " in first line and "--- " in second line (context diff).
                                " - "# It was generated by makepatch " in the second line (makepatch diff).
                                " - "Index: <filename>" in the first line (CVS file)
                                " - "=== ", line of "=", "---", "+++ " (SVK diff)
                                " - "=== ", "--- ", "+++ " (bzr diff, common case)
                                " - "=== (removed|added|renamed|modified)" (bzr diff, alternative)
                                " - "# HG changeset patch" in first line (Mercurial export format)
                              elseif s:line1 =~# '^\(diff\>\|Only in \|\d\+\(,\d\+\)\=[cda]\d\+\>\|# It was generated by makepatch \|Index:\s\+\f\+\r\=$\|===== \f\+ \d\+\.\d\+ vs edited\|==== //\f\+#\d\+\|# HG changeset patch\)'
                            	\ || (s:line1 =~# '^--- ' && s:line2 =~# '^+++ ')
                            	\ || (s:line1 =~# '^\* looking for ' && s:line2 =~# '^\* comparing to ')
                            	\ || (s:line1 =~# '^\*\*\* ' && s:line2 =~# '^--- ')
                            	\ || (s:line1 =~# '^=== ' && ((s:line2 =~# '^=\{66\}' && s:line3 =~# '^--- ' && s:line4 =~# '^+++') || (s:line2 =~# '^--- ' && s:line3 =~# '^+++ ')))
                            	\ || (s:line1 =~# '^=== \(removed\|added\|renamed\|modified\)')
                                set ft=diff
                            
                                " PostScript Files (must have %!PS as the first line, like a2ps output)
                              elseif s:line1 =~# '^%![ \t]*PS'
                                set ft=postscr
                            
                                " M4 scripts: Guess there is a line that starts with "dnl".
                              elseif s:line1 =~# '^\s*dnl\>'
                            	\ || s:line2 =~# '^\s*dnl\>'
                            	\ || s:line3 =~# '^\s*dnl\>'
                            	\ || s:line4 =~# '^\s*dnl\>'
                            	\ || s:line5 =~# '^\s*dnl\>'
                                set ft=m4
                            
                                " AmigaDos scripts
                              elseif $TERM == "amiga"
                            	\ && (s:line1 =~# "^;" || s:line1 =~? '^\.bra')
                                set ft=amiga
                            
                                " SiCAD scripts (must have procn or procd as the first line to trigger this)
                              elseif s:line1 =~? '^ *proc[nd] *$'
                                set ft=sicad
                            
                                " Purify log files start with "****  Purify"
                              elseif s:line1 =~# '^\*\*\*\*  Purify'
                                set ft=purifylog
                            
                                " XML
                              elseif s:line1 =~# '<?\s*xml.*?>'
                                set ft=xml
                            
                                " XHTML (e.g.: PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN")
                              elseif s:line1 =~# '\<DTD\s\+XHTML\s'
                                set ft=xhtml
                            
                                " HTML (e.g.: <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN")
                                " Avoid "doctype html", used by slim.
                              elseif s:line1 =~? '<!DOCTYPE\s\+html\>'
                                set ft=html
                            
                                " PDF
                              elseif s:line1 =~# '^%PDF-'
                                set ft=pdf
                            
                                " XXD output
                              elseif s:line1 =~# '^\x\{7}: \x\{2} \=\x\{2} \=\x\{2} \=\x\{2} '
                                set ft=xxd
                            
                                " RCS/CVS log output
                              elseif s:line1 =~# '^RCS file:' || s:line2 =~# '^RCS file:'
                                set ft=rcslog
                            
                                " CVS commit
                              elseif s:line2 =~# '^CVS:' || getline("$") =~# '^CVS: '
                                set ft=cvs
                            
                                " Prescribe
                              elseif s:line1 =~# '^!R!'
                                set ft=prescribe
                            
                                " Send-pr
                              elseif s:line1 =~# '^SEND-PR:'
                                set ft=sendpr
                            
                                " SNNS files
                              elseif s:line1 =~# '^SNNS network definition file'
                                set ft=snnsnet
                              elseif s:line1 =~# '^SNNS pattern definition file'
                                set ft=snnspat
                              elseif s:line1 =~# '^SNNS result file'
                                set ft=snnsres
                            
                                " Virata
                              elseif s:line1 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line2 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line3 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line4 =~# '^%.\{-}[Vv]irata'
                            	\ || s:line5 =~# '^%.\{-}[Vv]irata'
                                set ft=virata
                            
                                " Strace
                              elseif s:line1 =~# '[0-9:.]* *execve(' || s:line1 =~# '^__libc_start_main'
                                set ft=strace
                            
                                " VSE JCL
                              elseif s:line1 =~# '^\* $$ JOB\>' || s:line1 =~# '^// *JOB\>'
                                set ft=vsejcl
                            
                                " TAK and SINDA
                              elseif s:line4 =~# 'K & K  Associates' || s:line2 =~# 'TAK 2000'
                                set ft=takout
                              elseif s:line3 =~# 'S Y S T E M S   I M P R O V E D '
                                set ft=sindaout
                              elseif getline(6) =~# 'Run Date: '
                                set ft=takcmp
                              elseif getline(9) =~# 'Node    File  1'
                                set ft=sindacmp
                            
                                " DNS zone files
                              elseif s:line1.s:line2.s:line3.s:line4 =~# '^; <<>> DiG [0-9.]\+.* <<>>\|$ORIGIN\|$TTL\|IN\s\+SOA'
                                set ft=bindzone
                            
                                " BAAN
                              elseif s:line1 =~# '|\*\{1,80}' && s:line2 =~# 'VRC '
                            	\ || s:line2 =~# '|\*\{1,80}' && s:line3 =~# 'VRC '
                                set ft=baan
                            
                              " Valgrind
                              elseif s:line1 =~# '^==\d\+== valgrind' || s:line3 =~# '^==\d\+== Using valgrind'
                                set ft=valgrind
                            
                              " Go docs
                              elseif s:line1 =~# '^PACKAGE DOCUMENTATION$'
                                set ft=godoc
                            
                              " Renderman Interface Bytestream
                              elseif s:line1 =~# '^##RenderMan'
                                set ft=rib
                            
                              " Scheme scripts
                              elseif s:line1 =~# 'exec\s\+\S*scheme' || s:line2 =~# 'exec\s\+\S*scheme'
                                set ft=scheme
                            
                              " Git output
                              elseif s:line1 =~# '^\(commit\|tree\|object\) \x\{40\}\>\|^tag \S\+$'
                                set ft=git
                            
                               " Gprof (gnu profiler)
                               elseif s:line1 == 'Flat profile:'
                                 \ && s:line2 == ''
                                 \ && s:line3 =~# '^Each sample counts as .* seconds.$'
                                 set ft=gprof
                            
                              " Erlang terms
                              " (See also: http://www.gnu.org/software/emacs/manual/html_node/emacs/Choosing-Modes.html#Choosing-Modes)
                              elseif s:line1 =~? '-\*-.*erlang.*-\*-'
                                set ft=erlang
                            
                              " CVS diff
                              else
    1              0.000004     let s:lnum = 1
    1              0.000008     while getline(s:lnum) =~# "^? " && s:lnum < line("$")
                                  let s:lnum += 1
                                endwhile
    1              0.000005     if getline(s:lnum) =~# '^Index:\s\+\f\+$'
                                  set ft=diff
                            
                                  " locale input files: Formal Definitions of Cultural Conventions
                                  " filename must be like en_US, fr_FR@euro or en_US.UTF-8
                                elseif expand("%") =~# '\a\a_\a\a\($\|[.@]\)\|i18n$\|POSIX$\|translit_'
                                  let s:lnum = 1
                                  while s:lnum < 100 && s:lnum < line("$")
                            	if getline(s:lnum) =~# '^LC_\(IDENTIFICATION\|CTYPE\|COLLATE\|MONETARY\|NUMERIC\|TIME\|MESSAGES\|PAPER\|TELEPHONE\|MEASUREMENT\|NAME\|ADDRESS\)$'
                            	  setf fdcc
                            	  break
                            	endif
                            	let s:lnum += 1
                                  endwhile
                                endif
    1              0.000003     unlet s:lnum
                            
    1              0.000001   endif
                            
    1              0.000003   unlet s:line2 s:line3 s:line4 s:line5
                            
    1              0.000001 endif
                            
                            " Restore 'cpoptions'
    1              0.000012 let &cpo = s:cpo_save
                            
    1              0.000007 unlet s:cpo_save s:line1

SCRIPT  /Users/liss/.local/share/nvim/plugged/vim-markdown/syntax/markdown.vim
Sourced 3 times
Total time:   0.258057
 Self time:   0.021960

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Markdown
                            " Maintainer:	Ben Williams <benw@plasticboy.com>
                            " URL:		http://plasticboy.com/markdown-vim-mode/
                            " Remark:	Uses HTML syntax file
                            " TODO: 	Handle stuff contained within stuff (e.g. headings within blockquotes)
                            
                            
                            " Read the HTML syntax to start with
    3              0.000022 if version < 600
                              so <sfile>:p:h/html.vim
                            else
    3   0.248716   0.012618   runtime! syntax/html.vim
                            
    3              0.000032   if exists('b:current_syntax')
    3              0.000007     unlet b:current_syntax
    3              0.000003   endif
    3              0.000002 endif
                            
    3              0.000005 if version < 600
                              syntax clear
                            elseif exists("b:current_syntax")
                              finish
                            endif
                            
                            " don't use standard HiLink, it will not work with included syntax files
    3              0.000003 if version < 508
                              command! -nargs=+ HtmlHiLink hi link <args>
                            else
    3              0.000031   command! -nargs=+ HtmlHiLink hi def link <args>
    3              0.000002 endif
                            
    3              0.000009 syn spell toplevel
    3              0.000004 syn case ignore
    3              0.000008 syn sync linebreaks=1
                            
    3              0.000010 let s:conceal = ''
    3              0.000006 let s:concealends = ''
    3              0.000005 let s:concealcode = ''
    3              0.000020 if has('conceal') && get(g:, 'vim_markdown_conceal', 1)
    3              0.000006   let s:conceal = ' conceal'
    3              0.000005   let s:concealends = ' concealends'
    3              0.000003 endif
    3              0.000014 if has('conceal') && get(g:, 'vim_markdown_conceal_code_blocks', 1)
    3              0.000005   let s:concealcode = ' concealends'
    3              0.000058 endif
                            
                            " additions to HTML groups
    3              0.000015 if get(g:, 'vim_markdown_emphasis_multiline', 1)
    3              0.000007     let s:oneline = ''
    3              0.000003 else
                                let s:oneline = ' oneline'
                            endif
    3              0.000052 syn region mkdItalic matchgroup=mkdItalic start="\%(\*\|_\)"    end="\%(\*\|_\)"
    3              0.000047 syn region mkdBold matchgroup=mkdBold start="\%(\*\*\|__\)"    end="\%(\*\*\|__\)"
    3              0.000036 syn region mkdBoldItalic matchgroup=mkdBoldItalic start="\%(\*\*\*\|___\)"    end="\%(\*\*\*\|___\)"
    3              0.000114 execute 'syn region htmlItalic matchgroup=mkdItalic start="\%(^\|\s\)\zs\*\ze[^\\\*\t ]\%(\%([^*]\|\\\*\|\n\)*[^\\\*\t ]\)\?\*\_W" end="[^\\\*\t ]\zs\*\ze\_W" keepend contains=@Spell' . s:oneline . s:concealends
    3              0.000094 execute 'syn region htmlItalic matchgroup=mkdItalic start="\%(^\|\s\)\zs_\ze[^\\_\t ]" end="[^\\_\t ]\zs_\ze\_W" keepend contains=@Spell' . s:oneline . s:concealends
    3              0.000092 execute 'syn region htmlBold matchgroup=mkdBold start="\%(^\|\s\)\zs\*\*\ze\S" end="\S\zs\*\*" keepend contains=@Spell' . s:oneline . s:concealends
    3              0.000067 execute 'syn region htmlBold matchgroup=mkdBold start="\%(^\|\s\)\zs__\ze\S" end="\S\zs__" keepend contains=@Spell' . s:oneline . s:concealends
    3              0.000064 execute 'syn region htmlBoldItalic matchgroup=mkdBoldItalic start="\%(^\|\s\)\zs\*\*\*\ze\S" end="\S\zs\*\*\*" keepend contains=@Spell' . s:oneline . s:concealends
    3              0.000061 execute 'syn region htmlBoldItalic matchgroup=mkdBoldItalic start="\%(^\|\s\)\zs___\ze\S" end="\S\zs___" keepend contains=@Spell' . s:oneline . s:concealends
                            
                            " [link](URL) | [link][id] | [link][] | ![image](URL)
    3              0.000045 syn region mkdFootnotes matchgroup=mkdDelimiter start="\[^"    end="\]"
    3              0.000124 execute 'syn region mkdID matchgroup=mkdDelimiter    start="\["    end="\]" contained oneline' . s:conceal
    3              0.000070 execute 'syn region mkdURL matchgroup=mkdDelimiter   start="("     end=")"  contained oneline' . s:conceal
    3              0.000159 execute 'syn region mkdLink matchgroup=mkdDelimiter  start="\\\@<!!\?\[\ze[^]\n]*\n\?[^]\n]*\][[(]" end="\]" contains=@mkdNonListItem,@Spell nextgroup=mkdURL,mkdID skipwhite' . s:concealends
                            
                            " Autolink without angle brackets.
                            " mkd  inline links:      protocol     optional  user:pass@  sub/domain                    .com, .co.uk, etc         optional port   path/querystring/hash fragment
                            "                         ------------ _____________________ ----------------------------- _________________________ ----------------- __
    3              0.000071 syn match   mkdInlineURL /https\?:\/\/\(\w\+\(:\w\+\)\?@\)\?\([A-Za-z0-9][-_0-9A-Za-z]*\.\)\{1,}\(\w\{2,}\.\?\)\{1,}\(:[0-9]\{1,5}\)\?\S*/
                            
                            " Autolink with parenthesis.
    3              0.000077 syn region  mkdInlineURL matchgroup=mkdDelimiter start="(\(https\?:\/\/\(\w\+\(:\w\+\)\?@\)\?\([A-Za-z0-9][-_0-9A-Za-z]*\.\)\{1,}\(\w\{2,}\.\?\)\{1,}\(:[0-9]\{1,5}\)\?\S*)\)\@=" end=")"
                            
                            " Autolink with angle brackets.
    3              0.000100 syn region mkdInlineURL matchgroup=mkdDelimiter start="\\\@<!<\ze[a-z][a-z0-9,.-]\{1,22}:\/\/[^> ]*>" end=">"
                            
                            " Link definitions: [id]: URL (Optional Title)
    3              0.001186 syn region mkdLinkDef matchgroup=mkdDelimiter   start="^ \{,3}\zs\[\^\@!" end="]:" oneline nextgroup=mkdLinkDefTarget skipwhite
    3              0.000081 syn region mkdLinkDefTarget start="<\?\zs\S" excludenl end="\ze[>[:space:]\n]"   contained nextgroup=mkdLinkTitle,mkdLinkDef skipwhite skipnl oneline
    3              0.000038 syn region mkdLinkTitle matchgroup=mkdDelimiter start=+"+     end=+"+  contained
    3              0.000034 syn region mkdLinkTitle matchgroup=mkdDelimiter start=+'+     end=+'+  contained
    3              0.000035 syn region mkdLinkTitle matchgroup=mkdDelimiter start=+(+     end=+)+  contained
                            
                            "HTML headings
    3              0.000099 syn region htmlH1       matchgroup=mkdHeading     start="^\s*#"                   end="$" contains=mkdLink,mkdInlineURL,@Spell
    3              0.000077 syn region htmlH2       matchgroup=mkdHeading     start="^\s*##"                  end="$" contains=mkdLink,mkdInlineURL,@Spell
    3              0.000075 syn region htmlH3       matchgroup=mkdHeading     start="^\s*###"                 end="$" contains=mkdLink,mkdInlineURL,@Spell
    3              0.000088 syn region htmlH4       matchgroup=mkdHeading     start="^\s*####"                end="$" contains=mkdLink,mkdInlineURL,@Spell
    3              0.000451 syn region htmlH5       matchgroup=mkdHeading     start="^\s*#####"               end="$" contains=mkdLink,mkdInlineURL,@Spell
    3              0.000099 syn region htmlH6       matchgroup=mkdHeading     start="^\s*######"              end="$" contains=mkdLink,mkdInlineURL,@Spell
    3              0.000075 syn match  htmlH1       /^.\+\n=\+$/ contains=mkdLink,mkdInlineURL,@Spell
    3              0.000069 syn match  htmlH2       /^.\+\n-\+$/ contains=mkdLink,mkdInlineURL,@Spell
                            
                            "define Markdown groups
    3              0.000017 syn match  mkdLineBreak    /  \+$/
    3              0.000078 syn region mkdBlockquote   start=/^\s*>/                   end=/$/ contains=mkdLink,mkdInlineURL,mkdLineBreak,@Spell
    3              0.000090 execute 'syn region mkdCode matchgroup=mkdCodeDelimiter start=/\(\([^\\]\|^\)\\\)\@<!`/                     end=/`/'  . s:concealcode
    3              0.000066 execute 'syn region mkdCode matchgroup=mkdCodeDelimiter start=/\(\([^\\]\|^\)\\\)\@<!``/ skip=/[^`]`[^`]/   end=/``/' . s:concealcode
    3              0.000072 execute 'syn region mkdCode matchgroup=mkdCodeDelimiter start=/^\s*\z(`\{3,}\)[^`]*$/                       end=/^\s*\z1`*\s*$/'            . s:concealcode
    3              0.000066 execute 'syn region mkdCode matchgroup=mkdCodeDelimiter start=/\(\([^\\]\|^\)\\\)\@<!\~\~/  end=/\(\([^\\]\|^\)\\\)\@<!\~\~/'               . s:concealcode
    3              0.000077 execute 'syn region mkdCode matchgroup=mkdCodeDelimiter start=/^\s*\z(\~\{3,}\)\s*[0-9A-Za-z_+-]*\s*$/      end=/^\s*\z1\~*\s*$/'           . s:concealcode
    3              0.000056 execute 'syn region mkdCode matchgroup=mkdCodeDelimiter start="<pre[^>]*\\\@<!>"                            end="</pre>"'                   . s:concealcode
    3              0.000052 execute 'syn region mkdCode matchgroup=mkdCodeDelimiter start="<code[^>]*\\\@<!>"                           end="</code>"'                  . s:concealcode
    3              0.000045 syn region mkdFootnote     start="\[^"                     end="\]"
    3              0.000047 syn match  mkdCode         /^\s*\n\(\(\s\{8,}[^ ]\|\t\t\+[^\t]\).*\n\)\+/
    3              0.000178 syn match  mkdCode         /\%^\(\(\s\{4,}[^ ]\|\t\+[^\t]\).*\n\)\+/
    3              0.000113 syn match  mkdCode         /^\s*\n\(\(\s\{4,}[^ ]\|\t\+[^\t]\).*\n\)\+/ contained
    3              0.000043 syn match  mkdListItem     /^\s*\%([-*+]\|\d\+\.\)\ze\s\+/ contained
    3              0.000079 syn region mkdListItemLine start="^\s*\%([-*+]\|\d\+\.\)\s\+" end="$" oneline contains=@mkdNonListItem,mkdListItem,@Spell
    3              0.000088 syn region mkdNonListItemBlock start="\(\%^\(\s*\([-*+]\|\d\+\.\)\s\+\)\@!\|\n\(\_^\_$\|\s\{4,}[^ ]\|\t+[^\t]\)\@!\)" end="^\(\s*\([-*+]\|\d\+\.\)\s\+\)\@=" contains=@mkdNonListItem,@Spell
    3              0.000052 syn match  mkdRule         /^\s*\*\s\{0,1}\*\s\{0,1}\*\(\*\|\s\)*$/
    3              0.000040 syn match  mkdRule         /^\s*-\s\{0,1}-\s\{0,1}-\(-\|\s\)*$/
    3              0.000038 syn match  mkdRule         /^\s*_\s\{0,1}_\s\{0,1}_\(_\|\s\)*$/
                            
                            " YAML frontmatter
    3              0.000021 if get(g:, 'vim_markdown_frontmatter', 0)
                              syn include @yamlTop syntax/yaml.vim
                              syn region Comment matchgroup=mkdDelimiter start="\%^---$" end="^\(---\|\.\.\.\)$" contains=@yamlTop keepend
                              unlet! b:current_syntax
                            endif
                            
    3              0.000011 if get(g:, 'vim_markdown_toml_frontmatter', 0)
                              try
                                syn include @tomlTop syntax/toml.vim
                                syn region Comment matchgroup=mkdDelimiter start="\%^+++$" end="^+++$" transparent contains=@tomlTop keepend
                                unlet! b:current_syntax
                              catch /E484/
                                syn region Comment matchgroup=mkdDelimiter start="\%^+++$" end="^+++$"
                              endtry
                            endif
                            
    3              0.000010 if get(g:, 'vim_markdown_json_frontmatter', 0)
                              try
                                syn include @jsonTop syntax/json.vim
                                syn region Comment matchgroup=mkdDelimiter start="\%^{$" end="^}$" contains=@jsonTop keepend
                                unlet! b:current_syntax
                              catch /E484/
                                syn region Comment matchgroup=mkdDelimiter start="\%^{$" end="^}$"
                              endtry
                            endif
                            
    3              0.000012 if get(g:, 'vim_markdown_math', 0)
                              syn include @tex syntax/tex.vim
                              syn region mkdMath start="\\\@<!\$" end="\$" skip="\\\$" contains=@tex keepend
                              syn region mkdMath start="\\\@<!\$\$" end="\$\$" skip="\\\$" contains=@tex keepend
                            endif
                            
                            " Strike through
    3              0.000009 if get(g:, 'vim_markdown_strikethrough', 0)
                                execute 'syn region mkdStrike matchgroup=htmlStrike start="\%(\~\~\)" end="\%(\~\~\)"' . s:concealends
                                HtmlHiLink mkdStrike        htmlStrike
                            endif
                            
    3              0.000835 syn cluster mkdNonListItem contains=@htmlTop,htmlItalic,htmlBold,htmlBoldItalic,mkdFootnotes,mkdInlineURL,mkdLink,mkdLinkDef,mkdLineBreak,mkdBlockquote,mkdCode,mkdRule,htmlH1,htmlH2,htmlH3,htmlH4,htmlH5,htmlH6,mkdMath,mkdStrike
                            
                            "highlighting for Markdown groups
    3              0.000043 HtmlHiLink mkdString        String
    3              0.000037 HtmlHiLink mkdCode          String
    3              0.000024 HtmlHiLink mkdCodeDelimiter String
    3              0.000028 HtmlHiLink mkdCodeStart     String
    3              0.000027 HtmlHiLink mkdCodeEnd       String
    3              0.000021 HtmlHiLink mkdFootnote      Comment
    3              0.000030 HtmlHiLink mkdBlockquote    Comment
    3              0.000032 HtmlHiLink mkdListItem      Identifier
    3              0.000031 HtmlHiLink mkdRule          Identifier
    3              0.000024 HtmlHiLink mkdLineBreak     Visual
    3              0.000020 HtmlHiLink mkdFootnotes     htmlLink
    3              0.000029 HtmlHiLink mkdLink          htmlLink
    3              0.000022 HtmlHiLink mkdURL           htmlString
    3              0.000093 HtmlHiLink mkdInlineURL     htmlLink
    3              0.000046 HtmlHiLink mkdID            Identifier
    3              0.000039 HtmlHiLink mkdLinkDef       mkdID
    3              0.000026 HtmlHiLink mkdLinkDefTarget mkdURL
    3              0.000015 HtmlHiLink mkdLinkTitle     htmlString
    3              0.000040 HtmlHiLink mkdDelimiter     Delimiter
                            
    3              0.000015 let b:current_syntax = "mkd"
                            
    3              0.000011 delcommand HtmlHiLink
                            " vim: ts=8

SCRIPT  /usr/local/Cellar/neovim/HEAD-c6cd608/share/nvim/runtime/syntax/html.vim
Sourced 3 times
Total time:   0.235883
 Self time:   0.069750

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:             HTML
                            " Maintainer:           Jorge Maldonado Ventura <jorgesumle@freakspot.net>
                            " Previous Maintainer:  Claudio Fleiner <claudio@fleiner.com>
                            " Repository:           https://notabug.org/jorgesumle/vim-html-syntax
                            " Last Change:          2018 May 31
                            " Included patch from Jay Sitter to add WAI-ARIA htmlArg keywords
                            "
                            
                            " Please check :help html.vim for some comments and a description of the options
                            
                            " quit when a syntax file was already loaded
    3              0.000029 if !exists("main_syntax")
    3              0.000010   if exists("b:current_syntax")
                                finish
                              endif
    3              0.000029   let main_syntax = 'html'
    3              0.000003 endif
                            
    3              0.000022 let s:cpo_save = &cpo
    3              0.000032 set cpo&vim
                            
    3              0.000006 syntax spell toplevel
                            
    3              0.000003 syn case ignore
                            
                            " mark illegal characters
    3              0.000343 syn match htmlError "[<>&]"
                            
                            
                            " tags
    3              0.000078 syn region  htmlString   contained start=+"+ end=+"+ contains=htmlSpecialChar,javaScriptExpression,@htmlPreproc
    3              0.000040 syn region  htmlString   contained start=+'+ end=+'+ contains=htmlSpecialChar,javaScriptExpression,@htmlPreproc
    3              0.000037 syn match   htmlValue    contained "=[\t ]*[^'" \t>][^ \t>]*"hs=s+1   contains=javaScriptExpression,@htmlPreproc
    3              0.000099 syn region  htmlEndTag             start=+</+      end=+>+ contains=htmlTagN,htmlTagError
    3              0.000129 syn region  htmlTag                start=+<[^/]+   end=+>+ fold contains=htmlTagN,htmlString,htmlArg,htmlValue,htmlTagError,htmlEvent,htmlCssDefinition,@htmlPreproc,@htmlArgCluster
    3              0.000085 syn match   htmlTagN     contained +<\s*[-a-zA-Z0-9]\++hs=s+1 contains=htmlTagName,htmlSpecialTagName,@htmlTagNameCluster
    3              0.000067 syn match   htmlTagN     contained +</\s*[-a-zA-Z0-9]\++hs=s+2 contains=htmlTagName,htmlSpecialTagName,@htmlTagNameCluster
    3              0.000013 syn match   htmlTagError contained "[^>]<"ms=s+1
                            
                            
                            " tag names
    3              0.000026 syn keyword htmlTagName contained address applet area a base basefont
    3              0.000023 syn keyword htmlTagName contained big blockquote br caption center
    3              0.000026 syn keyword htmlTagName contained cite code dd dfn dir div dl dt font
    3              0.000020 syn keyword htmlTagName contained form hr html img
    3              0.000022 syn keyword htmlTagName contained input isindex kbd li link map menu
    3              0.000022 syn keyword htmlTagName contained meta ol option param pre p samp span
    3              0.000071 syn keyword htmlTagName contained select small sub sup
    3              0.000044 syn keyword htmlTagName contained table td textarea th tr tt ul var xmp
    3              0.000032 syn match htmlTagName contained "\<\(b\|i\|u\|h[1-6]\|em\|strong\|head\|body\|title\)\>"
                            
                            " new html 4.0 tags
    3              0.000021 syn keyword htmlTagName contained abbr acronym bdo button col label
    3              0.000019 syn keyword htmlTagName contained colgroup fieldset iframe ins legend
    3              0.000020 syn keyword htmlTagName contained object optgroup q s tbody tfoot thead
                            
                            " new html 5 tags
    3              0.000025 syn keyword htmlTagName contained article aside audio bdi canvas data
    3              0.000021 syn keyword htmlTagName contained datalist details embed figcaption figure
    3              0.000020 syn keyword htmlTagName contained footer header hgroup keygen main mark
    3              0.000018 syn keyword htmlTagName contained menuitem meter nav output picture
    3              0.000021 syn keyword htmlTagName contained progress rb rp rt rtc ruby section
    3              0.000020 syn keyword htmlTagName contained slot source template time track video wbr
                            
                            " legal arg names
    3              0.000007 syn keyword htmlArg contained action
    3              0.000011 syn keyword htmlArg contained align alink alt archive background bgcolor
    3              0.000009 syn keyword htmlArg contained border bordercolor cellpadding
    3              0.000013 syn keyword htmlArg contained cellspacing checked class clear code codebase color
    3              0.000014 syn keyword htmlArg contained cols colspan content coords enctype face
    3              0.000009 syn keyword htmlArg contained gutter height hspace id
    3              0.000008 syn keyword htmlArg contained link lowsrc marginheight
    3              0.000010 syn keyword htmlArg contained marginwidth maxlength method name prompt
    3              0.000012 syn keyword htmlArg contained rel rev rows rowspan scrolling selected shape
    3              0.000012 syn keyword htmlArg contained size src start target text type url
    3              0.000012 syn keyword htmlArg contained usemap ismap valign value vlink vspace width wrap
    3              0.000017 syn match   htmlArg contained "\<\(http-equiv\|href\|title\)="me=e-1
                            
                            " aria attributes
    3              0.000033 syn match htmlArg contained "\<\(aria-activedescendant\|aria-atomic\)\>"
    3              0.000017 syn match htmlArg contained "\<\(aria-autocomplete\|aria-busy\|aria-checked\)\>"
    3              0.000016 syn match htmlArg contained "\<\(aria-colcount\|aria-colindex\|aria-colspan\)\>"
    3              0.001072 syn match htmlArg contained "\<\(aria-controls\|aria-current\)\>"
    3              0.000024 syn match htmlArg contained "\<\(aria-describedby\|aria-details\)\>"
    3              0.000018 syn match htmlArg contained "\<\(aria-disabled\|aria-dropeffect\)\>"
    3              0.000014 syn match htmlArg contained "\<\(aria-errormessage\|aria-expanded\)\>"
    3              0.000016 syn match htmlArg contained "\<\(aria-flowto\|aria-grabbed\|aria-haspopup\)\>"
    3              0.000013 syn match htmlArg contained "\<\(aria-hidden\|aria-invalid\)\>"
    3              0.000080 syn match htmlArg contained "\<\(aria-keyshortcuts\|aria-label\)\>"
    3              0.000020 syn match htmlArg contained "\<\(aria-labelledby\|aria-level\|aria-live\)\>"
    3              0.000014 syn match htmlArg contained "\<\(aria-modal\|aria-multiline\)\>"
    3              0.000015 syn match htmlArg contained "\<\(aria-multiselectable\|aria-orientation\)\>"
    3              0.000016 syn match htmlArg contained "\<\(aria-owns\|aria-placeholder\|aria-posinset\)\>"
    3              0.000015 syn match htmlArg contained "\<\(aria-pressed\|aria-readonly\|aria-relevant\)\>"
    3              0.000017 syn match htmlArg contained "\<\(aria-required\|aria-roledescription\)\>"
    3              0.000015 syn match htmlArg contained "\<\(aria-rowcount\|aria-rowindex\|aria-rowspan\)\>"
    3              0.000014 syn match htmlArg contained "\<\(aria-selected\|aria-setsize\|aria-sort\)\>"
    3              0.000013 syn match htmlArg contained "\<\(aria-valuemax\|aria-valuemin\)\>"
    3              0.000013 syn match htmlArg contained "\<\(aria-valuenow\|aria-valuetext\)\>"
    3              0.000008 syn keyword htmlArg contained role
                            
                            " Netscape extensions
    3              0.000029 syn keyword htmlTagName contained frame noframes frameset nobr blink
    3              0.000029 syn keyword htmlTagName contained layer ilayer nolayer spacer
    3              0.000067 syn keyword htmlArg     contained frameborder noresize pagex pagey above below
    3              0.000048 syn keyword htmlArg     contained left top visibility clip id noshade
    3              0.000012 syn match   htmlArg     contained "\<z-index\>"
                            
                            " Microsoft extensions
    3              0.000025 syn keyword htmlTagName contained marquee
                            
                            " html 4.0 arg names
    3              0.000016 syn match   htmlArg contained "\<\(accept-charset\|label\)\>"
    3              0.000061 syn keyword htmlArg contained abbr accept accesskey axis char charoff charset
    3              0.000045 syn keyword htmlArg contained cite classid codetype compact data datetime
    3              0.000044 syn keyword htmlArg contained declare defer dir disabled for frame
    3              0.000050 syn keyword htmlArg contained headers hreflang lang language longdesc
    3              0.000027 syn keyword htmlArg contained multiple nohref nowrap object profile readonly
    3              0.000012 syn keyword htmlArg contained rules scheme scope span standby style
    3              0.000010 syn keyword htmlArg contained summary tabindex valuetype version
                            
                            " html 5 arg names
    3              0.000013 syn keyword htmlArg contained allowfullscreen async autocomplete autofocus
    3              0.000011 syn keyword htmlArg contained autoplay challenge contenteditable contextmenu
    3              0.000011 syn keyword htmlArg contained controls crossorigin default dialog dirname
    3              0.000011 syn keyword htmlArg contained download draggable dropzone form formaction
    3              0.000010 syn keyword htmlArg contained formenctype formmethod formnovalidate formtarget
    3              0.000013 syn keyword htmlArg contained hidden high icon inputmode keytype kind list loop
    3              0.000012 syn keyword htmlArg contained low max min minlength muted nonce novalidate open
    3              0.000010 syn keyword htmlArg contained optimum pattern placeholder poster preload
    3              0.000010 syn keyword htmlArg contained radiogroup required reversed sandbox spellcheck
    3              0.000012 syn keyword htmlArg contained sizes srcset srcdoc srclang step title translate
    3              0.000007 syn keyword htmlArg contained typemustmatch
                            
                            " special characters
    3              0.000025 syn match htmlSpecialChar "&#\=[0-9A-Za-z]\{1,8};"
                            
                            " Comments (the real ones or the old netscape ones)
    3              0.000017 if exists("html_wrong_comments")
                              syn region htmlComment                start=+<!--+    end=+--\s*>+ contains=@Spell
                            else
    3              0.000053   syn region htmlComment                start=+<!+      end=+>+   contains=htmlCommentPart,htmlCommentError,@Spell
    3              0.000013   syn match  htmlCommentError contained "[^><!]"
    3              0.000042   syn region htmlCommentPart  contained start=+--+      end=+--\s*+  contains=@htmlPreProc,@Spell
    3              0.000003 endif
    3              0.000020 syn region htmlComment                  start=+<!DOCTYPE+ keepend end=+>+
                            
                            " server-parsed commands
    3              0.000051 syn region htmlPreProc start=+<!--#+ end=+-->+ contains=htmlPreStmt,htmlPreError,htmlPreAttr
    3              0.000025 syn match htmlPreStmt contained "<!--#\(config\|echo\|exec\|fsize\|flastmod\|include\|printenv\|set\|if\|elif\|else\|endif\|geoguide\)\>"
    3              0.000011 syn match htmlPreError contained "<!--#\S*"ms=s+4
    3              0.000137 syn match htmlPreAttr contained "\w\+=[^"]\S\+" contains=htmlPreProcAttrError,htmlPreProcAttrName
    3              0.000111 syn region htmlPreAttr contained start=+\w\+="+ skip=+\\\\\|\\"+ end=+"+ contains=htmlPreProcAttrName keepend
    3              0.000012 syn match htmlPreProcAttrError contained "\w\+="he=e-1
    3              0.000020 syn match htmlPreProcAttrName contained "\(expr\|errmsg\|sizefmt\|timefmt\|var\|cgi\|cmd\|file\|virtual\|value\)="he=e-1
                            
    3              0.000014 if !exists("html_no_rendering")
                              " rendering
    3              0.000117   syn cluster htmlTop contains=@Spell,htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLink,javaScript,@htmlPreproc
                            
    3              0.000029   syn region htmlStrike start="<del\>" end="</del>"me=e-6 contains=@htmlTop
    3              0.000021   syn region htmlStrike start="<strike\>" end="</strike>"me=e-9 contains=@htmlTop
                            
    3              0.000089   syn region htmlBold start="<b\>" end="</b>"me=e-4 contains=@htmlTop,htmlBoldUnderline,htmlBoldItalic
    3              0.000121   syn region htmlBold start="<strong\>" end="</strong>"me=e-9 contains=@htmlTop,htmlBoldUnderline,htmlBoldItalic
    3              0.000052   syn region htmlBoldUnderline contained start="<u\>" end="</u>"me=e-4 contains=@htmlTop,htmlBoldUnderlineItalic
    3              0.000053   syn region htmlBoldItalic contained start="<i\>" end="</i>"me=e-4 contains=@htmlTop,htmlBoldItalicUnderline
    3              0.000045   syn region htmlBoldItalic contained start="<em\>" end="</em>"me=e-5 contains=@htmlTop,htmlBoldItalicUnderline
    3              0.000026   syn region htmlBoldUnderlineItalic contained start="<i\>" end="</i>"me=e-4 contains=@htmlTop
    3              0.000023   syn region htmlBoldUnderlineItalic contained start="<em\>" end="</em>"me=e-5 contains=@htmlTop
    3              0.000030   syn region htmlBoldItalicUnderline contained start="<u\>" end="</u>"me=e-4 contains=@htmlTop,htmlBoldUnderlineItalic
                            
    3              0.000069   syn region htmlUnderline start="<u\>" end="</u>"me=e-4 contains=@htmlTop,htmlUnderlineBold,htmlUnderlineItalic
    3              0.000042   syn region htmlUnderlineBold contained start="<b\>" end="</b>"me=e-4 contains=@htmlTop,htmlUnderlineBoldItalic
    3              0.000040   syn region htmlUnderlineBold contained start="<strong\>" end="</strong>"me=e-9 contains=@htmlTop,htmlUnderlineBoldItalic
    3              0.000093   syn region htmlUnderlineItalic contained start="<i\>" end="</i>"me=e-4 contains=@htmlTop,htmlUnderlineItalicBold
    3              0.000032   syn region htmlUnderlineItalic contained start="<em\>" end="</em>"me=e-5 contains=@htmlTop,htmlUnderlineItalicBold
    3              0.000021   syn region htmlUnderlineItalicBold contained start="<b\>" end="</b>"me=e-4 contains=@htmlTop
    3              0.000026   syn region htmlUnderlineItalicBold contained start="<strong\>" end="</strong>"me=e-9 contains=@htmlTop
    3              0.000023   syn region htmlUnderlineBoldItalic contained start="<i\>" end="</i>"me=e-4 contains=@htmlTop
    3              0.000022   syn region htmlUnderlineBoldItalic contained start="<em\>" end="</em>"me=e-5 contains=@htmlTop
                            
    3              0.000138   syn region htmlItalic start="<i\>" end="</i>"me=e-4 contains=@htmlTop,htmlItalicBold,htmlItalicUnderline
    3              0.000039   syn region htmlItalic start="<em\>" end="</em>"me=e-5 contains=@htmlTop
    3              0.000113   syn region htmlItalicBold contained start="<b\>" end="</b>"me=e-4 contains=@htmlTop,htmlItalicBoldUnderline
    3              0.000040   syn region htmlItalicBold contained start="<strong\>" end="</strong>"me=e-9 contains=@htmlTop,htmlItalicBoldUnderline
    3              0.000023   syn region htmlItalicBoldUnderline contained start="<u\>" end="</u>"me=e-4 contains=@htmlTop
    3              0.000039   syn region htmlItalicUnderline contained start="<u\>" end="</u>"me=e-4 contains=@htmlTop,htmlItalicUnderlineBold
    3              0.000021   syn region htmlItalicUnderlineBold contained start="<b\>" end="</b>"me=e-4 contains=@htmlTop
    3              0.000023   syn region htmlItalicUnderlineBold contained start="<strong\>" end="</strong>"me=e-9 contains=@htmlTop
                            
    3              0.000018   syn match htmlLeadingSpace "^\s\+" contained
    3              0.000123   syn region htmlLink start="<a\>\_[^>]*\<href\>" end="</a>"me=e-4 contains=@Spell,htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLeadingSpace,javaScript,@htmlPreproc
    3              0.000030   syn region htmlH1 start="<h1\>" end="</h1>"me=e-5 contains=@htmlTop
    3              0.000032   syn region htmlH2 start="<h2\>" end="</h2>"me=e-5 contains=@htmlTop
    3              0.000027   syn region htmlH3 start="<h3\>" end="</h3>"me=e-5 contains=@htmlTop
    3              0.000028   syn region htmlH4 start="<h4\>" end="</h4>"me=e-5 contains=@htmlTop
    3              0.000027   syn region htmlH5 start="<h5\>" end="</h5>"me=e-5 contains=@htmlTop
    3              0.000036   syn region htmlH6 start="<h6\>" end="</h6>"me=e-5 contains=@htmlTop
    3              0.000306   syn region htmlHead start="<head\>" end="</head>"me=e-7 end="<body\>"me=e-5 end="<h[1-6]\>"me=e-3 contains=htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,htmlLink,htmlTitle,javaScript,cssStyle,@htmlPreproc
    3              0.000104   syn region htmlTitle start="<title\>" end="</title>"me=e-8 contains=htmlTag,htmlEndTag,htmlSpecialChar,htmlPreProc,htmlComment,javaScript,@htmlPreproc
    3              0.000004 endif
                            
    3              0.000018 syn keyword htmlTagName         contained noscript
    3              0.000010 syn keyword htmlSpecialTagName  contained script style
    3              0.000018 if main_syntax != 'java' || exists("java_javascript")
                              " JAVA SCRIPT
    3   0.010824   0.006838   syn include @htmlJavaScript syntax/javascript.vim
    3              0.000017   unlet b:current_syntax
    3              0.000101   syn region  javaScript start=+<script\_[^>]*>+ keepend end=+</script\_[^>]*>+me=s-1 contains=@htmlJavaScript,htmlCssStyleComment,htmlScriptTag,@htmlPreproc
    3              0.000097   syn region  htmlScriptTag     contained start=+<script+ end=+>+ fold contains=htmlTagN,htmlString,htmlArg,htmlValue,htmlTagError,htmlEvent
    3              0.000023   hi def link htmlScriptTag htmlTag
                            
                              " html events (i.e. arguments that include javascript commands)
    3              0.000016   if exists("html_extended_events")
                                syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*'+ end=+'+ contains=htmlEventSQ
                                syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*"+ end=+"+ contains=htmlEventDQ
                              else
    3              0.000024     syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*'+ end=+'+ keepend contains=htmlEventSQ
    3              0.000023     syn region htmlEvent        contained start=+\<on\a\+\s*=[\t ]*"+ end=+"+ keepend contains=htmlEventDQ
    3              0.000002   endif
    3              0.000020   syn region htmlEventSQ        contained start=+'+ms=s+1 end=+'+me=s-1 contains=@htmlJavaScript
    3              0.000018   syn region htmlEventDQ        contained start=+"+ms=s+1 end=+"+me=s-1 contains=@htmlJavaScript
    3              0.000008   hi def link htmlEventSQ htmlEvent
    3              0.000007   hi def link htmlEventDQ htmlEvent
                            
                              " a javascript expression is used as an arg value
    3              0.000044   syn region  javaScriptExpression contained start=+&{+ keepend end=+};+ contains=@htmlJavaScript,@htmlPreproc
    3              0.000038 endif
                            
    3              0.000013 if main_syntax != 'java' || exists("java_vb")
                              " VB SCRIPT
    3   0.018129   0.005211   syn include @htmlVbScript syntax/vb.vim
    3              0.000013   unlet b:current_syntax
    3              0.000066   syn region  javaScript start=+<script \_[^>]*language *=\_[^>]*vbscript\_[^>]*>+ keepend end=+</script\_[^>]*>+me=s-1 contains=@htmlVbScript,htmlCssStyleComment,htmlScriptTag,@htmlPreproc
    3              0.000004 endif
                            
    3              0.000014 syn cluster htmlJavaScript      add=@htmlPreproc
                            
    3              0.000019 if main_syntax != 'java' || exists("java_css")
                              " embedded style sheets
    3              0.000010   syn keyword htmlArg           contained media
    3   0.152206   0.002977   syn include @htmlCss syntax/css.vim
    3              0.000016   unlet b:current_syntax
    3              0.000233   syn region cssStyle start=+<style+ keepend end=+</style>+ contains=@htmlCss,htmlTag,htmlEndTag,htmlCssStyleComment,@htmlPreproc
    3              0.000050   syn match htmlCssStyleComment contained "\(<!--\|-->\)"
    3              0.044742   syn region htmlCssDefinition matchgroup=htmlArg start='style="' keepend matchgroup=htmlString end='"' contains=css.*Attr,css.*Prop,cssComment,cssLength,cssColor,cssURL,cssImportant,cssError,cssString,@htmlPreproc
    3              0.000055   hi def link htmlStyleArg htmlString
    3              0.000008 endif
                            
    3              0.000024 if main_syntax == "html"
                              " synchronizing (does not always work if a comment includes legal
                              " html tags, but doing it right would mean to always start
                              " at the first line, which is too slow)
    3              0.000050   syn sync match htmlHighlight groupthere NONE "<[/a-zA-Z]"
    3              0.000035   syn sync match htmlHighlight groupthere javaScript "<script"
    3              0.000029   syn sync match htmlHighlightSkip "^.*['\"].*$"
    3              0.000007   syn sync minlines=10
    3              0.000003 endif
                            
                            " The default highlighting.
    3              0.000083 hi def link htmlTag                     Function
    3              0.000067 hi def link htmlEndTag                  Identifier
    3              0.000066 hi def link htmlArg                     Type
    3              0.000039 hi def link htmlTagName                 htmlStatement
    3              0.000033 hi def link htmlSpecialTagName          Exception
    3              0.000032 hi def link htmlValue                     String
    3              0.000029 hi def link htmlSpecialChar             Special
                            
    3              0.000019 if !exists("html_no_rendering")
    3              0.000047   hi def link htmlH1                      Title
    3              0.000094   hi def link htmlH2                      htmlH1
    3              0.000038   hi def link htmlH3                      htmlH2
    3              0.000034   hi def link htmlH4                      htmlH3
    3              0.000033   hi def link htmlH5                      htmlH4
    3              0.000034   hi def link htmlH6                      htmlH5
    3              0.000024   hi def link htmlHead                    PreProc
    3              0.000029   hi def link htmlTitle                   Title
    3              0.000014   hi def link htmlBoldItalicUnderline     htmlBoldUnderlineItalic
    3              0.000012   hi def link htmlUnderlineBold           htmlBoldUnderline
    3              0.000038   hi def link htmlUnderlineItalicBold     htmlBoldUnderlineItalic
    3              0.000011   hi def link htmlUnderlineBoldItalic     htmlBoldUnderlineItalic
    3              0.000012   hi def link htmlItalicUnderline         htmlUnderlineItalic
    3              0.000025   hi def link htmlItalicBold              htmlBoldItalic
    3              0.000013   hi def link htmlItalicBoldUnderline     htmlBoldUnderlineItalic
    3              0.000011   hi def link htmlItalicUnderlineBold     htmlBoldUnderlineItalic
    3              0.000039   hi def link htmlLink                    Underlined
    3              0.000019   hi def link htmlLeadingSpace            None
    3              0.000015   if !exists("html_my_rendering")
    3              0.000026     hi def htmlBold                term=bold cterm=bold gui=bold
    3              0.000050     hi def htmlBoldUnderline       term=bold,underline cterm=bold,underline gui=bold,underline
    3              0.000022     hi def htmlBoldItalic          term=bold,italic cterm=bold,italic gui=bold,italic
    3              0.000014     hi def htmlBoldUnderlineItalic term=bold,italic,underline cterm=bold,italic,underline gui=bold,italic,underline
    3              0.000010     hi def htmlUnderline           term=underline cterm=underline gui=underline
    3              0.000022     hi def htmlUnderlineItalic     term=italic,underline cterm=italic,underline gui=italic,underline
    3              0.000025     hi def htmlItalic              term=italic cterm=italic gui=italic
    3              0.000032     if v:version > 800 || v:version == 800 && has("patch1038")
                                    hi def htmlStrike              term=strikethrough cterm=strikethrough gui=strikethrough
                                else
    3              0.000014         hi def htmlStrike              term=underline cterm=underline gui=underline
    3              0.000003     endif
    3              0.000002   endif
    3              0.000002 endif
                            
    3              0.000043 hi def link htmlPreStmt            PreProc
    3              0.000028 hi def link htmlPreError           Error
    3              0.000025 hi def link htmlPreProc            PreProc
    3              0.000027 hi def link htmlPreAttr            String
    3              0.000026 hi def link htmlPreProcAttrName    PreProc
    3              0.000026 hi def link htmlPreProcAttrError   Error
    3              0.000026 hi def link htmlSpecial            Special
    3              0.000025 hi def link htmlSpecialChar        Special
    3              0.000026 hi def link htmlString             String
    3              0.000021 hi def link htmlStatement          Statement
    3              0.000024 hi def link htmlComment            Comment
    3              0.000025 hi def link htmlCommentPart        Comment
    3              0.000026 hi def link htmlValue              String
    3              0.000014 hi def link htmlCommentError       htmlError
    3              0.000012 hi def link htmlTagError           htmlError
    3              0.000012 hi def link htmlEvent              javaScript
    3              0.000025 hi def link htmlError              Error
                            
    3              0.000023 hi def link javaScript             Special
    3              0.000014 hi def link javaScriptExpression   javaScript
    3              0.000023 hi def link htmlCssStyleComment    Comment
    3              0.000025 hi def link htmlCssDefinition      Special
                            
    3              0.000016 let b:current_syntax = "html"
                            
    3              0.000012 if main_syntax == 'html'
    3              0.000009   unlet main_syntax
    3              0.000003 endif
                            
    3              0.000041 let &cpo = s:cpo_save
    3              0.000007 unlet s:cpo_save
                            " vim: ts=8

SCRIPT  /usr/local/Cellar/neovim/HEAD-c6cd608/share/nvim/runtime/syntax/javascript.vim
Sourced 3 times
Total time:   0.003807
 Self time:   0.003807

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	JavaScript
                            " Maintainer:	Claudio Fleiner <claudio@fleiner.com>
                            " Updaters:	Scott Shattuck (ss) <ss@technicalpursuit.com>
                            " URL:		http://www.fleiner.com/vim/syntax/javascript.vim
                            " Changes:	(ss) added keywords, reserved words, and other identifiers
                            "		(ss) repaired several quoting and grouping glitches
                            "		(ss) fixed regex parsing issue with multiple qualifiers [gi]
                            "		(ss) additional factoring of keywords, globals, and members
                            " Last Change:	2018 Jul 28
                            " 		2013 Jun 12: adjusted javaScriptRegexpString (Kevin Locke)
                            " 		2018 Apr 14: adjusted javaScriptRegexpString (LongJohnCoder)
                            
                            " tuning parameters:
                            " unlet javaScript_fold
                            
    3              0.000026 if !exists("main_syntax")
                              " quit when a syntax file was already loaded
                              if exists("b:current_syntax")
                                finish
                              endif
                              let main_syntax = 'javascript'
                            elseif exists("b:current_syntax") && b:current_syntax == "javascript"
                              finish
                            endif
                            
    3              0.000025 let s:cpo_save = &cpo
    3              0.000026 set cpo&vim
                            
                            
    3              0.000038 syn keyword javaScriptCommentTodo      TODO FIXME XXX TBD contained
    3              0.000051 syn match   javaScriptLineComment      "\/\/.*" contains=@Spell,javaScriptCommentTodo
    3              0.000034 syn match   javaScriptCommentSkip      "^[ \t]*\*\($\|[ \t]\+\)"
    3              0.000066 syn region  javaScriptComment	       start="/\*"  end="\*/" contains=@Spell,javaScriptCommentTodo
    3              0.000024 syn match   javaScriptSpecial	       "\\\d\d\d\|\\."
    3              0.000048 syn region  javaScriptStringD	       start=+"+  skip=+\\\\\|\\"+  end=+"\|$+	contains=javaScriptSpecial,@htmlPreproc
    3              0.000061 syn region  javaScriptStringS	       start=+'+  skip=+\\\\\|\\'+  end=+'\|$+	contains=javaScriptSpecial,@htmlPreproc
    3              0.000054 syn region  javaScriptStringT	       start=+`+  skip=+\\\\\|\\`+  end=+`+	contains=javaScriptSpecial,javaScriptEmbed,@htmlPreproc
                            
    3              0.000022 syn region  javaScriptEmbed	       start=+${+  end=+}+	contains=@javaScriptEmbededExpr
                            
    3              0.000020 syn match   javaScriptSpecialCharacter "'\\.'"
    3              0.000037 syn match   javaScriptNumber	       "-\=\<\d\+L\=\>\|0[xX][0-9a-fA-F]\+\>"
    3              0.000079 syn region  javaScriptRegexpString     start=+[,(=+]\s*/[^/*]+ms=e-1,me=e-1 skip=+\\\\\|\\/+ end=+/[gimuys]\{0,2\}\s*$+ end=+/[gimuys]\{0,2\}\s*[+;.,)\]}]+me=e-1 end=+/[gimuys]\{0,2\}\s\+\/+me=e-1 contains=@htmlPreproc,javaScriptComment oneline
                            
    3              0.000019 syn keyword javaScriptConditional	if else switch
    3              0.000019 syn keyword javaScriptRepeat		while for do in
    3              0.000015 syn keyword javaScriptBranch		break continue
    3              0.000018 syn keyword javaScriptOperator		new delete instanceof typeof
    3              0.000022 syn keyword javaScriptType		Array Boolean Date Function Number Object String RegExp
    3              0.000015 syn keyword javaScriptStatement		return with
    3              0.000014 syn keyword javaScriptBoolean		true false
    3              0.000014 syn keyword javaScriptNull		null undefined
    3              0.000017 syn keyword javaScriptIdentifier	arguments this var let
    3              0.000014 syn keyword javaScriptLabel		case default
    3              0.000016 syn keyword javaScriptException		try catch finally throw
    3              0.000016 syn keyword javaScriptMessage		alert confirm prompt status
    3              0.000053 syn keyword javaScriptGlobal		self window top parent
    3              0.000015 syn keyword javaScriptMember		document event location 
    3              0.000017 syn keyword javaScriptDeprecated	escape unescape
    3              0.000044 syn keyword javaScriptReserved		abstract boolean byte char class const debugger double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile 
                            
    3              0.000042 syn cluster  javaScriptEmbededExpr	contains=javaScriptBoolean,javaScriptNull,javaScriptIdentifier,javaScriptStringD,javaScriptStringS,javaScriptStringT
                            
    3              0.000013 if exists("javaScript_fold")
                                syn match	javaScriptFunction	"\<function\>"
                                syn region	javaScriptFunctionFold	start="\<function\>.*[^};]$" end="^\z1}.*$" transparent fold keepend
                            
                                syn sync match javaScriptSync	grouphere javaScriptFunctionFold "\<function\>"
                                syn sync match javaScriptSync	grouphere NONE "^}"
                            
                                setlocal foldmethod=syntax
                                setlocal foldtext=getline(v:foldstart)
                            else
    3              0.000022     syn keyword javaScriptFunction	function
    3              0.000023     syn match	javaScriptBraces	   "[{}\[\]]"
    3              0.000018     syn match	javaScriptParens	   "[()]"
    3              0.000003 endif
                            
    3              0.000004 syn sync fromstart
    3              0.000004 syn sync maxlines=100
                            
    3              0.000011 if main_syntax == "javascript"
                              syn sync ccomment javaScriptComment
                            endif
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
    3              0.000041 hi def link javaScriptComment		Comment
    3              0.000090 hi def link javaScriptLineComment		Comment
    3              0.000023 hi def link javaScriptCommentTodo		Todo
    3              0.000020 hi def link javaScriptSpecial		Special
    3              0.000022 hi def link javaScriptStringS		String
    3              0.000021 hi def link javaScriptStringD		String
    3              0.000020 hi def link javaScriptStringT		String
    3              0.000026 hi def link javaScriptCharacter		Character
    3              0.000009 hi def link javaScriptSpecialCharacter	javaScriptSpecial
    3              0.000038 hi def link javaScriptNumber		javaScriptValue
    3              0.000019 hi def link javaScriptConditional		Conditional
    3              0.000019 hi def link javaScriptRepeat		Repeat
    3              0.000017 hi def link javaScriptBranch		Conditional
    3              0.000020 hi def link javaScriptOperator		Operator
    3              0.000018 hi def link javaScriptType			Type
    3              0.000017 hi def link javaScriptStatement		Statement
    3              0.000016 hi def link javaScriptFunction		Function
    3              0.000016 hi def link javaScriptBraces		Function
    3              0.000034 hi def link javaScriptError		Error
    3              0.000013 hi def link javaScrParenError		javaScriptError
    3              0.000016 hi def link javaScriptNull			Keyword
    3              0.000016 hi def link javaScriptBoolean		Boolean
    3              0.000017 hi def link javaScriptRegexpString		String
                            
    3              0.000017 hi def link javaScriptIdentifier		Identifier
    3              0.000016 hi def link javaScriptLabel		Label
    3              0.000016 hi def link javaScriptException		Exception
    3              0.000015 hi def link javaScriptMessage		Keyword
    3              0.000015 hi def link javaScriptGlobal		Keyword
    3              0.000028 hi def link javaScriptMember		Keyword
    3              0.000020 hi def link javaScriptDeprecated		Exception 
    3              0.000020 hi def link javaScriptReserved		Keyword
    3              0.000026 hi def link javaScriptDebug		Debug
    3              0.000066 hi def link javaScriptConstant		Label
    3              0.000022 hi def link javaScriptEmbed		Special
                            
                            
                            
    3              0.000015 let b:current_syntax = "javascript"
    3              0.000011 if main_syntax == 'javascript'
                              unlet main_syntax
                            endif
    3              0.000035 let &cpo = s:cpo_save
    3              0.000007 unlet s:cpo_save
                            
                            " vim: ts=8

SCRIPT  /usr/local/Cellar/neovim/HEAD-c6cd608/share/nvim/runtime/syntax/vb.vim
Sourced 3 times
Total time:   0.012772
 Self time:   0.012772

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:	Visual Basic
                            " Maintainer:	Tim Chase <vb.vim@tim.thechases.com>
                            " Former Maintainer:	Robert M. Cortopassi <cortopar@mindspring.com>
                            "	(tried multiple times to contact, but email bounced)
                            " Last Change:
                            "   2005 May 25  Synched with work by Thomas Barthel
                            "   2004 May 30  Added a few keywords
                            
                            " This was thrown together after seeing numerous requests on the
                            " VIM and VIM-DEV mailing lists.  It is by no means complete.
                            " Send comments, suggestions and requests to the maintainer.
                            
                            " quit when a syntax file was already loaded
    3              0.000023 if exists("b:current_syntax")
                            	finish
                            endif
                            
                            " VB is case insensitive
    3              0.000006 syn case ignore
                            
    3              0.000054 syn keyword vbConditional If Then ElseIf Else Select Case
                            
    3              0.000037 syn keyword vbOperator AddressOf And ByRef ByVal Eqv Imp In
    3              0.000014 syn keyword vbOperator Is Like Mod Not Or To Xor
                            
    3              0.000029 syn match vbOperator "[()+.,\-/*=&]"
    3              0.000013 syn match vbOperator "[<>]=\="
    3              0.000010 syn match vbOperator "<>"
    3              0.000012 syn match vbOperator "\s\+_$"
                            
    3              0.000022 syn keyword vbBoolean  True False
    3              0.000019 syn keyword vbConst Null Nothing
                            
    3              0.000060 syn keyword vbRepeat Do For ForEach Loop Next
    3              0.000013 syn keyword vbRepeat Step To Until Wend While
                            
    3              0.000020 syn keyword vbEvents AccessKeyPress Activate ActiveRowChanged
    3              0.000011 syn keyword vbEvents AfterAddFile AfterChangeFileName AfterCloseFile
    3              0.000009 syn keyword vbEvents AfterColEdit AfterColUpdate AfterDelete
    3              0.000010 syn keyword vbEvents AfterInsert AfterLabelEdit AfterRemoveFile
    3              0.000009 syn keyword vbEvents AfterUpdate AfterWriteFile AmbientChanged
    3              0.000053 syn keyword vbEvents ApplyChanges Associate AsyncProgress
    3              0.000010 syn keyword vbEvents AsyncReadComplete AsyncReadProgress AxisActivated
    3              0.000008 syn keyword vbEvents AxisLabelActivated AxisLabelSelected
    3              0.000009 syn keyword vbEvents AxisLabelUpdated AxisSelected AxisTitleActivated
    3              0.000009 syn keyword vbEvents AxisTitleSelected AxisTitleUpdated AxisUpdated
    3              0.000009 syn keyword vbEvents BeforeClick BeforeColEdit BeforeColUpdate
    3              0.000009 syn keyword vbEvents BeforeConnect BeforeDelete BeforeInsert
    3              0.000009 syn keyword vbEvents BeforeLabelEdit BeforeLoadFile BeforeUpdate
    3              0.000009 syn keyword vbEvents BeginRequest BeginTrans ButtonClick
    3              0.000009 syn keyword vbEvents ButtonCompleted ButtonDropDown ButtonGotFocus
    3              0.000011 syn keyword vbEvents ButtonLostFocus CallbackKeyDown Change Changed
    3              0.000011 syn keyword vbEvents ChartActivated ChartSelected ChartUpdated Click
    3              0.000013 syn keyword vbEvents Close CloseQuery CloseUp ColEdit ColResize
    3              0.000011 syn keyword vbEvents Collapse ColumnClick CommitTrans Compare
    3              0.000009 syn keyword vbEvents ConfigChageCancelled ConfigChanged
    3              0.000011 syn keyword vbEvents ConfigChangedCancelled Connect ConnectionRequest
    3              0.000009 syn keyword vbEvents CurrentRecordChanged DECommandAdded
    3              0.000009 syn keyword vbEvents DECommandPropertyChanged DECommandRemoved
    3              0.000009 syn keyword vbEvents DEConnectionAdded DEConnectionPropertyChanged
    3              0.000009 syn keyword vbEvents DEConnectionRemoved DataArrival DataChanged
    3              0.000010 syn keyword vbEvents DataUpdated DateClicked DblClick Deactivate
    3              0.000009 syn keyword vbEvents DevModeChange DeviceArrival DeviceOtherEvent
    3              0.000009 syn keyword vbEvents DeviceQueryRemove DeviceQueryRemoveFailed
    3              0.000008 syn keyword vbEvents DeviceRemoveComplete DeviceRemovePending
    3              0.000045 syn keyword vbEvents Disconnect DisplayChanged Dissociate
    3              0.000011 syn keyword vbEvents DoGetNewFileName Done DonePainting DownClick
    3              0.000011 syn keyword vbEvents DragDrop DragOver DropDown EditProperty EditQuery
    3              0.000012 syn keyword vbEvents EndRequest EnterCell EnterFocus ExitFocus Expand
    3              0.000010 syn keyword vbEvents FontChanged FootnoteActivated FootnoteSelected
    3              0.000011 syn keyword vbEvents FootnoteUpdated Format FormatSize GotFocus
    3              0.000010 syn keyword vbEvents HeadClick HeightChanged Hide InfoMessage
    3              0.000009 syn keyword vbEvents IniProperties InitProperties Initialize
    3              0.000026 syn keyword vbEvents ItemActivated ItemAdded ItemCheck ItemClick
    3              0.000009 syn keyword vbEvents ItemReloaded ItemRemoved ItemRenamed
    3              0.000011 syn keyword vbEvents ItemSeletected KeyDown KeyPress KeyUp LeaveCell
    3              0.000008 syn keyword vbEvents LegendActivated LegendSelected LegendUpdated
    3              0.000009 syn keyword vbEvents LinkClose LinkError LinkExecute LinkNotify
    3              0.000010 syn keyword vbEvents LinkOpen Load LostFocus MouseDown MouseMove
    3              0.000010 syn keyword vbEvents MouseUp NodeCheck NodeClick OLECompleteDrag
    3              0.000011 syn keyword vbEvents OLEDragDrop OLEDragOver OLEGiveFeedback OLESetData
    3              0.000496 syn keyword vbEvents OLEStartDrag ObjectEvent ObjectMove OnAddNew
    3              0.000014 syn keyword vbEvents OnComm Paint PanelClick PanelDblClick PathChange
    3              0.000010 syn keyword vbEvents PatternChange PlotActivated PlotSelected
    3              0.000044 syn keyword vbEvents PlotUpdated PointActivated PointLabelActivated
    3              0.000014 syn keyword vbEvents PointLabelSelected PointLabelUpdated PointSelected
    3              0.000013 syn keyword vbEvents PointUpdated PowerQuerySuspend PowerResume
    3              0.000013 syn keyword vbEvents PowerStatusChanged PowerSuspend ProcessTag
    3              0.000055 syn keyword vbEvents ProcessingTimeout QueryChangeConfig QueryClose
    3              0.000019 syn keyword vbEvents QueryComplete QueryCompleted QueryTimeout
    3              0.000067 syn keyword vbEvents QueryUnload ReadProperties RepeatedControlLoaded
    3              0.000013 syn keyword vbEvents RepeatedControlUnloaded Reposition
    3              0.000010 syn keyword vbEvents RequestChangeFileName RequestWriteFile Resize
    3              0.000009 syn keyword vbEvents ResultsChanged RetainedProject RollbackTrans
    3              0.000009 syn keyword vbEvents RowColChange RowCurrencyChange RowResize
    3              0.000012 syn keyword vbEvents RowStatusChanged Scroll SelChange SelectionChanged
    3              0.000010 syn keyword vbEvents SendComplete SendProgress SeriesActivated
    3              0.000061 syn keyword vbEvents SeriesSelected SeriesUpdated SettingChanged Show
    3              0.000011 syn keyword vbEvents SplitChange Start StateChanged StatusUpdate
    3              0.000011 syn keyword vbEvents SysColorsChanged Terminate TimeChanged Timer
    3              0.000009 syn keyword vbEvents TitleActivated TitleSelected TitleUpdated
    3              0.000008 syn keyword vbEvents UnboundAddData UnboundDeleteRow
    3              0.000008 syn keyword vbEvents UnboundGetRelativeBookmark UnboundReadData
    3              0.000016 syn keyword vbEvents UnboundWriteData Unformat Unload UpClick Updated
    3              0.000009 syn keyword vbEvents UserEvent Validate ValidationError
    3              0.000050 syn keyword vbEvents VisibleRecordChanged WillAssociate WillChangeData
    3              0.000012 syn keyword vbEvents WillDissociate WillExecute WillUpdateRows
    3              0.000007 syn keyword vbEvents WriteProperties
                            
                            
    3              0.000031 syn keyword vbFunction Abs Array Asc AscB AscW Atn Avg BOF CBool CByte
    3              0.000016 syn keyword vbFunction CCur CDate CDbl CInt CLng CSng CStr CVDate CVErr
    3              0.000015 syn keyword vbFunction CVar CallByName Cdec Choose Chr ChrB ChrW Command
    3              0.000015 syn keyword vbFunction Cos Count CreateObject CurDir DDB Date DateAdd
    3              0.000013 syn keyword vbFunction DateDiff DatePart DateSerial DateValue Day Dir
    3              0.000024 syn keyword vbFunction DoEvents EOF Environ Error Exp FV FileAttr
    3              0.000018 syn keyword vbFunction FileDateTime FileLen FilterFix Fix Format
    3              0.000010 syn keyword vbFunction FormatCurrency FormatDateTime FormatNumber
    3              0.000011 syn keyword vbFunction FormatPercent FreeFile GetAllStrings GetAttr
    3              0.000011 syn keyword vbFunction GetAutoServerSettings GetObject GetSetting Hex
    3              0.000012 syn keyword vbFunction Hour IIf IMEStatus IPmt InStr Input InputB
    3              0.000012 syn keyword vbFunction InputBox InstrB Int IsArray IsDate IsEmpty IsError
    3              0.000011 syn keyword vbFunction IsMissing IsNull IsNumeric IsObject Join LBound
    3              0.000237 syn keyword vbFunction LCase LOF LTrim Left LeftB Len LenB LoadPicture
    3              0.000194 syn keyword vbFunction LoadResData LoadResPicture LoadResString Loc Log
    3              0.000226 syn keyword vbFunction MIRR Max Mid MidB Min Minute Month MonthName
    3              0.000338 syn keyword vbFunction MsgBox NPV NPer Now Oct PPmt PV Partition Pmt
    3              0.000291 syn keyword vbFunction QBColor RGB RTrim Rate Replace Right RightB Rnd
    3              0.000373 syn keyword vbFunction Round SLN SYD Second Seek Sgn Shell Sin Space Spc
    3              0.000322 syn keyword vbFunction Split Sqr StDev StDevP Str StrComp StrConv
    3              0.000154 syn keyword vbFunction StrReverse String Sum Switch Tab Tan Time
    3              0.000187 syn keyword vbFunction TimeSerial TimeValue Timer Trim TypeName UBound
    3              0.000226 syn keyword vbFunction UCase Val Var VarP VarType Weekday WeekdayName
    3              0.000044 syn keyword vbFunction Year
                            
    3              0.000166 syn keyword vbMethods AboutBox Accept Activate Add AddCustom AddFile
    3              0.000119 syn keyword vbMethods AddFromFile AddFromGuid AddFromString
    3              0.000198 syn keyword vbMethods AddFromTemplate AddItem AddNew AddToAddInToolbar
    3              0.000117 syn keyword vbMethods AddToolboxProgID Append AppendAppendChunk
    3              0.000187 syn keyword vbMethods AppendChunk Arrange Assert AsyncRead BatchUpdate
    3              0.000117 syn keyword vbMethods BeginQueryEdit BeginTrans Bind BuildPath
    3              0.000125 syn keyword vbMethods CanPropertyChange Cancel CancelAsyncRead
    3              0.000156 syn keyword vbMethods CancelBatch CancelUpdate CaptureImage CellText
    3              0.000173 syn keyword vbMethods CellValue Circle Clear ClearFields ClearSel
    3              0.000181 syn keyword vbMethods ClearSelCols ClearStructure Clone Close Cls
    3              0.000142 syn keyword vbMethods ColContaining CollapseAll ColumnSize CommitTrans
    3              0.000259 syn keyword vbMethods CompactDatabase Compose Connect Copy CopyFile
    3              0.000143 syn keyword vbMethods CopyFolder CopyQueryDef Count CreateDatabase
    3              0.000140 syn keyword vbMethods CreateDragImage CreateEmbed CreateField
    3              0.000184 syn keyword vbMethods CreateFolder CreateGroup CreateIndex CreateLink
    3              0.000141 syn keyword vbMethods CreatePreparedStatement CreatePropery CreateQuery
    3              0.000140 syn keyword vbMethods CreateQueryDef CreateRelation CreateTableDef
    3              0.000140 syn keyword vbMethods CreateTextFile CreateToolWindow CreateUser
    3              0.000142 syn keyword vbMethods CreateWorkspace Customize Cut Delete
    3              0.000142 syn keyword vbMethods DeleteColumnLabels DeleteColumns DeleteFile
    3              0.000142 syn keyword vbMethods DeleteFolder DeleteLines DeleteRowLabels
    3              0.000016 syn keyword vbMethods DeleteRows DeselectAll DesignerWindow DoVerb Drag
    3              0.000013 syn keyword vbMethods Draw DriveExists Edit EditCopy EditPaste EndDoc
    3              0.000011 syn keyword vbMethods EnsureVisible EstablishConnection Execute Exists
    3              0.000012 syn keyword vbMethods Expand Export ExportReport ExtractIcon Fetch
    3              0.000011 syn keyword vbMethods FetchVerbs FileExists Files FillCache Find
    3              0.000146 syn keyword vbMethods FindFirst FindItem FindLast FindNext FindPrevious
    3              0.000015 syn keyword vbMethods FolderExists Forward GetAbsolutePathName
    3              0.000014 syn keyword vbMethods GetBaseName GetBookmark GetChunk GetClipString
    3              0.000014 syn keyword vbMethods GetData GetDrive GetDriveName GetFile GetFileName
    3              0.000013 syn keyword vbMethods GetFirstVisible GetFolder GetFormat GetHeader
    3              0.000012 syn keyword vbMethods GetLineFromChar GetNumTicks GetParentFolderName
    3              0.000011 syn keyword vbMethods GetRows GetSelectedPart GetSelection
    3              0.000012 syn keyword vbMethods GetSpecialFolder GetTempName GetText
    3              0.000079 syn keyword vbMethods GetVisibleCount GoBack GoForward Hide HitTest
    3              0.000017 syn keyword vbMethods HoldFields Idle Import InitializeLabels Insert
    3              0.000014 syn keyword vbMethods InsertColumnLabels InsertColumns InsertFile
    3              0.000013 syn keyword vbMethods InsertLines InsertObjDlg InsertRowLabels
    3              0.000018 syn keyword vbMethods InsertRows Item Keys KillDoc Layout Line Lines
    3              0.000016 syn keyword vbMethods LinkExecute LinkPoke LinkRequest LinkSend Listen
    3              0.000015 syn keyword vbMethods LoadFile LoadResData LoadResPicture LoadResString
    3              0.000013 syn keyword vbMethods LogEvent MakeCompileFile MakeCompiledFile
    3              0.000015 syn keyword vbMethods MakeReplica MoreResults Move MoveData MoveFile
    3              0.000014 syn keyword vbMethods MoveFirst MoveFolder MoveLast MoveNext
    3              0.000015 syn keyword vbMethods MovePrevious NavigateTo NewPage NewPassword
    3              0.000015 syn keyword vbMethods NextRecordset OLEDrag OnAddinsUpdate OnConnection
    3              0.000014 syn keyword vbMethods OnDisconnection OnStartupComplete Open
    3              0.000014 syn keyword vbMethods OpenAsTextStream OpenConnection OpenDatabase
    3              0.000015 syn keyword vbMethods OpenQueryDef OpenRecordset OpenResultset OpenURL
    3              0.000016 syn keyword vbMethods Overlay PSet PaintPicture PastSpecialDlg Paste
    3              0.000015 syn keyword vbMethods PeekData Play Point PopulatePartial PopupMenu
    3              0.000016 syn keyword vbMethods Print PrintForm PrintReport PropertyChanged Quit
    3              0.000013 syn keyword vbMethods Raise RandomDataFill RandomFillColumns
    3              0.000015 syn keyword vbMethods RandomFillRows ReFill Read ReadAll ReadFromFile
    3              0.000015 syn keyword vbMethods ReadLine ReadProperty Rebind Refresh RefreshLink
    3              0.000014 syn keyword vbMethods RegisterDatabase ReleaseInstance Reload Remove
    3              0.000049 syn keyword vbMethods RemoveAddInFromToolbar RemoveAll RemoveItem Render
    3              0.000164 syn keyword vbMethods RepairDatabase ReplaceLine Reply ReplyAll Requery
    3              0.000068 syn keyword vbMethods ResetCustom ResetCustomLabel ResolveName
    3              0.000016 syn keyword vbMethods RestoreToolbar Resync Rollback RollbackTrans
    3              0.000016 syn keyword vbMethods RowBookmark RowContaining RowTop Save SaveAs
    3              0.000015 syn keyword vbMethods SaveFile SaveToFile SaveToOle1File SaveToolbar
    3              0.000017 syn keyword vbMethods Scale ScaleX ScaleY Scroll SelPrint SelectAll
    3              0.000016 syn keyword vbMethods SelectPart Send SendData Set SetAutoServerSettings
    3              0.000017 syn keyword vbMethods SetData SetFocus SetOption SetSelection SetSize
    3              0.000015 syn keyword vbMethods SetText SetViewport Show ShowColor ShowFont
    3              0.000164 syn keyword vbMethods ShowHelp ShowOpen ShowPrinter ShowSave
    3              0.000019 syn keyword vbMethods ShowWhatsThis SignOff SignOn Size Skip SkipLine
    3              0.000016 syn keyword vbMethods Span Split SplitContaining StartLabelEdit
    3              0.000017 syn keyword vbMethods StartLogging Stop Synchronize Tag TextHeight
    3              0.000015 syn keyword vbMethods TextWidth ToDefaults Trace TwipsToChartPart
    3              0.000015 syn keyword vbMethods TypeByChartType URLFor Update UpdateControls
    3              0.000045 syn keyword vbMethods UpdateRecord UpdateRow Upto ValidateControls Value
    3              0.000015 syn keyword vbMethods WhatsThisMode Write WriteBlankLines WriteLine
    3              0.000013 syn keyword vbMethods WriteProperty WriteTemplate ZOrder
    3              0.000013 syn keyword vbMethods rdoCreateEnvironment rdoRegisterDataSource
                            
    3              0.000044 syn keyword vbStatement Alias AppActivate As Base Beep Begin Call ChDir
    3              0.000021 syn keyword vbStatement ChDrive Close Const Date Declare DefBool DefByte
    3              0.000017 syn keyword vbStatement DefCur DefDate DefDbl DefDec DefInt DefLng DefObj
    3              0.000017 syn keyword vbStatement DefSng DefStr DefVar Deftype DeleteSetting Dim Do
    3              0.000018 syn keyword vbStatement Each ElseIf End Enum Erase Error Event Exit
    3              0.000017 syn keyword vbStatement Explicit FileCopy For ForEach Function Get GoSub
    3              0.000022 syn keyword vbStatement GoTo Gosub Implements Kill LSet Let Lib LineInput
    3              0.000020 syn keyword vbStatement Load Lock Loop Mid MkDir Name Next On OnError Open
    3              0.000016 syn keyword vbStatement Option Preserve Private Property Public Put RSet
    3              0.000014 syn keyword vbStatement RaiseEvent Randomize ReDim Redim Reset Resume
    3              0.000015 syn keyword vbStatement Return RmDir SavePicture SaveSetting Seek SendKeys
    3              0.000018 syn keyword vbStatement Sendkeys Set SetAttr Static Step Stop Sub Time
    3              0.000017 syn keyword vbStatement Type Unload Unlock Until Wend While Width With
    3              0.000048 syn keyword vbStatement Write
                            
    3              0.000037 syn keyword vbKeyword As Binary ByRef ByVal Date Empty Error Friend Get
    3              0.000022 syn keyword vbKeyword Input Is Len Lock Me Mid New Nothing Null On
    3              0.000137 syn keyword vbKeyword Option Optional ParamArray Print Private Property
    3              0.000017 syn keyword vbKeyword Public PublicNotCreateable OnNewProcessSingleUse
    3              0.000017 syn keyword vbKeyword InSameProcessMultiUse GlobalMultiUse Resume Seek
    3              0.000029 syn keyword vbKeyword Set Static Step String Time WithEvents
                            
    3              0.000045 syn keyword vbTodo contained	TODO
                            
                            "Datatypes
    3              0.000042 syn keyword vbTypes Boolean Byte Currency Date Decimal Double Empty
    3              0.000023 syn keyword vbTypes Integer Long Object Single String Variant
                            
                            "VB defined values
    3              0.000039 syn keyword vbDefine dbBigInt dbBinary dbBoolean dbByte dbChar
    3              0.000021 syn keyword vbDefine dbCurrency dbDate dbDecimal dbDouble dbFloat
    3              0.000020 syn keyword vbDefine dbGUID dbInteger dbLong dbLongBinary dbMemo
    3              0.000019 syn keyword vbDefine dbNumeric dbSingle dbText dbTime dbTimeStamp
    3              0.000013 syn keyword vbDefine dbVarBinary
                            
                            "VB defined values
    3              0.000017 syn keyword vbDefine vb3DDKShadow vb3DFace vb3DHighlight vb3DLight
    3              0.000016 syn keyword vbDefine vb3DShadow vbAbort vbAbortRetryIgnore
    3              0.000016 syn keyword vbDefine vbActiveBorder vbActiveTitleBar vbAlias
    3              0.000033 syn keyword vbDefine vbApplicationModal vbApplicationWorkspace
    3              0.000023 syn keyword vbDefine vbAppTaskManager vbAppWindows vbArchive vbArray
    3              0.000021 syn keyword vbDefine vbBack vbBinaryCompare vbBlack vbBlue vbBoolean
    3              0.000017 syn keyword vbDefine vbButtonFace vbButtonShadow vbButtonText vbByte
    3              0.000018 syn keyword vbDefine vbCalGreg vbCalHijri vbCancel vbCr vbCritical
    3              0.000018 syn keyword vbDefine vbCrLf vbCurrency vbCyan vbDatabaseCompare
    3              0.000110 syn keyword vbDefine vbDataObject vbDate vbDecimal vbDefaultButton1
    3              0.000020 syn keyword vbDefine vbDefaultButton2 vbDefaultButton3 vbDefaultButton4
    3              0.000016 syn keyword vbDefine vbDesktop vbDirectory vbDouble vbEmpty vbError
    3              0.000013 syn keyword vbDefine vbExclamation vbFirstFourDays vbFirstFullWeek
    3              0.000013 syn keyword vbDefine vbFirstJan1 vbFormCode vbFormControlMenu
    3              0.000014 syn keyword vbDefine vbFormFeed vbFormMDIForm vbFriday vbFromUnicode
    3              0.000015 syn keyword vbDefine vbGrayText vbGreen vbHidden vbHide vbHighlight
    3              0.000014 syn keyword vbDefine vbHighlightText vbHiragana vbIgnore vbIMEAlphaDbl
    3              0.000062 syn keyword vbDefine vbIMEAlphaSng vbIMEDisable vbIMEHiragana
    3              0.000014 syn keyword vbDefine vbIMEKatakanaDbl vbIMEKatakanaSng vbIMEModeAlpha
    3              0.000024 syn keyword vbDefine vbIMEModeAlphaFull vbIMEModeDisable
    3              0.000010 syn keyword vbDefine vbIMEModeHangul vbIMEModeHangulFull
    3              0.000009 syn keyword vbDefine vbIMEModeHiragana vbIMEModeKatakana
    3              0.000011 syn keyword vbDefine vbIMEModeKatakanaHalf vbIMEModeNoControl
    3              0.000012 syn keyword vbDefine vbIMEModeOff vbIMEModeOn vbIMENoOp vbIMEOff
    3              0.000011 syn keyword vbDefine vbIMEOn vbInactiveBorder vbInactiveCaptionText
    3              0.000012 syn keyword vbDefine vbInactiveTitleBar vbInfoBackground vbInformation
    3              0.000013 syn keyword vbDefine vbInfoText vbInteger vbKatakana vbKey0 vbKey1
    3              0.000014 syn keyword vbDefine vbKey2 vbKey3 vbKey4 vbKey5 vbKey6 vbKey7 vbKey8
    3              0.000013 syn keyword vbDefine vbKey9 vbKeyA vbKeyAdd vbKeyB vbKeyBack vbKeyC
    3              0.000034 syn keyword vbDefine vbKeyCancel vbKeyCapital vbKeyClear vbKeyControl
    3              0.000012 syn keyword vbDefine vbKeyD vbKeyDecimal vbKeyDelete vbKeyDivide
    3              0.000013 syn keyword vbDefine vbKeyDown vbKeyE vbKeyEnd vbKeyEscape vbKeyExecute
    3              0.000014 syn keyword vbDefine vbKeyF vbKeyF1 vbKeyF10 vbKeyF11 vbKeyF12 vbKeyF13
    3              0.000014 syn keyword vbDefine vbKeyF14 vbKeyF15 vbKeyF16 vbKeyF2 vbKeyF3 vbKeyF4
    3              0.000013 syn keyword vbDefine vbKeyF5 vbKeyF6 vbKeyF7 vbKeyF8 vbKeyF9 vbKeyG
    3              0.000013 syn keyword vbDefine vbKeyH vbKeyHelp vbKeyHome vbKeyI vbKeyInsert
    3              0.000029 syn keyword vbDefine vbKeyJ vbKeyK vbKeyL vbKeyLButton vbKeyLeft vbKeyM
    3              0.000012 syn keyword vbDefine vbKeyMButton vbKeyMenu vbKeyMultiply vbKeyN
    3              0.000010 syn keyword vbDefine vbKeyNumlock vbKeyNumpad0 vbKeyNumpad1
    3              0.000010 syn keyword vbDefine vbKeyNumpad2 vbKeyNumpad3 vbKeyNumpad4
    3              0.000009 syn keyword vbDefine vbKeyNumpad5 vbKeyNumpad6 vbKeyNumpad7
    3              0.000082 syn keyword vbDefine vbKeyNumpad8 vbKeyNumpad9 vbKeyO vbKeyP
    3              0.000013 syn keyword vbDefine vbKeyPageDown vbKeyPageUp vbKeyPause vbKeyPrint
    3              0.000013 syn keyword vbDefine vbKeyQ vbKeyR vbKeyRButton vbKeyReturn vbKeyRight
    3              0.000013 syn keyword vbDefine vbKeyS vbKeySelect vbKeySeparator vbKeyShift
    3              0.000010 syn keyword vbDefine vbKeySnapshot vbKeySpace vbKeySubtract vbKeyT
    3              0.000011 syn keyword vbDefine vbKeyTab vbKeyU vbKeyUp vbKeyV vbKeyW vbKeyX
    3              0.000012 syn keyword vbDefine vbKeyY vbKeyZ vbLf vbLong vbLowerCase vbMagenta
    3              0.000009 syn keyword vbDefine vbMaximizedFocus vbMenuBar vbMenuText
    3              0.000028 syn keyword vbDefine vbMinimizedFocus vbMinimizedNoFocus vbMonday
    3              0.000009 syn keyword vbDefine vbMsgBox vbMsgBoxHelpButton vbMsgBoxRight
    3              0.000009 syn keyword vbDefine vbMsgBoxRtlReading vbMsgBoxSetForeground
    3              0.000011 syn keyword vbDefine vbMsgBoxText vbNarrow vbNewLine vbNo vbNormal
    3              0.000010 syn keyword vbDefine vbNormalFocus vbNormalNoFocus vbNull vbNullChar
    3              0.000010 syn keyword vbDefine vbNullString vbObject vbObjectError vbOK
    3              0.000010 syn keyword vbDefine vbOKCancel vbOKOnly vbProperCase vbQuestion
    3              0.000011 syn keyword vbDefine vbReadOnly vbRed vbRetry vbRetryCancel vbSaturday
    3              0.000017 syn keyword vbDefine vbScrollBars vbSingle vbString vbSunday vbSystem
    3              0.000010 syn keyword vbDefine vbSystemModal vbTab vbTextCompare vbThursday
    3              0.000010 syn keyword vbDefine vbTitleBarText vbTuesday vbUnicode vbUpperCase
    3              0.000009 syn keyword vbDefine vbUseSystem vbUseSystemDayOfWeek vbVariant
    3              0.000010 syn keyword vbDefine vbVerticalTab vbVolume vbWednesday vbWhite vbWide
    3              0.000009 syn keyword vbDefine vbWindowBackground vbWindowFrame vbWindowText
    3              0.000010 syn keyword vbDefine vbYellow vbYes vbYesNo vbYesNoCancel
                            
                            "Numbers
                            "integer number, or floating point number without a dot.
    3              0.000039 syn match vbNumber "\<\d\+\>"
                            "floating point number, with dot
    3              0.000023 syn match vbNumber "\<\d\+\.\d*\>"
                            "floating point number, starting with a dot
    3              0.000011 syn match vbNumber "\.\d\+\>"
                            "syn match  vbNumber		"{[[:xdigit:]-]\+}\|&[hH][[:xdigit:]]\+&"
                            "syn match  vbNumber		":[[:xdigit:]]\+"
                            "syn match  vbNumber		"[-+]\=\<\d\+\>"
    3              0.000036 syn match  vbFloat		"[-+]\=\<\d\+[eE][\-+]\=\d\+"
    3              0.000024 syn match  vbFloat		"[-+]\=\<\d\+\.\d*\([eE][\-+]\=\d\+\)\="
    3              0.000017 syn match  vbFloat		"[-+]\=\<\.\d\+\([eE][\-+]\=\d\+\)\="
                            
                            " String and Character contstants
    3              0.000035 syn region  vbString		start=+"+  end=+"\|$+
    3              0.000061 syn region  vbComment		start="\(^\|\s\)REM\s" end="$" contains=vbTodo
    3              0.000028 syn region  vbComment		start="\(^\|\s\)\'"   end="$" contains=vbTodo
    3              0.000026 syn match   vbLineNumber	"^\d\+\(\s\|$\)"
    3              0.000029 syn match   vbTypeSpecifier  "[a-zA-Z0-9][\$%&!#]"ms=s+1
    3              0.000018 syn match   vbTypeSpecifier  "#[a-zA-Z0-9]"me=e-1
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    3              0.000063 hi def link vbBoolean		Boolean
    3              0.000030 hi def link vbLineNumber		Comment
    3              0.000026 hi def link vbComment		Comment
    3              0.000025 hi def link vbConditional	Conditional
    3              0.000024 hi def link vbConst			Constant
    3              0.000024 hi def link vbDefine			Constant
    3              0.000032 hi def link vbError			Error
    3              0.000026 hi def link vbFunction		Identifier
    3              0.000031 hi def link vbIdentifier		Identifier
    3              0.000026 hi def link vbNumber			Number
    3              0.000022 hi def link vbFloat			Float
    3              0.000018 hi def link vbMethods		PreProc
    3              0.000020 hi def link vbOperator		Operator
    3              0.000017 hi def link vbRepeat			Repeat
    3              0.000017 hi def link vbString			String
    3              0.000054 hi def link vbStatement		Statement
    3              0.000017 hi def link vbKeyword		Statement
    3              0.000016 hi def link vbEvents			Special
    3              0.000015 hi def link vbTodo			Todo
    3              0.000017 hi def link vbTypes			Type
    3              0.000017 hi def link vbTypeSpecifier	Type
                            
                            
    3              0.000057 let b:current_syntax = "vb"
                            
                            " vim: ts=8

SCRIPT  /usr/local/Cellar/neovim/HEAD-c6cd608/share/nvim/runtime/syntax/css.vim
Sourced 3 times
Total time:   0.149087
 Self time:   0.149087

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     Cascading Style Sheets
                            " Previous Contributor List:
                            "               Claudio Fleiner <claudio@fleiner.com> (Maintainer)
                            "               Yeti            (Add full CSS2, HTML4 support)
                            "               Nikolai Weibull (Add CSS2 support)
                            " URL:          https://github.com/JulesWang/css.vim
                            " Maintainer:   Jules Wang      <w.jq0722@gmail.com>
                            " Last Change:  2018 Feb. 27
                            "               cssClassName updated by Ryuichi Hayashida Jan 2016
                            
                            " quit when a syntax file was already loaded
    3              0.000026 if !exists("main_syntax")
                              if exists("b:current_syntax")
                                finish
                              endif
                              let main_syntax = 'css'
                            elseif exists("b:current_syntax") && b:current_syntax == "css"
                              finish
                            endif
                            
    3              0.000023 let s:cpo_save = &cpo
    3              0.000027 set cpo&vim
                            
    3              0.000005 syn case ignore
                            
                            " HTML4 tags
    3              0.000040 syn keyword cssTagName abbr address area a b base
    3              0.000015 syn keyword cssTagName bdo blockquote body br button
    3              0.000016 syn keyword cssTagName caption cite code col colgroup dd del
    3              0.000014 syn keyword cssTagName dfn div dl dt em fieldset form
    3              0.000029 syn keyword cssTagName h1 h2 h3 h4 h5 h6 head hr html img i
    3              0.000015 syn keyword cssTagName iframe input ins isindex kbd label legend li
    3              0.000013 syn keyword cssTagName link map menu meta noscript ol optgroup
    3              0.000014 syn keyword cssTagName option p param pre q s samp script small
    3              0.000012 syn keyword cssTagName span strong sub sup tbody td
    3              0.000034 syn keyword cssTagName textarea tfoot th thead title tr ul u var
    3              0.000018 syn keyword cssTagName object svg
    3              0.000031 syn match   cssTagName /\<select\>\|\<style\>\|\<table\>/
                            
                            " 34 HTML5 tags
    3              0.000019 syn keyword cssTagName article aside audio bdi canvas command data
    3              0.000037 syn keyword cssTagName datalist details dialog embed figcaption figure footer
    3              0.000019 syn keyword cssTagName header hgroup keygen main mark menuitem meter nav
    3              0.000015 syn keyword cssTagName output progress rt rp ruby section
    3              0.000015 syn keyword cssTagName source summary time track video wbr
                            
                            " Tags not supported in HTML5
                            " acronym applet basefont big center dir
                            " font frame frameset noframes strike tt
                            
    3              0.000015 syn match cssTagName "\*"
                            
                            " selectors
    3              0.000029 syn match cssSelectorOp "[,>+~]"
    3              0.000024 syn match cssSelectorOp2 "[~|^$*]\?=" contained
    3              0.000086 syn region cssAttributeSelector matchgroup=cssSelectorOp start="\[" end="]" contains=cssUnicodeEscape,cssSelectorOp2,cssStringQ,cssStringQQ
                            
                            " .class and #id
    3              0.000047 syn match cssClassName "\.-\=[A-Za-z_][A-Za-z0-9_-]*" contains=cssClassNameDot
    3              0.000016 syn match cssClassNameDot contained '\.'
                            
    3              0.000004 try
    3              0.000025 syn match cssIdentifier "#[A-Za-zÀ-ÿ_@][A-Za-zÀ-ÿ0-9_@-]*"
    3              0.000004 catch /^.*/
                            syn match cssIdentifier "#[A-Za-z_@][A-Za-z0-9_@-]*"
                            endtry
                            
                            " digits
    3              0.000044 syn match cssValueInteger contained "[-+]\=\d\+" contains=cssUnitDecorators
    3              0.000029 syn match cssValueNumber contained "[-+]\=\d\+\(\.\d*\)\=" contains=cssUnitDecorators
    3              0.000034 syn match cssValueLength contained "[-+]\=\d\+\(\.\d*\)\=\(mm\|cm\|in\|pt\|pc\|em\|ex\|px\|rem\|dpi\|dppx\|dpcm\)\>" contains=cssUnitDecorators
    3              0.000017 syn match cssValueLength contained "[-+]\=\d\+\(\.\d*\)\=%" contains=cssUnitDecorators
    3              0.000026 syn match cssValueAngle contained "[-+]\=\d\+\(\.\d*\)\=\(deg\|grad\|rad\)\>" contains=cssUnitDecorators
    3              0.000042 syn match cssValueTime contained "+\=\d\+\(\.\d*\)\=\(ms\|s\)\>" contains=cssUnitDecorators
    3              0.000033 syn match cssValueFrequency contained "+\=\d\+\(\.\d*\)\=\(Hz\|kHz\)\>" contains=cssUnitDecorators
                            
                            " The 16 basic color names
    3              0.000029 syn keyword cssColor contained aqua black blue fuchsia gray green lime maroon navy olive purple red silver teal yellow
                            
                            " 130 more color names
    3              0.000010 syn keyword cssColor contained aliceblue antiquewhite aquamarine azure
    3              0.000011 syn keyword cssColor contained beige bisque blanchedalmond blueviolet brown burlywood
    3              0.000015 syn keyword cssColor contained cadetblue chartreuse chocolate coral cornflowerblue cornsilk crimson cyan
    3              0.000019 syn match cssColor contained /\<dark\(blue\|cyan\|goldenrod\|gray\|green\|grey\|khaki\)\>/
    3              0.000020 syn match cssColor contained /\<dark\(magenta\|olivegreen\|orange\|orchid\|red\|salmon\|seagreen\)\>/
    3              0.000012 syn match cssColor contained /\<darkslate\(blue\|gray\|grey\)\>/
    3              0.000012 syn match cssColor contained /\<dark\(turquoise\|violet\)\>/
    3              0.000012 syn keyword cssColor contained deeppink deepskyblue dimgray dimgrey dodgerblue firebrick
    3              0.001205 syn keyword cssColor contained floralwhite forestgreen gainsboro ghostwhite gold
    3              0.000016 syn keyword cssColor contained goldenrod greenyellow grey honeydew hotpink
    3              0.000016 syn keyword cssColor contained indianred indigo ivory khaki lavender lavenderblush lawngreen
    3              0.000011 syn keyword cssColor contained lemonchiffon limegreen linen magenta
    3              0.000027 syn match cssColor contained /\<light\(blue\|coral\|cyan\|goldenrodyellow\|gray\|green\)\>/
    3              0.000020 syn match cssColor contained /\<light\(grey\|pink\|salmon\|seagreen\|skyblue\|yellow\)\>/
    3              0.000018 syn match cssColor contained /\<light\(slategray\|slategrey\|steelblue\)\>/
    3              0.000019 syn match cssColor contained /\<medium\(aquamarine\|blue\|orchid\|purple\|seagreen\)\>/
    3              0.000019 syn match cssColor contained /\<medium\(slateblue\|springgreen\|turquoise\|violetred\)\>/
    3              0.000014 syn keyword cssColor contained midnightblue mintcream mistyrose moccasin navajowhite
    3              0.000013 syn keyword cssColor contained oldlace olivedrab orange orangered orchid
    3              0.000023 syn match cssColor contained /\<pale\(goldenrod\|green\|turquoise\|violetred\)\>/
    3              0.000014 syn keyword cssColor contained papayawhip peachpuff peru pink plum powderblue
    3              0.000014 syn keyword cssColor contained rosybrown royalblue rebeccapurple saddlebrown salmon
    3              0.000014 syn keyword cssColor contained sandybrown seagreen seashell sienna skyblue slateblue
    3              0.000015 syn keyword cssColor contained slategray slategrey snow springgreen steelblue tan
    3              0.000013 syn keyword cssColor contained thistle tomato turquoise violet wheat
    3              0.000058 syn keyword cssColor contained whitesmoke yellowgreen
                            
                            " FIXME: These are actually case-insensitive too, but (a) specs recommend using
                            " mixed-case (b) it's hard to highlight the word `Background' correctly in
                            " all situations
    3              0.000006 syn case match
    3              0.000029 syn keyword cssColor contained ActiveBorder ActiveCaption AppWorkspace ButtonFace ButtonHighlight ButtonShadow ButtonText CaptionText GrayText Highlight HighlightText InactiveBorder InactiveCaption InactiveCaptionText InfoBackground InfoText Menu MenuText Scrollbar ThreeDDarkShadow ThreeDFace ThreeDHighlight ThreeDLightShadow ThreeDShadow Window WindowFrame WindowText Background
    3              0.000003 syn case ignore
                            
    3              0.000025 syn match cssImportant contained "!\s*important\>"
                            
    3              0.000012 syn match cssColor contained "\<transparent\>"
    3              0.000010 syn match cssColor contained "\<currentColor\>"
    3              0.000009 syn match cssColor contained "\<white\>"
    3              0.000019 syn match cssColor contained "#\x\{3,4\}\>" contains=cssUnitDecorators
    3              0.000075 syn match cssColor contained "#\x\{6\}\>" contains=cssUnitDecorators
    3              0.000016 syn match cssColor contained "#\x\{8\}\>" contains=cssUnitDecorators
                            
    3              0.000054 syn region cssURL contained matchgroup=cssFunctionName start="\<\(uri\|url\|local\|format\)\s*(" end=")" contains=cssStringQ,cssStringQQ oneline
    3              0.000063 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(rgb\|clip\|attr\|counter\|rect\|cubic-bezier\|steps\)\s*(" end=")" oneline  contains=cssValueInteger,cssValueNumber,cssValueLength,cssFunctionComma
    3              0.000103 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(rgba\|hsl\|hsla\|color-stop\|from\|to\)\s*(" end=")" oneline  contains=cssColor,cssValueInteger,cssValueNumber,cssValueLength,cssFunctionComma,cssFunction
    3              0.000067 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(linear-\|radial-\)\=\gradient\s*(" end=")" oneline  contains=cssColor,cssValueInteger,cssValueNumber,cssValueLength,cssFunction,cssGradientAttr,cssFunctionComma
    3              0.000063 syn region cssFunction contained matchgroup=cssFunctionName start="\<\(matrix\(3d\)\=\|scale\(3d\|X\|Y\|Z\)\=\|translate\(3d\|X\|Y\|Z\)\=\|skew\(X\|Y\)\=\|rotate\(3d\|X\|Y\|Z\)\=\|perspective\)\s*(" end=")" oneline contains=cssValueInteger,cssValueNumber,cssValueLength,cssValueAngle,cssFunctionComma
    3              0.000017 syn keyword cssGradientAttr contained top bottom left right cover center middle ellipse at
    3              0.000008 syn match cssFunctionComma contained ","
                            
                            " Common Prop and Attr
    3              0.000019 syn keyword cssCommonAttr contained auto none inherit all default normal
    3              0.000012 syn keyword cssCommonAttr contained top bottom center stretch hidden visible
                            "------------------------------------------------
                            " CSS Animations
                            " http://www.w3.org/TR/css3-animations/
    3              0.000051 syn match cssAnimationProp contained "\<animation\(-\(delay\|direction\|duration\|fill-mode\|name\|play-state\|timing-function\|iteration-count\)\)\=\>"
                            
                            " animation-direction attributes
    3              0.000017 syn keyword cssAnimationAttr contained alternate reverse
    3              0.000013 syn match cssAnimationAttr contained "\<alternate-reverse\>"
                            
                            " animation-fill-mode attributes
    3              0.000009 syn keyword cssAnimationAttr contained forwards backwards both
                            
                            " animation-play-state attributes
    3              0.000007 syn keyword cssAnimationAttr contained running paused
                            
                            " animation-iteration-count attributes
    3              0.000006 syn keyword cssAnimationAttr contained infinite
                            "------------------------------------------------
                            "  CSS Backgrounds and Borders Module Level 3
                            "  http://www.w3.org/TR/css3-background/
    3              0.000030 syn match cssBackgroundProp contained "\<background\(-\(attachment\|clip\|color\|image\|origin\|position\|repeat\|size\)\)\=\>"
                            " background-attachment attributes
    3              0.000015 syn keyword cssBackgroundAttr contained scroll fixed local
                            
                            " background-position attributes
    3              0.000010 syn keyword cssBackgroundAttr contained left center right top bottom
                            
                            " background-repeat attributes
    3              0.000012 syn match cssBackgroundAttr contained "\<no-repeat\>"
    3              0.000013 syn match cssBackgroundAttr contained "\<repeat\(-[xy]\)\=\>"
                            
                            " background-size attributes
    3              0.000007 syn keyword cssBackgroundAttr contained cover contain
                            
    3              0.000025 syn match cssBorderProp contained "\<border\(-\(top\|right\|bottom\|left\)\)\=\(-\(width\|color\|style\)\)\=\>"
    3              0.000144 syn match cssBorderProp contained "\<border\(-\(top\|bottom\)-\(left\|right\)\)\=-radius\>"
    3              0.000026 syn match cssBorderProp contained "\<border-image\(-\(outset\|repeat\|slice\|source\|width\)\)\=\>"
    3              0.000012 syn match cssBorderProp contained "\<box-decoration-break\>"
    3              0.000009 syn match cssBorderProp contained "\<box-shadow\>"
                            
                            " border-image attributes
    3              0.000021 syn keyword cssBorderAttr contained stretch round fill
                            
                            " border-style attributes
    3              0.000015 syn keyword cssBorderAttr contained dotted dashed solid double groove ridge inset outset
                            
                            " border-width attributes
    3              0.000009 syn keyword cssBorderAttr contained thin thick medium
                            
                            " box-decoration-break attributes
    3              0.000040 syn keyword cssBorderAttr contained clone slice
                            "------------------------------------------------
                            
    3              0.000025 syn match cssBoxProp contained "\<padding\(-\(top\|right\|bottom\|left\)\)\=\>"
    3              0.000014 syn match cssBoxProp contained "\<margin\(-\(top\|right\|bottom\|left\)\)\=\>"
    3              0.000011 syn match cssBoxProp contained "\<overflow\(-\(x\|y\|style\)\)\=\>"
    3              0.000022 syn match cssBoxProp contained "\<rotation\(-point\)\=\>"
    3              0.000017 syn keyword cssBoxAttr contained visible hidden scroll auto
    3              0.000012 syn match cssBoxAttr contained "\<no-\(display\|content\)\>"
                            
    3              0.000013 syn keyword cssColorProp contained opacity
    3              0.000024 syn match cssColorProp contained "\<color-profile\>"
    3              0.000010 syn match cssColorProp contained "\<rendering-intent\>"
                            
                            
    3              0.000019 syn match cssDimensionProp contained "\<\(min\|max\)-\(width\|height\)\>"
    3              0.000006 syn keyword cssDimensionProp contained height
    3              0.000029 syn keyword cssDimensionProp contained width
                            
                            " CSS Flexible Box Layout Module Level 1
                            " http://www.w3.org/TR/css3-flexbox/
                            " CSS Box Alignment Module Level 3
                            " http://www.w3.org/TR/css-align-3/
    3              0.000024 syn match cssFlexibleBoxProp contained "\<flex\(-\(direction\|wrap\|flow\|grow\|shrink\|basis\)\)\=\>"
    3              0.000015 syn match cssFlexibleBoxProp contained "\<\(align\|justify\)\(-\(items\|self\|content\)\)\=\>"
    3              0.000006 syn keyword cssFlexibleBoxProp contained order
                            
    3              0.000018 syn match cssFlexibleBoxAttr contained "\<\(row\|column\|wrap\)\(-reverse\)\=\>"
    3              0.000010 syn keyword cssFlexibleBoxAttr contained nowrap stretch baseline center
    3              0.000011 syn match cssFlexibleBoxAttr contained "\<flex\(-\(start\|end\)\)\=\>"
    3              0.000059 syn match cssFlexibleBoxAttr contained "\<space\(-\(between\|around\)\)\=\>"
                            
                            " CSS Fonts Module Level 3
                            " http://www.w3.org/TR/css-fonts-3/
    3              0.000059 syn match cssFontProp contained "\<font\(-\(family\|\|feature-settings\|kerning\|language-override\|size\(-adjust\)\=\|stretch\|style\|synthesis\|variant\(-\(alternates\|caps\|east-asian\|ligatures\|numeric\|position\)\)\=\|weight\)\)\=\>"
                            
                            " font attributes
    3              0.000019 syn keyword cssFontAttr contained icon menu caption
    3              0.000022 syn match cssFontAttr contained "\<message-box\>"
    3              0.000012 syn match cssFontAttr contained "\<status-bar\>"
    3              0.000009 syn keyword cssFontAttr contained larger smaller
    3              0.000018 syn match cssFontAttr contained "\<\(x\{1,2\}-\)\=\(large\|small\)\>"
    3              0.000014 syn match cssFontAttr contained "\<small-\(caps\|caption\)\>"
                            " font-family attributes
    3              0.000692 syn match cssFontAttr contained "\<\(sans-\)\=serif\>"
    3              0.000047 syn keyword cssFontAttr contained Antiqua Arial Black Book Charcoal Comic Courier Dingbats Gadget Geneva Georgia Grande Helvetica Impact Linotype Lucida MS Monaco Neue New Palatino Roboto Roman Symbol Tahoma Times Trebuchet Verdana Webdings Wingdings York Zapf
    3              0.000009 syn keyword cssFontAttr contained cursive fantasy monospace
                            " font-feature-settings attributes
    3              0.000008 syn keyword cssFontAttr contained on off
                            " font-stretch attributes
    3              0.000020 syn match cssFontAttr contained "\<\(\(ultra\|extra\|semi\)-\)\=\(condensed\|expanded\)\>"
                            " font-style attributes
    3              0.000007 syn keyword cssFontAttr contained italic oblique
                            " font-synthesis attributes
    3              0.000007 syn keyword cssFontAttr contained weight style
                            " font-weight attributes
    3              0.000007 syn keyword cssFontAttr contained bold bolder lighter
                            " TODO: font-variant-* attributes
                            "------------------------------------------------
                            
                            " Webkit specific property/attributes
    3              0.000015 syn match cssFontProp contained "\<font-smooth\>"
    3              0.000013 syn match cssFontAttr contained "\<\(subpixel-\)\=\antialiased\>"
                            
                            
                            " CSS Multi-column Layout Module
                            " http://www.w3.org/TR/css3-multicol/
    3              0.000048 syn match cssMultiColumnProp contained "\<break-\(after\|before\|inside\)\>"
    3              0.000033 syn match cssMultiColumnProp contained "\<column-\(count\|fill\|gap\|rule\(-\(color\|style\|width\)\)\=\|span\|width\)\>"
    3              0.000008 syn keyword cssMultiColumnProp contained columns
    3              0.000017 syn keyword cssMultiColumnAttr contained balance medium
    3              0.000011 syn keyword cssMultiColumnAttr contained always left right page column
    3              0.000013 syn match cssMultiColumnAttr contained "\<avoid\(-\(page\|column\)\)\=\>"
                            
                            " http://www.w3.org/TR/css3-break/#page-break
    3              0.000014 syn match cssMultiColumnProp contained "\<page\(-break-\(before\|after\|inside\)\)\=\>"
                            
                            " http://www.w3.org/TR/SVG11/interact.html
    3              0.000020 syn match cssInteractProp contained "\<pointer-events\>"
    3              0.000022 syn match cssInteractAttr contained "\<\(visible\)\=\(Painted\|Fill\|Stroke\)\=\>"
                            
                            " TODO find following items in w3c docs.
    3              0.000019 syn keyword cssGeneratedContentProp contained quotes crop
    3              0.000013 syn match cssGeneratedContentProp contained "\<counter-\(reset\|increment\)\>"
    3              0.000010 syn match cssGeneratedContentProp contained "\<move-to\>"
    3              0.000009 syn match cssGeneratedContentProp contained "\<page-policy\>"
    3              0.000020 syn match cssGeneratedContentAttr contained "\<\(no-\)\=\(open\|close\)-quote\>"
                            
                            " https://www.w3.org/TR/css-grid-1/
    3              0.000016 syn match cssGridProp contained "\<grid\>"
    3              0.000028 syn match cssGridProp contained "\<grid\(-\(template\|auto\)\)\=\(-\(columns\|rows\|areas\)\)\>"
    3              0.000016 syn match cssGridProp contained "\<grid-\(column\|row\)\(-\(start\|end\|gap\)\)\=\>"
    3              0.000011 syn match cssGridProp contained "\<grid-\(area\|gap\)\>"
    3              0.000010 syn match cssGridProp contained "\<grid-auto-flow\>"
                            
    3              0.000021 syn match cssHyerlinkProp contained "\<target\(-\(name\|new\|position\)\)\=\>"
                            
    3              0.000025 syn match cssListProp contained "\<list-style\(-\(type\|position\|image\)\)\=\>"
    3              0.000022 syn match cssListAttr contained "\<\(lower\|upper\)-\(roman\|alpha\|greek\|latin\)\>"
    3              0.000014 syn match cssListAttr contained "\<\(hiragana\|katakana\)\(-iroha\)\=\>"
    3              0.000015 syn match cssListAttr contained "\<\(decimal\(-leading-zero\)\=\|cjk-ideographic\)\>"
    3              0.000012 syn keyword cssListAttr contained disc circle square hebrew armenian georgian
    3              0.000007 syn keyword cssListAttr contained inside outside
                            
    3              0.000018 syn keyword cssPositioningProp contained bottom clear clip display float left
    3              0.000010 syn keyword cssPositioningProp contained position right top visibility
    3              0.000010 syn match cssPositioningProp contained "\<z-index\>"
    3              0.000015 syn keyword cssPositioningAttr contained block compact grid
    3              0.000023 syn match cssPositioningAttr contained "\<table\(-\(row-group\|\(header\|footer\)-group\|row\|column\(-group\)\=\|cell\|caption\)\)\=\>"
    3              0.000007 syn keyword cssPositioningAttr contained left right both
    3              0.000009 syn match cssPositioningAttr contained "\<list-item\>"
    3              0.000024 syn match cssPositioningAttr contained "\<inline\(-\(block\|box\|table\|grid\|flex\)\)\=\>"
    3              0.000011 syn keyword cssPositioningAttr contained static relative absolute fixed subgrid
                            
    3              0.000030 syn keyword cssPrintAttr contained landscape portrait crop cross always
                            
    3              0.000029 syn match cssTableProp contained "\<\(caption-side\|table-layout\|border-collapse\|border-spacing\|empty-cells\)\>"
    3              0.000019 syn keyword cssTableAttr contained fixed collapse separate show hide once always
                            
                            
    3              0.000028 syn keyword cssTextProp contained color direction
    3              0.000032 syn match cssTextProp "\<\(\(word\|letter\)-spacing\|text\(-\(decoration\|transform\|align\|index\|shadow\)\)\=\|vertical-align\|unicode-bidi\|line-height\)\>"
    3              0.000026 syn match cssTextProp contained "\<text-\(justify\|outline\|warp\|align-last\|size-adjust\|rendering\|stroke\|indent\)\>"
    3              0.000023 syn match cssTextProp contained "\<word-\(break\|\wrap\)\>"
    3              0.000016 syn match cssTextProp contained "\<white-space\>"
    3              0.000015 syn match cssTextProp contained "\<hanging-punctuation\>"
    3              0.000021 syn match cssTextProp contained "\<punctuation-trim\>"
    3              0.000026 syn match cssTextAttr contained "\<line-through\>"
    3              0.000045 syn match cssTextAttr contained "\<\(text-\)\=\(top\|bottom\)\>"
    3              0.000011 syn keyword cssTextAttr contained ltr rtl embed nowrap
    3              0.000012 syn keyword cssTextAttr contained underline overline blink sub super middle
    3              0.000009 syn keyword cssTextAttr contained capitalize uppercase lowercase
    3              0.000008 syn keyword cssTextAttr contained justify baseline sub super
    3              0.000008 syn keyword cssTextAttr contained optimizeLegibility optimizeSpeed
    3              0.000011 syn match cssTextAttr contained "\<pre\(-\(line\|wrap\)\)\=\>"
    3              0.000011 syn match cssTextAttr contained "\<\(allow\|force\)-end\>"
    3              0.000009 syn keyword cssTextAttr contained start end adjacent
    3              0.000020 syn match cssTextAttr contained "\<inter-\(word\|ideographic\|cluster\)\>"
    3              0.000009 syn keyword cssTextAttr contained distribute kashida first last
    3              0.000009 syn keyword cssTextAttr contained clip ellipsis unrestricted suppress
    3              0.000015 syn match cssTextAttr contained "\<break-all\>"
    3              0.000017 syn match cssTextAttr contained "\<break-word\>"
    3              0.000006 syn keyword cssTextAttr contained hyphenate
    3              0.000011 syn match cssTextAttr contained "\<bidi-override\>"
                            
    3              0.000071 syn match cssTransformProp contained "\<transform\(-\(origin\|style\)\)\=\>"
    3              0.000018 syn match cssTransformProp contained "\<perspective\(-origin\)\=\>"
    3              0.000120 syn match cssTransformProp contained "\<backface-visibility\>"
                            
                            " CSS Transitions
                            " http://www.w3.org/TR/css3-transitions/
    3              0.000040 syn match cssTransitionProp contained "\<transition\(-\(delay\|duration\|property\|timing-function\)\)\=\>"
                            
                            " transition-time-function attributes
    3              0.000020 syn match cssTransitionAttr contained "\<linear\(-gradient\)\@!\>"
    3              0.000013 syn match cssTransitionAttr contained "\<ease\(-\(in-out\|out\|in\)\)\=\>"
    3              0.000011 syn match cssTransitionAttr contained "\<step\(-start\|-end\)\=\>"
                            "------------------------------------------------
                            " CSS Basic User Interface Module Level 3 (CSS3 UI)
                            " http://www.w3.org/TR/css3-ui/
    3              0.000064 syn match cssUIProp contained "\<box-sizing\>"
    3              0.000029 syn match cssUIAttr contained "\<\(content\|padding\|border\)\(-box\)\=\>"
                            
    3              0.000009 syn keyword cssUIProp contained cursor
    3              0.000021 syn match cssUIAttr contained "\<\(\([ns]\=[ew]\=\)\|col\|row\|nesw\|nwse\)-resize\>"
    3              0.000014 syn keyword cssUIAttr contained crosshair help move pointer alias copy
    3              0.000010 syn keyword cssUIAttr contained progress wait text cell move
    3              0.000020 syn match cssUIAttr contained "\<context-menu\>"
    3              0.000009 syn match cssUIAttr contained "\<no-drop\>"
    3              0.000010 syn match cssUIAttr contained "\<not-allowed\>"
    3              0.000009 syn match cssUIAttr contained "\<all-scroll\>"
    3              0.000011 syn match cssUIAttr contained "\<\(vertical-\)\=text\>"
    3              0.000009 syn match cssUIAttr contained "\<zoom\(-in\|-out\)\=\>"
                            
    3              0.000039 syn match cssUIProp contained "\<ime-mode\>"
    3              0.000009 syn keyword cssUIAttr contained active inactive disabled
                            
    3              0.000032 syn match cssUIProp contained "\<nav-\(down\|index\|left\|right\|up\)\=\>"
    3              0.000014 syn match cssUIProp contained "\<outline\(-\(width\|style\|color\|offset\)\)\=\>"
    3              0.000006 syn keyword cssUIAttr contained invert
                            
    3              0.000006 syn keyword cssUIProp contained icon resize
    3              0.000008 syn keyword cssUIAttr contained both horizontal vertical
                            
    3              0.000009 syn match cssUIProp contained "\<text-overflow\>"
    3              0.000007 syn keyword cssUIAttr contained clip ellipsis
                            
    3              0.000025 syn match cssUIProp contained "\<image-rendering\>"
    3              0.000006 syn keyword cssUIAttr contained pixellated
    3              0.000009 syn match cssUIAttr contained "\<crisp-edges\>"
                            
                            "------------------------------------------------
                            " Webkit/iOS specific attributes
    3              0.000019 syn match cssUIAttr contained '\<preserve-3d\>'
                            " IE specific attributes
    3              0.001437 syn match cssIEUIAttr contained '\<bicubic\>'
                            
                            " Webkit/iOS specific properties
    3              0.000027 syn match cssUIProp contained '\<tap-highlight-color\|user-select\|touch-callout\>'
                            " IE specific properties
    3              0.000033 syn match cssIEUIProp contained '\<interpolation-mode\|zoom\|filter\>'
                            
                            " Webkit/Firebox specific properties/attributes
    3              0.000028 syn keyword cssUIProp contained appearance
    3              0.000012 syn keyword cssUIAttr contained window button field icon document menu
                            
                            
    3              0.000030 syn match cssAuralProp contained "\<\(pause\|cue\)\(-\(before\|after\)\)\=\>"
    3              0.000025 syn match cssAuralProp contained "\<\(play-during\|speech-rate\|voice-family\|pitch\(-range\)\=\|speak\(-\(punctuation\|numeral\|header\)\)\=\)\>"
    3              0.000059 syn keyword cssAuralProp contained volume during azimuth elevation stress richness
    3              0.000025 syn match cssAuralAttr contained "\<\(x-\)\=\(soft\|loud\)\>"
    3              0.000006 syn keyword cssAuralAttr contained silent
    3              0.000010 syn match cssAuralAttr contained "\<spell-out\>"
    3              0.000007 syn keyword cssAuralAttr contained non mix
    3              0.000011 syn match cssAuralAttr contained "\<\(left\|right\)-side\>"
    3              0.000018 syn match cssAuralAttr contained "\<\(far\|center\)-\(left\|center\|right\)\>"
    3              0.000008 syn keyword cssAuralAttr contained leftwards rightwards behind
    3              0.000010 syn keyword cssAuralAttr contained below level above lower higher
    3              0.000020 syn match cssAuralAttr contained "\<\(x-\)\=\(slow\|fast\|low\|high\)\>"
    3              0.000008 syn keyword cssAuralAttr contained faster slower
    3              0.000013 syn keyword cssAuralAttr contained male female child code digits continuous
                            
                            " mobile text
    3              0.000023 syn match cssMobileTextProp contained "\<text-size-adjust\>"
                            
    3              0.000034 syn keyword cssMediaProp contained width height orientation scan grid
    3              0.000017 syn match cssMediaProp contained /\(\(max\|min\)-\)\=\(\(device\)-\)\=aspect-ratio/
    3              0.000013 syn match cssMediaProp contained /\(\(max\|min\)-\)\=device-pixel-ratio/
    3              0.000013 syn match cssMediaProp contained /\(\(max\|min\)-\)\=device-\(height\|width\)/
    3              0.000021 syn match cssMediaProp contained /\(\(max\|min\)-\)\=\(height\|width\|resolution\|monochrome\|color\(-index\)\=\)/
    3              0.000019 syn keyword cssMediaAttr contained portrait landscape progressive interlace
    3              0.000036 syn match cssKeyFrameProp /\d*%\|from\|to/  contained nextgroup=cssDefinition
    3              0.000040 syn match cssPageMarginProp /@\(\(top\|left\|right\|bottom\)-\(left\|center\|right\|middle\|bottom\)\)\(-corner\)\=/ contained nextgroup=cssDefinition
    3              0.000016 syn keyword cssPageProp contained content size
    3              0.000007 syn keyword cssPageProp contained orphans widows
    3              0.000013 syn keyword cssFontDescriptorProp contained src
    3              0.000023 syn match cssFontDescriptorProp contained "\<unicode-range\>"
                            " unicode-range attributes
    3              0.000021 syn match cssFontDescriptorAttr contained "U+[0-9A-Fa-f?]\+"
    3              0.000021 syn match cssFontDescriptorAttr contained "U+\x\+-\x\+"
                            
    3              0.000093 syn match cssBraces contained "[{}]"
    3              0.000032 syn match cssError contained "{@<>"
    3              0.023560 syn region cssDefinition transparent matchgroup=cssBraces start='{' end='}' contains=cssTagName,cssAttributeSelector,cssClassName,cssIdentifier,cssAtRule,cssAttrRegion,css.*Prop,cssComment,cssValue.*,cssColor,cssURL,cssImportant,cssError,cssStringQ,cssStringQQ,cssFunction,cssUnicodeEscape,cssVendor,cssDefinition,cssHacks,cssNoise fold
    3              0.000056 syn match cssBraceError "}"
    3              0.000028 syn match cssAttrComma ","
                            
                            " Pseudo class
                            " http://www.w3.org/TR/css3-selectors/
    3              0.000070 syn match cssPseudoClass ":[A-Za-z0-9_-]*" contains=cssNoise,cssPseudoClassId,cssUnicodeEscape,cssVendor,cssPseudoClassFn
    3              0.000021 syn keyword cssPseudoClassId contained link visited active hover before after left right
    3              0.000016 syn keyword cssPseudoClassId contained root empty target enable disabled checked invalid
    3              0.000016 syn match cssPseudoClassId contained "\<first-\(line\|letter\)\>"
    3              0.000017 syn match cssPseudoClassId contained "\<\(first\|last\|only\)-\(of-type\|child\)\>"
    3              0.000037 syn region cssPseudoClassFn contained matchgroup=cssFunctionName start="\<\(not\|lang\|\(nth\|nth-last\)-\(of-type\|child\)\)(" end=")"
                            " ------------------------------------
                            " Vendor specific properties
    3              0.000018 syn match cssPseudoClassId contained  "\<selection\>"
    3              0.000021 syn match cssPseudoClassId contained  "\<focus\(-inner\)\=\>"
    3              0.000019 syn match cssPseudoClassId contained  "\<\(input-\)\=placeholder\>"
                            
                            " Misc highlight groups
    3              0.000031 syntax match cssUnitDecorators /\(#\|-\|+\|%\|mm\|cm\|in\|pt\|pc\|em\|ex\|px\|ch\|rem\|vh\|vw\|vmin\|vmax\|dpi\|dppx\|dpcm\|Hz\|kHz\|s\|ms\|deg\|grad\|rad\)/ contained
    3              0.000011 syntax match cssNoise contained /\(:\|;\|\/\)/
                            
                            " Comment
    3              0.000025 syn region cssComment start="/\*" end="\*/" contains=@Spell fold
                            
    3              0.000072 syn match cssUnicodeEscape "\\\x\{1,6}\s\?"
    3              0.000024 syn match cssSpecialCharQQ +\\\\\|\\"+ contained
    3              0.000022 syn match cssSpecialCharQ +\\\\\|\\'+ contained
    3              0.000068 syn region cssStringQQ start=+"+ skip=+\\\\\|\\"+ end=+"+ contains=cssUnicodeEscape,cssSpecialCharQQ
    3              0.000031 syn region cssStringQ start=+'+ skip=+\\\\\|\\'+ end=+'+ contains=cssUnicodeEscape,cssSpecialCharQ
                            
                            " Vendor Prefix
    3              0.000013 syn match cssVendor contained "-\(webkit\|moz\|o\|ms\)-"
                            
                            " Various CSS Hack characters
                            " In earlier versions of IE (6 and 7), one can prefix property names
                            " with a _ or * to isolate those definitions to particular versions of IE
                            " This is purely decorative and therefore we assign to the same highlight
                            " group to cssVendor, for more information:
                            " http://www.paulirish.com/2009/browser-specific-css-hacks/
    3              0.000009 syn match cssHacks contained /\(_\|*\)/
                            
                            " Attr Enhance
                            " Some keywords are both Prop and Attr, so we have to handle them
    3              0.031712 syn region cssAttrRegion start=/:/ end=/\ze\(;\|)\|}\)/ contained contains=css.*Attr,cssColor,cssImportant,cssValue.*,cssFunction,cssString.*,cssURL,cssComment,cssUnicodeEscape,cssVendor,cssError,cssAttrComma,cssNoise
                            
                            " Hack for transition
                            " 'transition' has Props after ':'.
    3              0.049785 syn region cssAttrRegion start=/transition\s*:/ end=/\ze\(;\|)\|}\)/ contained contains=css.*Prop,css.*Attr,cssColor,cssImportant,cssValue.*,cssFunction,cssString.*,cssURL,cssComment,cssUnicodeEscape,cssVendor,cssError,cssAttrComma,cssNoise
                            
    3              0.000086 syn match cssAtKeyword /@\(font-face\|media\|keyframes\|import\|charset\|namespace\|page\|supports\)/ contained
                            
    3              0.000053 syn keyword cssAtRuleLogical only not and contained
                            
                            " @media
                            " Reference: http://www.w3.org/TR/css3-mediaqueries/
    3              0.000095 syn region cssAtRule start=/@media\>/ end=/\ze{/ skipwhite skipnl matchgroup=cssAtKeyword contains=cssMediaProp,cssValueLength,cssAtRuleLogical,cssValueInteger,cssMediaAttr,cssVendor,cssMediaType,cssComment nextgroup=cssDefinition
    3              0.000024 syn keyword cssMediaType contained screen print aural braille embossed handheld projection tty tv speech all contained
                            
                            " @page
                            " http://www.w3.org/TR/css3-page/
    3              0.000065 syn region cssAtRule start=/@page\>/ end=/\ze{/ skipwhite skipnl matchgroup=cssAtKeyword contains=cssPagePseudo,cssComment nextgroup=cssDefinition
    3              0.000016 syn match cssPagePseudo /:\(left\|right\|first\|blank\)/ contained skipwhite skipnl
                            " @keyframe
                            " http://www.w3.org/TR/css3-animations/#keyframes
    3              0.000051 syn region cssAtRule start=/@\(-[a-z]\+-\)\=keyframes\>/ end=/\ze{/ skipwhite skipnl matchgroup=cssAtKeyword contains=cssVendor,cssComment nextgroup=cssDefinition
                            
    3              0.000077 syn region cssAtRule start=/@import\>/    end=/\ze;/ contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssAtKeyword,cssURL,cssMediaProp,cssValueLength,cssAtRuleLogical,cssValueInteger,cssMediaAttr,cssMediaType
    3              0.000043 syn region cssAtRule start=/@charset\>/   end=/\ze;/ contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssAtKeyword
    3              0.000041 syn region cssAtRule start=/@namespace\>/ end=/\ze;/ contains=cssStringQ,cssStringQQ,cssUnicodeEscape,cssComment,cssAtKeyword
                            
                            " @font-face
                            " http://www.w3.org/TR/css3-fonts/#at-font-face-rule
    3              0.000126 syn match cssAtRule "@font-face\>" nextgroup=cssFontDescriptorBlock
                            " @supports
                            " https://www.w3.org/TR/css3-conditional/#at-supports
    3              0.028161 syn region cssAtRule start=/@supports\>/ end=/\ze{/ skipwhite skipnl contains=cssAtRuleLogical,cssAttrRegion,css.*Prop,cssValue.*,cssVendor,cssAtKeyword,cssComment nextgroup=cssDefinition
                            
                            
    3              0.000038 if main_syntax == "css"
                              syn sync minlines=10
                            endif
                            
                            " Define the default highlighting.
                            " Only when an item doesn't have highlighting yet
                            
    3              0.000091 hi def link cssComment Comment
    3              0.000061 hi def link cssVendor Comment
    3              0.000057 hi def link cssHacks Comment
    3              0.000051 hi def link cssTagName Statement
    3              0.000062 hi def link cssDeprecated Error
    3              0.000046 hi def link cssSelectorOp Special
    3              0.000045 hi def link cssSelectorOp2 Special
    3              0.000038 hi def link cssAttrComma Special
                            
    3              0.000024 hi def link cssAnimationProp cssProp
    3              0.000064 hi def link cssBackgroundProp cssProp
    3              0.000033 hi def link cssBorderProp cssProp
    3              0.000011 hi def link cssBoxProp cssProp
    3              0.000009 hi def link cssColorProp cssProp
    3              0.000021 hi def link cssContentForPagedMediaProp cssProp
    3              0.000126 hi def link cssDimensionProp cssProp
    3              0.000010 hi def link cssFlexibleBoxProp cssProp
    3              0.000008 hi def link cssFontProp cssProp
    3              0.000009 hi def link cssGeneratedContentProp cssProp
    3              0.000010 hi def link cssGridProp cssProp
    3              0.000008 hi def link cssHyerlinkProp cssProp
    3              0.000008 hi def link cssInteractProp cssProp
    3              0.000019 hi def link cssLineboxProp cssProp
    3              0.000008 hi def link cssListProp cssProp
    3              0.000054 hi def link cssMarqueeProp cssProp
    3              0.000011 hi def link cssMultiColumnProp cssProp
    3              0.000017 hi def link cssPagedMediaProp cssProp
    3              0.000009 hi def link cssPositioningProp cssProp
    3              0.000016 hi def link cssPrintProp cssProp
    3              0.000025 hi def link cssRubyProp cssProp
    3              0.000030 hi def link cssSpeechProp cssProp
    3              0.000009 hi def link cssTableProp cssProp
    3              0.000007 hi def link cssTextProp cssProp
    3              0.000008 hi def link cssTransformProp cssProp
    3              0.000008 hi def link cssTransitionProp cssProp
    3              0.000008 hi def link cssUIProp cssProp
    3              0.000008 hi def link cssIEUIProp cssProp
    3              0.000008 hi def link cssAuralProp cssProp
    3              0.000018 hi def link cssRenderProp cssProp
    3              0.000009 hi def link cssMobileTextProp cssProp
                            
    3              0.000019 hi def link cssAnimationAttr cssAttr
    3              0.000010 hi def link cssBackgroundAttr cssAttr
    3              0.000008 hi def link cssBorderAttr cssAttr
    3              0.000008 hi def link cssBoxAttr cssAttr
    3              0.000018 hi def link cssContentForPagedMediaAttr cssAttr
    3              0.000017 hi def link cssDimensionAttr cssAttr
    3              0.000075 hi def link cssFlexibleBoxAttr cssAttr
    3              0.000010 hi def link cssFontAttr cssAttr
    3              0.000010 hi def link cssGeneratedContentAttr cssAttr
    3              0.000017 hi def link cssGridAttr cssAttr
    3              0.000017 hi def link cssHyerlinkAttr cssAttr
    3              0.000009 hi def link cssInteractAttr cssAttr
    3              0.000017 hi def link cssLineboxAttr cssAttr
    3              0.000009 hi def link cssListAttr cssAttr
    3              0.000016 hi def link cssMarginAttr cssAttr
    3              0.000017 hi def link cssMarqueeAttr cssAttr
    3              0.000010 hi def link cssMultiColumnAttr cssAttr
    3              0.000017 hi def link cssPaddingAttr cssAttr
    3              0.000018 hi def link cssPagedMediaAttr cssAttr
    3              0.000009 hi def link cssPositioningAttr cssAttr
    3              0.000009 hi def link cssGradientAttr cssAttr
    3              0.000008 hi def link cssPrintAttr cssAttr
    3              0.000016 hi def link cssRubyAttr cssAttr
    3              0.000017 hi def link cssSpeechAttr cssAttr
    3              0.000008 hi def link cssTableAttr cssAttr
    3              0.000008 hi def link cssTextAttr cssAttr
    3              0.000017 hi def link cssTransformAttr cssAttr
    3              0.000009 hi def link cssTransitionAttr cssAttr
    3              0.000008 hi def link cssUIAttr cssAttr
    3              0.000008 hi def link cssIEUIAttr cssAttr
    3              0.000008 hi def link cssAuralAttr cssAttr
    3              0.000016 hi def link cssRenderAttr cssAttr
    3              0.000009 hi def link cssCommonAttr cssAttr
                            
    3              0.000042 hi def link cssPseudoClassId PreProc
    3              0.000044 hi def link cssPseudoClassLang Constant
    3              0.000040 hi def link cssValueLength Number
    3              0.000038 hi def link cssValueInteger Number
    3              0.000111 hi def link cssValueNumber Number
    3              0.000042 hi def link cssValueAngle Number
    3              0.000038 hi def link cssValueTime Number
    3              0.000037 hi def link cssValueFrequency Number
    3              0.000033 hi def link cssFunction Constant
    3              0.000057 hi def link cssURL String
    3              0.000042 hi def link cssFunctionName Function
    3              0.000036 hi def link cssFunctionComma Function
    3              0.000034 hi def link cssColor Constant
    3              0.000033 hi def link cssIdentifier Function
    3              0.000032 hi def link cssAtRule Include
    3              0.000031 hi def link cssAtKeyword PreProc
    3              0.000031 hi def link cssImportant Special
    3              0.000029 hi def link cssBraces Function
    3              0.000031 hi def link cssBraceError Error
    3              0.000031 hi def link cssError Error
    3              0.000033 hi def link cssUnicodeEscape Special
    3              0.000033 hi def link cssStringQQ String
    3              0.000034 hi def link cssStringQ String
    3              0.000035 hi def link cssAttributeSelector String
    3              0.000030 hi def link cssMediaType Special
    3              0.000042 hi def link cssMediaComma Normal
    3              0.000032 hi def link cssAtRuleLogical Statement
    3              0.000010 hi def link cssMediaProp cssProp
    3              0.000008 hi def link cssMediaAttr cssAttr
    3              0.000029 hi def link cssPagePseudo PreProc
    3              0.000011 hi def link cssPageMarginProp cssAtKeyword
    3              0.000008 hi def link cssPageProp cssProp
    3              0.000030 hi def link cssKeyFrameProp Constant
    3              0.000041 hi def link cssFontDescriptor Special
    3              0.000011 hi def link cssFontDescriptorProp cssProp
    3              0.000009 hi def link cssFontDescriptorAttr cssAttr
    3              0.000131 hi def link cssUnicodeRange Constant
    3              0.000033 hi def link cssClassName Function
    3              0.000048 hi def link cssClassNameDot Function
    3              0.000035 hi def link cssProp StorageClass
    3              0.000031 hi def link cssAttr Constant
    3              0.000037 hi def link cssUnitDecorators Number
    3              0.000018 hi def link cssNoise Noise
                            
    3              0.000023 let b:current_syntax = "css"
                            
    3              0.000017 if main_syntax == 'css'
                              unlet main_syntax
                            endif
                            
    3              0.000053 let &cpo = s:cpo_save
    3              0.000010 unlet s:cpo_save
                            " vim: ts=8
                            

SCRIPT  /Users/liss/.polka/config/nvim/ftplugin/markdown.vim
Sourced 3 times
Total time:   0.001451
 Self time:   0.001451

count  total (s)   self (s)
    3              0.000081 let b:ale_linters = ['prettier']

SCRIPT  /Users/liss/.local/share/nvim/plugged/vim-markdown/ftplugin/markdown.vim
Sourced 3 times
Total time:   0.007817
 Self time:   0.005839

count  total (s)   self (s)
                            "TODO print messages when on visual mode. I only see VISUAL, not the messages.
                            
                            " Function interface phylosophy:
                            "
                            " - functions take arbitrary line numbers as parameters.
                            "    Current cursor line is only a suitable default parameter.
                            "
                            " - only functions that bind directly to user actions:
                            "
                            "    - print error messages.
                            "       All intermediate functions limit themselves return `0` to indicate an error.
                            "
                            "    - move the cursor. All other functions do not move the cursor.
                            "
                            " This is how you should view headers for the header mappings:
                            "
                            "   |BUFFER
                            "   |
                            "   |Outside any header
                            "   |
                            " a-+# a
                            "   |
                            "   |Inside a
                            "   |
                            " a-+
                            " b-+## b
                            "   |
                            "   |inside b
                            "   |
                            " b-+
                            " c-+### c
                            "   |
                            "   |Inside c
                            "   |
                            " c-+
                            " d-|# d
                            "   |
                            "   |Inside d
                            "   |
                            " d-+
                            " e-|e
                            "   |====
                            "   |
                            "   |Inside e
                            "   |
                            " e-+
                            
                            " For each level, contains the regexp that matches at that level only.
                            "
    3              0.000054 let s:levelRegexpDict = {
                                \ 1: '\v^(#[^#]@=|.+\n\=+$)',
                                \ 2: '\v^(##[^#]@=|.+\n-+$)',
                                \ 3: '\v^###[^#]@=',
                                \ 4: '\v^####[^#]@=',
                                \ 5: '\v^#####[^#]@=',
                                \ 6: '\v^######[^#]@='
                            \ }
                            
                            " Maches any header level of any type.
                            "
                            " This could be deduced from `s:levelRegexpDict`, but it is more
                            " efficient to have a single regexp for this.
                            "
    3              0.000008 let s:headersRegexp = '\v^(#|.+\n(\=+|-+)$)'
                            
                            " Returns the line number of the first header before `line`, called the
                            " current header.
                            "
                            " If there is no current header, return `0`.
                            "
                            " @param a:1 The line to look the header of. Default value: `getpos('.')`.
                            "
    3              0.000010 function! s:GetHeaderLineNum(...)
                                if a:0 == 0
                                    let l:l = line('.')
                                else
                                    let l:l = a:1
                                endif
                                while(l:l > 0)
                                    if join(getline(l:l, l:l + 1), "\n") =~ s:headersRegexp
                                        return l:l
                                    endif
                                    let l:l -= 1
                                endwhile
                                return 0
                            endfunction
                            
                            " -  if inside a header goes to it.
                            "    Return its line number.
                            "
                            " -  if on top level outside any headers,
                            "    print a warning
                            "    Return `0`.
                            "
    3              0.000006 function! s:MoveToCurHeader()
                                let l:lineNum = s:GetHeaderLineNum()
                                if l:lineNum != 0
                                    call cursor(l:lineNum, 1)
                                else
                                    echo 'outside any header'
                                    "normal! gg
                                endif
                                return l:lineNum
                            endfunction
                            
                            " Move cursor to next header of any level.
                            "
                            " If there are no more headers, print a warning.
                            "
    3              0.000005 function! s:MoveToNextHeader()
                                if search(s:headersRegexp, 'W') == 0
                                    "normal! G
                                    echo 'no next header'
                                endif
                            endfunction
                            
                            " Move cursor to previous header (before current) of any level.
                            "
                            " If it does not exist, print a warning.
                            "
    3              0.000004 function! s:MoveToPreviousHeader()
                                let l:curHeaderLineNumber = s:GetHeaderLineNum()
                                let l:noPreviousHeader = 0
                                if l:curHeaderLineNumber <= 1
                                    let l:noPreviousHeader = 1
                                else
                                    let l:previousHeaderLineNumber = s:GetHeaderLineNum(l:curHeaderLineNumber - 1)
                                    if l:previousHeaderLineNumber == 0
                                        let l:noPreviousHeader = 1
                                    else
                                        call cursor(l:previousHeaderLineNumber, 1)
                                    endif
                                endif
                                if l:noPreviousHeader
                                    echo 'no previous header'
                                endif
                            endfunction
                            
                            " - if line is inside a header, return the header level (h1 -> 1, h2 -> 2, etc.).
                            "
                            " - if line is at top level outside any headers, return `0`.
                            "
    3              0.000005 function! s:GetHeaderLevel(...)
                                if a:0 == 0
                                    let l:line = line('.')
                                else
                                    let l:line = a:1
                                endif
                                let l:linenum = s:GetHeaderLineNum(l:line)
                                if l:linenum != 0
                                    return s:GetLevelOfHeaderAtLine(l:linenum)
                                else
                                    return 0
                                endif
                            endfunction
                            
                            " Returns the level of the header at the given line.
                            "
                            " If there is no header at the given line, returns `0`.
                            "
    3              0.000006 function! s:GetLevelOfHeaderAtLine(linenum)
                                let l:lines = join(getline(a:linenum, a:linenum + 1), "\n")
                                for l:key in keys(s:levelRegexpDict)
                                    if l:lines =~ get(s:levelRegexpDict, l:key)
                                        return l:key
                                    endif
                                endfor
                                return 0
                            endfunction
                            
                            " Move cursor to parent header of the current header.
                            "
                            " If it does not exit, print a warning and do nothing.
                            "
    3              0.000169 function! s:MoveToParentHeader()
                                let l:linenum = s:GetParentHeaderLineNumber()
                                if l:linenum != 0
                                    call cursor(l:linenum, 1)
                                else
                                    echo 'no parent header'
                                endif
                            endfunction
                            
                            " Return the line number of the parent header of line `line`.
                            "
                            " If it has no parent, return `0`.
                            "
    3              0.000009 function! s:GetParentHeaderLineNumber(...)
                                if a:0 == 0
                                    let l:line = line('.')
                                else
                                    let l:line = a:1
                                endif
                                let l:level = s:GetHeaderLevel(l:line)
                                if l:level > 1
                                    let l:linenum = s:GetPreviousHeaderLineNumberAtLevel(l:level - 1, l:line)
                                    return l:linenum
                                endif
                                return 0
                            endfunction
                            
                            " Return the line number of the previous header of given level.
                            " in relation to line `a:1`. If not given, `a:1 = getline()`
                            "
                            " `a:1` line is included, and this may return the current header.
                            "
                            " If none return 0.
                            "
    3              0.000006 function! s:GetNextHeaderLineNumberAtLevel(level, ...)
                                if a:0 < 1
                                    let l:line = line('.')
                                else
                                    let l:line = a:1
                                endif
                                let l:l = l:line
                                while(l:l <= line('$'))
                                    if join(getline(l:l, l:l + 1), "\n") =~ get(s:levelRegexpDict, a:level)
                                        return l:l
                                    endif
                                    let l:l += 1
                                endwhile
                                return 0
                            endfunction
                            
                            " Return the line number of the previous header of given level.
                            " in relation to line `a:1`. If not given, `a:1 = getline()`
                            "
                            " `a:1` line is included, and this may return the current header.
                            "
                            " If none return 0.
                            "
    3              0.000007 function! s:GetPreviousHeaderLineNumberAtLevel(level, ...)
                                if a:0 == 0
                                    let l:line = line('.')
                                else
                                    let l:line = a:1
                                endif
                                let l:l = l:line
                                while(l:l > 0)
                                    if join(getline(l:l, l:l + 1), "\n") =~ get(s:levelRegexpDict, a:level)
                                        return l:l
                                    endif
                                    let l:l -= 1
                                endwhile
                                return 0
                            endfunction
                            
                            " Move cursor to next sibling header.
                            "
                            " If there is no next siblings, print a warning and don't move.
                            "
    3              0.000006 function! s:MoveToNextSiblingHeader()
                                let l:curHeaderLineNumber = s:GetHeaderLineNum()
                                let l:curHeaderLevel = s:GetLevelOfHeaderAtLine(l:curHeaderLineNumber)
                                let l:curHeaderParentLineNumber = s:GetParentHeaderLineNumber()
                                let l:nextHeaderSameLevelLineNumber = s:GetNextHeaderLineNumberAtLevel(l:curHeaderLevel, l:curHeaderLineNumber + 1)
                                let l:noNextSibling = 0
                                if l:nextHeaderSameLevelLineNumber == 0
                                    let l:noNextSibling = 1
                                else
                                    let l:nextHeaderSameLevelParentLineNumber = s:GetParentHeaderLineNumber(l:nextHeaderSameLevelLineNumber)
                                    if l:curHeaderParentLineNumber == l:nextHeaderSameLevelParentLineNumber
                                        call cursor(l:nextHeaderSameLevelLineNumber, 1)
                                    else
                                        let l:noNextSibling = 1
                                    endif
                                endif
                                if l:noNextSibling
                                    echo 'no next sibling header'
                                endif
                            endfunction
                            
                            " Move cursor to previous sibling header.
                            "
                            " If there is no previous siblings, print a warning and do nothing.
                            "
    3              0.000005 function! s:MoveToPreviousSiblingHeader()
                                let l:curHeaderLineNumber = s:GetHeaderLineNum()
                                let l:curHeaderLevel = s:GetLevelOfHeaderAtLine(l:curHeaderLineNumber)
                                let l:curHeaderParentLineNumber = s:GetParentHeaderLineNumber()
                                let l:previousHeaderSameLevelLineNumber = s:GetPreviousHeaderLineNumberAtLevel(l:curHeaderLevel, l:curHeaderLineNumber - 1)
                                let l:noPreviousSibling = 0
                                if l:previousHeaderSameLevelLineNumber == 0
                                    let l:noPreviousSibling = 1
                                else
                                    let l:previousHeaderSameLevelParentLineNumber = s:GetParentHeaderLineNumber(l:previousHeaderSameLevelLineNumber)
                                    if l:curHeaderParentLineNumber == l:previousHeaderSameLevelParentLineNumber
                                        call cursor(l:previousHeaderSameLevelLineNumber, 1)
                                    else
                                        let l:noPreviousSibling = 1
                                    endif
                                endif
                                if l:noPreviousSibling
                                    echo 'no previous sibling header'
                                endif
                            endfunction
                            
    3              0.000005 function! s:Toc(...)
                                if a:0 > 0
                                    let l:window_type = a:1
                                else
                                    let l:window_type = 'vertical'
                                endif
                            
                            
                                let l:bufnr = bufnr('%')
                                let l:cursor_line = line('.')
                                let l:cursor_header = 0
                                let l:fenced_block = 0
                                let l:front_matter = 0
                                let l:header_list = []
                                let l:header_max_len = 0
                                let l:vim_markdown_toc_autofit = get(g:, "vim_markdown_toc_autofit", 0)
                                let l:vim_markdown_frontmatter = get(g:, "vim_markdown_frontmatter", 0)
                                for i in range(1, line('$'))
                                    let l:lineraw = getline(i)
                                    let l:l1 = getline(i+1)
                                    let l:line = substitute(l:lineraw, "#", "\\\#", "g")
                                    if l:line =~ '````*' || l:line =~ '\~\~\~\~*'
                                        if l:fenced_block == 0
                                            let l:fenced_block = 1
                                        elseif l:fenced_block == 1
                                            let l:fenced_block = 0
                                        endif
                                    elseif l:vim_markdown_frontmatter == 1
                                        if l:front_matter == 1
                                            if l:line == '---'
                                                let l:front_matter = 0
                                            endif
                                        elseif i == 1
                                            if l:line == '---'
                                                let l:front_matter = 1
                                            endif
                                        endif
                                    endif
                                    if l:line =~ '^#\+' || (l:l1 =~ '^=\+\s*$' || l:l1 =~ '^-\+\s*$') && l:line =~ '^\S'
                                        let l:is_header = 1
                                    else
                                        let l:is_header = 0
                                    endif
                                    if l:is_header == 1 && l:fenced_block == 0 && l:front_matter == 0
                                        " append line to location list
                                        let l:item = {'lnum': i, 'text': l:line, 'valid': 1, 'bufnr': l:bufnr, 'col': 1}
                                        let l:header_list = l:header_list + [l:item]
                                        " set header number of the cursor position
                                        if l:cursor_header == 0
                                            if i == l:cursor_line
                                                let l:cursor_header = len(l:header_list)
                                            elseif i > l:cursor_line
                                                let l:cursor_header = len(l:header_list) - 1
                                            endif
                                        endif
                                        " keep track of the longest header size (heading level + title)
                                        let l:total_len = stridx(l:line, ' ') + strdisplaywidth(l:line)
                                        if l:total_len > l:header_max_len
                                            let l:header_max_len = l:total_len
                                        endif
                                    endif
                                endfor
                                call setloclist(0, l:header_list)
                                if len(l:header_list) == 0
                                    echom "Toc: No headers."
                                    return
                                endif
                            
                                if l:window_type ==# 'horizontal'
                                    lopen
                                elseif l:window_type ==# 'vertical'
                                    vertical lopen
                                    " auto-fit toc window when possible to shrink it
                                    if (&columns/2) > l:header_max_len && l:vim_markdown_toc_autofit == 1
                                        execute 'vertical resize ' . (l:header_max_len + 1)
                                    else
                                        execute 'vertical resize ' . (&columns/2)
                                    endif
                                elseif l:window_type ==# 'tab'
                                    tab lopen
                                else
                                    lopen
                                endif
                                setlocal modifiable
                                for i in range(1, line('$'))
                                    " this is the location-list data for the current item
                                    let d = getloclist(0)[i-1]
                                    " atx headers
                                    if match(d.text, "^#") > -1
                                        let l:level = len(matchstr(d.text, '#*', 'g'))-1
                                        let d.text = substitute(d.text, '\v^#*[ ]*', '', '')
                                        let d.text = substitute(d.text, '\v[ ]*#*$', '', '')
                                    " setex headers
                                    else
                                        let l:next_line = getbufline(d.bufnr, d.lnum+1)
                                        if match(l:next_line, "=") > -1
                                            let l:level = 0
                                        elseif match(l:next_line, "-") > -1
                                            let l:level = 1
                                        endif
                                    endif
                                    call setline(i, repeat('  ', l:level). d.text)
                                endfor
                                setlocal nomodified
                                setlocal nomodifiable
                                execute 'normal! ' . l:cursor_header . 'G'
                            endfunction
                            
                            " Convert Setex headers in range `line1 .. line2` to Atx.
                            "
                            " Return the number of conversions.
                            "
    3              0.000040 function! s:SetexToAtx(line1, line2)
                                let l:originalNumLines = line('$')
                                execute 'silent! ' . a:line1 . ',' . a:line2 . 'substitute/\v(.*\S.*)\n\=+$/# \1/'
                                execute 'silent! ' . a:line1 . ',' . a:line2 . 'substitute/\v(.*\S.*)\n-+$/## \1/'
                                return l:originalNumLines - line('$')
                            endfunction
                            
                            " If `a:1` is 0, decrease the level of all headers in range `line1 .. line2`.
                            "
                            " Otherwise, increase the level. `a:1` defaults to `0`.
                            "
    3              0.000020 function! s:HeaderDecrease(line1, line2, ...)
                                if a:0 > 0
                                    let l:increase = a:1
                                else
                                    let l:increase = 0
                                endif
                                if l:increase
                                    let l:forbiddenLevel = 6
                                    let l:replaceLevels = [5, 1]
                                    let l:levelDelta = 1
                                else
                                    let l:forbiddenLevel = 1
                                    let l:replaceLevels = [2, 6]
                                    let l:levelDelta = -1
                                endif
                                for l:line in range(a:line1, a:line2)
                                    if join(getline(l:line, l:line + 1), "\n") =~ s:levelRegexpDict[l:forbiddenLevel]
                                        echomsg 'There is an h' . l:forbiddenLevel . ' at line ' . l:line . '. Aborting.'
                                        return
                                    endif
                                endfor
                                let l:numSubstitutions = s:SetexToAtx(a:line1, a:line2)
                                let l:flags = (&gdefault ? '' : 'g')
                                for l:level in range(replaceLevels[0], replaceLevels[1], -l:levelDelta)
                                    execute 'silent! ' . a:line1 . ',' . (a:line2 - l:numSubstitutions) . 'substitute/' . s:levelRegexpDict[l:level] . '/' . repeat('#', l:level + l:levelDelta) . '/' . l:flags
                                endfor
                            endfunction
                            
                            " Format table under cursor.
                            "
                            " Depends on Tabularize.
                            "
    3              0.000023 function! s:TableFormat()
                                let l:pos = getpos('.')
                                normal! {
                                " Search instead of `normal! j` because of the table at beginning of file edge case.
                                call search('|')
                                normal! j
                                " Remove everything that is not a pipe, colon or hyphen next to a colon othewise
                                " well formated tables would grow because of addition of 2 spaces on the separator
                                " line by Tabularize /|.
                                let l:flags = (&gdefault ? '' : 'g')
                                execute 's/\(:\@<!-:\@!\|[^|:-]\)//e' . l:flags
                                execute 's/--/-/e' . l:flags
                                Tabularize /|
                                " Move colons for alignment to left or right side of the cell.
                                execute 's/:\( \+\)|/\1:|/e' . l:flags
                                execute 's/|\( \+\):/|:\1/e' . l:flags
                                execute 's/ /-/' . l:flags
                                call setpos('.', l:pos)
                            endfunction
                            
                            " Wrapper to do move commands in visual mode.
                            "
    3              0.000006 function! s:VisMove(f)
                                norm! gv
                                call function(a:f)()
                            endfunction
                            
                            " Map in both normal and visual modes.
                            "
    3              0.000005 function! s:MapNormVis(rhs,lhs)
                                execute 'nn <buffer><silent> ' . a:rhs . ' :call ' . a:lhs . '()<cr>'
                                execute 'vn <buffer><silent> ' . a:rhs . ' <esc>:call <sid>VisMove(''' . a:lhs . ''')<cr>'
                            endfunction
                            
                            " Parameters:
                            "
                            " - step +1 for right, -1 for left
                            "
                            " TODO: multiple lines.
                            "
    3              0.000006 function! s:FindCornerOfSyntax(lnum, col, step)
                                let l:col = a:col
                                let l:syn = synIDattr(synID(a:lnum, l:col, 1), 'name')
                                while synIDattr(synID(a:lnum, l:col, 1), 'name') ==# l:syn
                                    let l:col += a:step
                                endwhile
                                return l:col - a:step
                            endfunction
                            
                            " Return the next position of the given syntax name,
                            " inclusive on the given position.
                            "
                            " TODO: multiple lines
                            "
    3              0.000011 function! s:FindNextSyntax(lnum, col, name)
                                let l:col = a:col
                                let l:step = 1
                                while synIDattr(synID(a:lnum, l:col, 1), 'name') !=# a:name
                                    let l:col += l:step
                                endwhile
                                return [a:lnum, l:col]
                            endfunction
                            
    3              0.000012 function! s:FindCornersOfSyntax(lnum, col)
                                return [<sid>FindLeftOfSyntax(a:lnum, a:col), <sid>FindRightOfSyntax(a:lnum, a:col)]
                            endfunction
                            
    3              0.000007 function! s:FindRightOfSyntax(lnum, col)
                                return <sid>FindCornerOfSyntax(a:lnum, a:col, 1)
                            endfunction
                            
    3              0.000006 function! s:FindLeftOfSyntax(lnum, col)
                                return <sid>FindCornerOfSyntax(a:lnum, a:col, -1)
                            endfunction
                            
                            " Returns:
                            "
                            " - a string with the the URL for the link under the cursor
                            " - an empty string if the cursor is not on a link
                            "
                            " TODO
                            "
                            " - multiline support
                            " - give an error if the separator does is not on a link
                            "
    3              0.000046 function! s:Markdown_GetUrlForPosition(lnum, col)
                                let l:lnum = a:lnum
                                let l:col = a:col
                                let l:syn = synIDattr(synID(l:lnum, l:col, 1), 'name')
                            
                                if l:syn ==# 'mkdInlineURL' || l:syn ==# 'mkdURL' || l:syn ==# 'mkdLinkDefTarget'
                                    " Do nothing.
                                elseif l:syn ==# 'mkdLink'
                                    let [l:lnum, l:col] = <sid>FindNextSyntax(l:lnum, l:col, 'mkdURL')
                                    let l:syn = 'mkdURL'
                                elseif l:syn ==# 'mkdDelimiter'
                                    let l:line = getline(l:lnum)
                                    let l:char = l:line[col - 1]
                                    if l:char ==# '<'
                                        let l:col += 1
                                    elseif l:char ==# '>' || l:char ==# ')'
                                        let l:col -= 1
                                    elseif l:char ==# '[' || l:char ==# ']' || l:char ==# '('
                                        let [l:lnum, l:col] = <sid>FindNextSyntax(l:lnum, l:col, 'mkdURL')
                                    else
                                        return ''
                                    endif
                                else
                                    return ''
                                endif
                            
                                let [l:left, l:right] = <sid>FindCornersOfSyntax(l:lnum, l:col)
                                return getline(l:lnum)[l:left - 1 : l:right - 1]
                            endfunction
                            
                            " Front end for GetUrlForPosition.
                            "
    3              0.000069 function! s:OpenUrlUnderCursor()
                                let l:url = s:Markdown_GetUrlForPosition(line('.'), col('.'))
                                if l:url != ''
                                    call s:VersionAwareNetrwBrowseX(l:url)
                                else
                                    echomsg 'The cursor is not on a link.'
                                endif
                            endfunction
                            
                            " We need a definition guard because we invoke 'edit' which will reload this
                            " script while this function is running. We must not replace it.
    3              0.000044 if !exists('*s:EditUrlUnderCursor')
    1              0.000002     function s:EditUrlUnderCursor()
                                    let l:url = s:Markdown_GetUrlForPosition(line('.'), col('.'))
                                    if l:url != ''
                                        if get(g:, 'vim_markdown_autowrite', 0)
                                            write
                                        endif
                                        let l:anchor = ''
                                        if get(g:, 'vim_markdown_follow_anchor', 0)
                                            let l:parts = split(l:url, '#', 1)
                                            if len(l:parts) == 2
                                                let [l:url, l:anchor] = parts
                                                let l:anchorexpr = get(g:, 'vim_markdown_anchorexpr', '')
                                                if l:anchorexpr != ''
                                                    let l:anchor = eval(substitute(
                                                        \ l:anchorexpr, 'v:anchor',
                                                        \ escape('"'.l:anchor.'"', '"'), ''))
                                                endif
                                            endif
                                        endif
                                        if l:url != ''
                                            let l:ext = ''
                                            if get(g:, 'vim_markdown_no_extensions_in_markdown', 0)
                                                " use another file extension if preferred
                                                if exists('g:vim_markdown_auto_extension_ext')
                                                    let l:ext = '.'.g:vim_markdown_auto_extension_ext
                                                else
                                                    let l:ext = '.md'
                                                endif
                                            endif
                                            let l:url = fnameescape(fnamemodify(expand('%:h').'/'.l:url.l:ext, ':.'))
                                            let l:editmethod = ''
                                            " determine how to open the linked file (split, tab, etc)
                                            if exists('g:vim_markdown_edit_url_in')
                                              if g:vim_markdown_edit_url_in == 'tab'
                                                let l:editmethod = 'tabnew'
                                              elseif g:vim_markdown_edit_url_in == 'vsplit'
                                                let l:editmethod = 'vsp'
                                              elseif g:vim_markdown_edit_url_in == 'hsplit'
                                                let l:editmethod = 'sp'
                                              else
                                                let l:editmethod = 'edit'
                                              endif
                                            else
                                              " default to current buffer
                                              let l:editmethod = 'edit'
                                            endif
                                            execute l:editmethod l:url
                                        endif
                                        if l:anchor != ''
                                            silent! execute '/'.l:anchor
                                        endif
                                    else
                                        echomsg 'The cursor is not on a link.'
                                    endif
                                endfunction
    1              0.000002 endif
                            
    3              0.000007 function! s:VersionAwareNetrwBrowseX(url)
                                if has('patch-7.4.567')
                                    call netrw#BrowseX(a:url, 0)
                                else
                                    call netrw#NetrwBrowseX(a:url, 0)
                                endif
                            endf
                            
    3              0.000005 function! s:MapNotHasmapto(lhs, rhs)
                                if !hasmapto('<Plug>' . a:rhs)
                                    execute 'nmap <buffer>' . a:lhs . ' <Plug>' . a:rhs
                                    execute 'vmap <buffer>' . a:lhs . ' <Plug>' . a:rhs
                                endif
                            endfunction
                            
    3   0.000402   0.000133 call <sid>MapNormVis('<Plug>Markdown_MoveToNextHeader', '<sid>MoveToNextHeader')
    3   0.000216   0.000046 call <sid>MapNormVis('<Plug>Markdown_MoveToPreviousHeader', '<sid>MoveToPreviousHeader')
    3   0.000159   0.000022 call <sid>MapNormVis('<Plug>Markdown_MoveToNextSiblingHeader', '<sid>MoveToNextSiblingHeader')
    3   0.000145   0.000019 call <sid>MapNormVis('<Plug>Markdown_MoveToPreviousSiblingHeader', '<sid>MoveToPreviousSiblingHeader')
    3   0.000116   0.000015 call <sid>MapNormVis('<Plug>Markdown_MoveToParentHeader', '<sid>MoveToParentHeader')
    3   0.000107   0.000013 call <sid>MapNormVis('<Plug>Markdown_MoveToCurHeader', '<sid>MoveToCurHeader')
    3              0.000073 nnoremap <Plug>Markdown_OpenUrlUnderCursor :call <sid>OpenUrlUnderCursor()<cr>
    3              0.000037 nnoremap <Plug>Markdown_EditUrlUnderCursor :call <sid>EditUrlUnderCursor()<cr>
                            
    3              0.000014 if !get(g:, 'vim_markdown_no_default_key_mappings', 0)
    3   0.000645   0.000382     call <sid>MapNotHasmapto(']]', 'Markdown_MoveToNextHeader')
    3   0.000148   0.000025     call <sid>MapNotHasmapto('[[', 'Markdown_MoveToPreviousHeader')
    3   0.000131   0.000015     call <sid>MapNotHasmapto('][', 'Markdown_MoveToNextSiblingHeader')
    3   0.000145   0.000032     call <sid>MapNotHasmapto('[]', 'Markdown_MoveToPreviousSiblingHeader')
    3   0.000124   0.000014     call <sid>MapNotHasmapto(']u', 'Markdown_MoveToParentHeader')
    3   0.000117   0.000012     call <sid>MapNotHasmapto(']c', 'Markdown_MoveToCurHeader')
    3   0.000118   0.000012     call <sid>MapNotHasmapto('gx', 'Markdown_OpenUrlUnderCursor')
    3   0.000158   0.000014     call <sid>MapNotHasmapto('ge', 'Markdown_EditUrlUnderCursor')
    3              0.000003 endif
                            
    3              0.000017 command! -buffer -range=% HeaderDecrease call s:HeaderDecrease(<line1>, <line2>)
    3              0.000013 command! -buffer -range=% HeaderIncrease call s:HeaderDecrease(<line1>, <line2>, 1)
    3              0.000012 command! -buffer -range=% SetexToAtx call s:SetexToAtx(<line1>, <line2>)
    3              0.000006 command! -buffer TableFormat call s:TableFormat()
    3              0.000008 command! -buffer Toc call s:Toc()
    3              0.000007 command! -buffer Toch call s:Toc('horizontal')
    3              0.000006 command! -buffer Tocv call s:Toc('vertical')
    3              0.000005 command! -buffer Toct call s:Toc('tab')
                            
                            " Heavily based on vim-notes - http://peterodding.com/code/vim/notes/
    3              0.000010 if exists('g:vim_markdown_fenced_languages')
                                let s:filetype_dict = {}
                                for s:filetype in g:vim_markdown_fenced_languages
                                    let key = matchstr(s:filetype, "[^=]*")
                                    let val = matchstr(s:filetype, "[^=]*$")
                                    let s:filetype_dict[key] = val
                                endfor
                            else
    3              0.000074     let s:filetype_dict = {
                                    \ 'c++': 'cpp',
                                    \ 'viml': 'vim',
                                    \ 'bash': 'sh',
                                    \ 'ini': 'dosini'
                                \ }
    3              0.000002 endif
                            
    3              0.000017 function! s:MarkdownHighlightSources(force)
                                " Syntax highlight source code embedded in notes.
                                " Look for code blocks in the current file
                                let filetypes = {}
                                for line in getline(1, '$')
                                    let ft = matchstr(line, '```\s*\zs[0-9A-Za-z_+-]*')
                                    if !empty(ft) && ft !~ '^\d*$' | let filetypes[ft] = 1 | endif
                                endfor
                                if !exists('b:mkd_known_filetypes')
                                    let b:mkd_known_filetypes = {}
                                endif
                                if !exists('b:mkd_included_filetypes')
                                    " set syntax file name included
                                    let b:mkd_included_filetypes = {}
                                endif
                                if !a:force && (b:mkd_known_filetypes == filetypes || empty(filetypes))
                                    return
                                endif
                            
                                " Now we're ready to actually highlight the code blocks.
                                let startgroup = 'mkdCodeStart'
                                let endgroup = 'mkdCodeEnd'
                                for ft in keys(filetypes)
                                    if a:force || !has_key(b:mkd_known_filetypes, ft)
                                        if has_key(s:filetype_dict, ft)
                                            let filetype = s:filetype_dict[ft]
                                        else
                                            let filetype = ft
                                        endif
                                        let group = 'mkdSnippet' . toupper(substitute(filetype, "[+-]", "_", "g"))
                                        if !has_key(b:mkd_included_filetypes, filetype)
                                            let include = s:SyntaxInclude(filetype)
                                            let b:mkd_included_filetypes[filetype] = 1
                                        else
                                            let include = '@' . toupper(filetype)
                                        endif
                                        let command = 'syntax region %s matchgroup=%s start="^\s*```\s*%s$" matchgroup=%s end="\s*```$" keepend contains=%s%s'
                                        execute printf(command, group, startgroup, ft, endgroup, include, has('conceal') && get(g:, 'vim_markdown_conceal', 1) && get(g:, 'vim_markdown_conceal_code_blocks', 1) ? ' concealends' : '')
                                        execute printf('syntax cluster mkdNonListItem add=%s', group)
                            
                                        let b:mkd_known_filetypes[ft] = 1
                                    endif
                                endfor
                            endfunction
                            
    3              0.000014 function! s:SyntaxInclude(filetype)
                                " Include the syntax highlighting of another {filetype}.
                                let grouplistname = '@' . toupper(a:filetype)
                                " Unset the name of the current syntax while including the other syntax
                                " because some syntax scripts do nothing when "b:current_syntax" is set
                                if exists('b:current_syntax')
                                    let syntax_save = b:current_syntax
                                    unlet b:current_syntax
                                endif
                                try
                                    execute 'syntax include' grouplistname 'syntax/' . a:filetype . '.vim'
                                    execute 'syntax include' grouplistname 'after/syntax/' . a:filetype . '.vim'
                                catch /E484/
                                    " Ignore missing scripts
                                endtry
                                " Restore the name of the current syntax
                                if exists('syntax_save')
                                    let b:current_syntax = syntax_save
                                elseif exists('b:current_syntax')
                                    unlet b:current_syntax
                                endif
                                return grouplistname
                            endfunction
                            
                            
    3              0.000007 function! s:MarkdownRefreshSyntax(force)
                                if &filetype =~ 'markdown' && line('$') > 1
                                    call s:MarkdownHighlightSources(a:force)
                                endif
                            endfunction
                            
    3              0.000004 function! s:MarkdownClearSyntaxVariables()
                                if &filetype =~ 'markdown'
                                    unlet! b:mkd_included_filetypes
                                endif
                            endfunction
                            
    3              0.000011 augroup Mkd
                                " These autocmd calling s:MarkdownRefreshSyntax need to be kept in sync with
                                " the autocmds calling s:MarkdownSetupFolding in after/ftplugin/markdown.vim.
    3              0.000711     autocmd! * <buffer>
    3              0.000015     autocmd BufWinEnter <buffer> call s:MarkdownRefreshSyntax(1)
    3              0.000009     autocmd BufUnload <buffer> call s:MarkdownClearSyntaxVariables()
    3              0.000015     autocmd BufWritePost <buffer> call s:MarkdownRefreshSyntax(0)
    3              0.000014     autocmd InsertEnter,InsertLeave <buffer> call s:MarkdownRefreshSyntax(0)
    3              0.000015     autocmd CursorHold,CursorHoldI <buffer> call s:MarkdownRefreshSyntax(0)
    3              0.000010 augroup END

SCRIPT  /usr/local/Cellar/neovim/HEAD-c6cd608/share/nvim/runtime/ftplugin/markdown.vim
Sourced 3 times
Total time:   0.037698
 Self time:   0.018514

count  total (s)   self (s)
                            " Vim filetype plugin
                            " Language:		Markdown
                            " Maintainer:		Tim Pope <vimNOSPAM@tpope.org>
                            " Last Change:		2016 Aug 29
                            
    3              0.000029 if exists("b:did_ftplugin")
                              finish
                            endif
                            
    3   0.037066   0.017882 runtime! ftplugin/html.vim ftplugin/html_*.vim ftplugin/html/*.vim
                            
    3              0.000040 setlocal comments=fb:*,fb:-,fb:+,n:> commentstring=>\ %s
    3              0.000031 setlocal formatoptions+=tcqln formatoptions-=r formatoptions-=o
    3              0.000015 setlocal formatlistpat=^\\s*\\d\\+\\.\\s\\+\\\|^[-*+]\\s\\+\\\|^\\[^\\ze[^\\]]\\+\\]:
                            
    3              0.000021 if exists('b:undo_ftplugin')
    3              0.000015   let b:undo_ftplugin .= "|setl cms< com< fo< flp<"
    3              0.000003 else
                              let b:undo_ftplugin = "setl cms< com< fo< flp<"
                            endif
                            
    3              0.000008 function! MarkdownFold()
                              let line = getline(v:lnum)
                            
                              " Regular headers
                              let depth = match(line, '\(^#\+\)\@<=\( .*$\)\@=')
                              if depth > 0
                                return ">" . depth
                              endif
                            
                              " Setext style headings
                              let nextline = getline(v:lnum + 1)
                              if (line =~ '^.\+$') && (nextline =~ '^=\+$')
                                return ">1"
                              endif
                            
                              if (line =~ '^.\+$') && (nextline =~ '^-\+$')
                                return ">2"
                              endif
                            
                              return "="
                            endfunction
                            
    3              0.000022 if has("folding") && exists("g:markdown_folding")
                              setlocal foldexpr=MarkdownFold()
                              setlocal foldmethod=expr
                              let b:undo_ftplugin .= " foldexpr< foldmethod<"
                            endif
                            
                            " vim:set sw=2:

SCRIPT  /usr/local/Cellar/neovim/HEAD-c6cd608/share/nvim/runtime/ftplugin/html.vim
Sourced 3 times
Total time:   0.018984
 Self time:   0.013854

count  total (s)   self (s)
                            " Vim filetype plugin file
                            " Language:	html
                            " Maintainer:	Dan Sharp <dwsharp at users dot sourceforge dot net>
                            " Last Changed: 20 Jan 2009
                            " URL:		http://dwsharp.users.sourceforge.net/vim/ftplugin
                            
    3              0.000040 if exists("b:did_ftplugin") | finish | endif
    3              0.000013 let b:did_ftplugin = 1
                            
                            " Make sure the continuation lines below do not cause problems in
                            " compatibility mode.
    3              0.000026 let s:save_cpo = &cpo
    3              0.000035 set cpo-=C
                            
    3              0.000016 setlocal matchpairs+=<:>
    3              0.000014 setlocal commentstring=<!--%s-->
    3              0.000014 setlocal comments=s:<!--,m:\ \ \ \ ,e:-->
                            
    3              0.000016 if exists("g:ft_html_autocomment") && (g:ft_html_autocomment == 1)
                                setlocal formatoptions-=t formatoptions+=croql
                            endif
                            
    3              0.000009 if exists('&omnifunc')
    3              0.000012   setlocal omnifunc=htmlcomplete#CompleteTags
    3   0.017401   0.012271   call htmlcomplete#DetectOmniFlavor()
    3              0.000005 endif
                            
                            " HTML:  thanks to Johannes Zellner and Benji Fisher.
    3              0.000011 if exists("loaded_matchit")
    3              0.000007     let b:match_ignorecase = 1
    3              0.000022     let b:match_words = '<:>,' .
                                \ '<\@<=[ou]l\>[^>]*\%(>\|$\):<\@<=li\>:<\@<=/[ou]l>,' .
                                \ '<\@<=dl\>[^>]*\%(>\|$\):<\@<=d[td]\>:<\@<=/dl>,' .
                                \ '<\@<=\([^/][^ \t>]*\)[^>]*\%(>\|$\):<\@<=/\1>'
    3              0.000002 endif
                            
                            " Change the :browse e filter to primarily show HTML-related files.
    3              0.000015 if has("gui_win32")
                                let  b:browsefilter="HTML Files (*.html,*.htm)\t*.htm;*.html\n" .
                            		\	"JavaScript Files (*.js)\t*.js\n" .
                            		\	"Cascading StyleSheets (*.css)\t*.css\n" .
                            		\	"All Files (*.*)\t*.*\n"
                            endif
                            
                            " Undo the stuff we changed.
    3              0.000017 let b:undo_ftplugin = "setlocal commentstring< matchpairs< omnifunc< comments< formatoptions<" .
                                \	" | unlet! b:match_ignorecase b:match_skip b:match_words b:browsefilter"
                            
                            " Restore the saved compatibility options.
    3              0.000034 let &cpo = s:save_cpo
    3              0.000019 unlet s:save_cpo

SCRIPT  /usr/local/Cellar/neovim/HEAD-c6cd608/share/nvim/runtime/autoload/htmlcomplete.vim
Sourced 1 time
Total time:   0.004451
 Self time:   0.004451

count  total (s)   self (s)
                            " Vim completion script
                            " Language:	HTML and XHTML
                            " Maintainer:	Mikolaj Machowski ( mikmach AT wp DOT pl )
                            " Last Change:	2014 Jun 20
                            
                            " Distinguish between HTML versions.
                            " To use with other HTML versions add another "elseif" condition to match
                            " proper DOCTYPE.
    1              0.000010 function! htmlcomplete#DetectOmniFlavor()
                              if &filetype == 'xhtml'
                                let b:html_omni_flavor = 'xhtml10s'
                              else
                                let b:html_omni_flavor = 'html401t'
                              endif
                              let i = 1
                              let line = ""
                              while i < 10 && i < line("$")
                                let line = getline(i)
                                if line =~ '<!DOCTYPE.*\<DTD '
                                  break
                                endif
                                let i += 1
                              endwhile
                              if line =~ '<!DOCTYPE.*\<DTD '  " doctype line found above
                                if line =~ ' HTML 3\.2'
                                  let b:html_omni_flavor = 'html32'
                                elseif line =~ ' XHTML 1\.1'
                                  let b:html_omni_flavor = 'xhtml11'
                                else    " two-step detection with strict/frameset/transitional
                                  if line =~ ' XHTML 1\.0'
                            	let b:html_omni_flavor = 'xhtml10'
                                  elseif line =~ ' HTML 4\.01'
                            	let b:html_omni_flavor = 'html401'
                                  elseif line =~ ' HTML 4.0\>'
                            	let b:html_omni_flavor = 'html40'
                                  endif
                                  if line =~ '\<Transitional\>'
                            	let b:html_omni_flavor .= 't'
                                  elseif line =~ '\<Frameset\>'
                            	let b:html_omni_flavor .= 'f'
                                  else
                            	let b:html_omni_flavor .= 's'
                                  endif
                                endif
                              endif
                            endfunction
                            
    1              0.000005 function! htmlcomplete#CompleteTags(findstart, base)
                              if a:findstart
                                " locate the start of the word
                                let line = getline('.')
                                let start = col('.') - 1
                            	let curline = line('.')
                            	let compl_begin = col('.') - 2
                                while start >= 0 && line[start - 1] =~ '\(\k\|[!:.-]\)'
                            		let start -= 1
                                endwhile
                            	" Handling of entities {{{
                            	if start >= 0 && line[start - 1] =~ '&'
                            		let b:entitiescompl = 1
                            		let b:compl_context = ''
                            		return start
                            	endif
                            	" }}}
                            	" Handling of <style> tag {{{
                            	let stylestart = searchpair('<style\>', '', '<\/style\>', "bnW")
                            	let styleend   = searchpair('<style\>', '', '<\/style\>', "nW")
                            	if stylestart != 0 && styleend != 0
                            		if stylestart <= curline && styleend >= curline
                            			let start = col('.') - 1
                            			let b:csscompl = 1
                            			while start >= 0 && line[start - 1] =~ '\(\k\|-\)'
                            				let start -= 1
                            			endwhile
                            		endif
                            	endif
                            	" }}}
                            	" Handling of <script> tag {{{
                            	let scriptstart = searchpair('<script\>', '', '<\/script\>', "bnW")
                            	let scriptend   = searchpair('<script\>', '', '<\/script\>', "nW")
                            	if scriptstart != 0 && scriptend != 0
                            		if scriptstart <= curline && scriptend >= curline
                            			let start = col('.') - 1
                            			let b:jscompl = 1
                            			let b:jsrange = [scriptstart, scriptend]
                            			while start >= 0 && line[start - 1] =~ '\k'
                            				let start -= 1
                            			endwhile
                            			" We are inside of <script> tag. But we should also get contents
                            			" of all linked external files and (secondary, less probably) other <script> tags
                            			" This logic could possible be done in separate function - may be
                            			" reused in events scripting (also with option could be reused for
                            			" CSS
                            			let b:js_extfiles = []
                            			let l = line('.')
                            			let c = col('.')
                            			call cursor(1,1)
                            			while search('<\@<=script\>', 'W') && line('.') <= l
                            				if synIDattr(synID(line('.'),col('.')-1,0),"name") !~? 'comment'
                            					let sname = matchstr(getline('.'), '<script[^>]*src\s*=\s*\([''"]\)\zs.\{-}\ze\1')
                            					if filereadable(sname)
                            						let b:js_extfiles += readfile(sname)
                            					endif
                            				endif
                            			endwhile
                            			call cursor(1,1)
                            			let js_scripttags = []
                            			while search('<script\>', 'W') && line('.') < l
                            				if matchstr(getline('.'), '<script[^>]*src') == ''
                            					let js_scripttag = getline(line('.'), search('</script>', 'W'))
                            					let js_scripttags += js_scripttag
                            				endif
                            			endwhile
                            			let b:js_extfiles += js_scripttags
                            			call cursor(l,c)
                            			unlet! l c
                            		endif
                            	endif
                            	" }}}
                            	if !exists("b:csscompl") && !exists("b:jscompl")
                            		let b:compl_context = getline('.')[0:(compl_begin)]
                            		if b:compl_context !~ '<[^>]*$'
                            			" Look like we may have broken tag. Check previous lines.
                            			let i = 1
                            			while 1
                            				let context_line = getline(curline-i)
                            				if context_line =~ '<[^>]*$'
                            					" Yep, this is this line
                            					let context_lines = getline(curline-i, curline-1) + [b:compl_context]
                            					let b:compl_context = join(context_lines, ' ')
                            					break
                            				elseif context_line =~ '>[^<]*$' || i == curline
                            					" We are in normal tag line, no need for completion at all
                            					" OR reached first line without tag at all
                            					let b:compl_context = ''
                            					break
                            				endif
                            				let i += 1
                            			endwhile
                            			" Make sure we don't have counter
                            			unlet! i
                            		endif
                            		let b:compl_context = matchstr(b:compl_context, '.*\zs<.*')
                            
                            		" Return proper start for on-events. Without that beginning of
                            		" completion will be badly reported
                            		if b:compl_context =~? 'on[a-z]*\s*=\s*\(''[^'']*\|"[^"]*\)$'
                            			let start = col('.') - 1
                            			while start >= 0 && line[start - 1] =~ '\k'
                            				let start -= 1
                            			endwhile
                            		endif
                            		" If b:compl_context begins with <? we are inside of PHP code. It
                            		" wasn't closed so PHP completion passed it to HTML
                            		if &filetype =~? 'php' && b:compl_context =~ '^<?'
                            			let b:phpcompl = 1
                            			let start = col('.') - 1
                            			while start >= 0 && line[start - 1] =~ '[a-zA-Z_0-9\x7f-\xff$]'
                            				let start -= 1
                            			endwhile
                            		endif
                            	else
                            		let b:compl_context = getline('.')[0:compl_begin]
                            	endif
                                return start
                              else
                            	" Initialize base return lists
                                let res = []
                                let res2 = []
                            	" a:base is very short - we need context
                            	let context = b:compl_context
                            	" Check if we should do CSS completion inside of <style> tag
                            	" or JS completion inside of <script> tag or PHP completion in case of <?
                            	" tag AND &ft==php
                            	if exists("b:csscompl")
                            		unlet! b:csscompl
                            		let context = b:compl_context
                            		unlet! b:compl_context
                            		return csscomplete#CompleteCSS(0, context)
                            	elseif exists("b:jscompl")
                            		unlet! b:jscompl
                            		return javascriptcomplete#CompleteJS(0, a:base)
                            	elseif exists("b:phpcompl")
                            		unlet! b:phpcompl
                            		let context = b:compl_context
                            		return phpcomplete#CompletePHP(0, a:base)
                            	else
                            		if len(b:compl_context) == 0 && !exists("b:entitiescompl")
                            			return []
                            		endif
                            		let context = matchstr(b:compl_context, '.\zs.*')
                            	endif
                            	unlet! b:compl_context
                            	" Entities completion {{{
                            	if exists("b:entitiescompl")
                            		unlet! b:entitiescompl
                            
                            		if !exists("b:html_doctype")
                            			call htmlcomplete#CheckDoctype()
                            		endif
                            		if !exists("b:html_omni")
                            			"runtime! autoload/xml/xhtml10s.vim
                            			call htmlcomplete#LoadData()
                            		endif
                            
                            	    let entities =  b:html_omni['vimxmlentities']
                            
                            		if len(a:base) == 1
                            			for m in entities
                            				if m =~ '^'.a:base
                            					call add(res, m.';')
                            				endif
                            			endfor
                            			return res
                            		else
                            			for m in entities
                            				if m =~? '^'.a:base
                            					call add(res, m.';')
                            				elseif m =~? a:base
                            					call add(res2, m.';')
                            				endif
                            			endfor
                            
                            			return res + res2
                            		endif
                            
                            
                            	endif
                            	" }}}
                            	if context =~ '>'
                            		" Generally if context contains > it means we are outside of tag and
                            		" should abandon action - with one exception: <style> span { bo
                            		if context =~ 'style[^>]\{-}>[^<]\{-}$'
                            			return csscomplete#CompleteCSS(0, context)
                            		elseif context =~ 'script[^>]\{-}>[^<]\{-}$'
                            			let b:jsrange = [line('.'), search('<\/script\>', 'nW')]
                            			return javascriptcomplete#CompleteJS(0, context)
                            		else
                            			return []
                            		endif
                            	endif
                            
                            	" If context contains > it means we are already outside of tag and we
                            	" should abandon action
                            	" If context contains white space it is attribute.
                            	" It can be also value of attribute.
                            	" We have to get first word to offer proper completions
                            	if context == ''
                            		let tag = ''
                            	else
                            		let tag = split(context)[0]
                            		" Detect if tag is uppercase to return in proper case,
                            		" we need to make it lowercase for processing
                            		if tag =~ '^[A-Z]*$'
                            			let uppercase_tag = 1
                            			let tag = tolower(tag)
                            		else
                            			let uppercase_tag = 0
                            		endif
                            	endif
                            	" Get last word, it should be attr name
                            	let attr = matchstr(context, '.*\s\zs.*')
                            	" Possible situations where any prediction would be difficult:
                            	" 1. Events attributes
                            	if context =~ '\s'
                            		" Sort out style, class, and on* cases
                            		if context =~? "\\(on[a-z]*\\|id\\|style\\|class\\)\\s*=\\s*[\"']"
                            			" Id, class completion {{{
                            			if context =~? "\\(id\\|class\\)\\s*=\\s*[\"'][a-zA-Z0-9_ -]*$"
                            				if context =~? "class\\s*=\\s*[\"'][a-zA-Z0-9_ -]*$"
                            					let search_for = "class"
                            				elseif context =~? "id\\s*=\\s*[\"'][a-zA-Z0-9_ -]*$"
                            					let search_for = "id"
                            				endif
                            				" Handle class name completion
                            				" 1. Find lines of <link stylesheet>
                            				" 1a. Check file for @import
                            				" 2. Extract filename(s?) of stylesheet,
                            				call cursor(1,1)
                            				let head = getline(search('<head\>'), search('<\/head>'))
                            				let headjoined = join(copy(head), ' ')
                            				if headjoined =~ '<style'
                            					" Remove possibly confusing CSS operators
                            					let stylehead = substitute(headjoined, '+>\*[,', ' ', 'g')
                            					if search_for == 'class'
                            						let styleheadlines = split(stylehead)
                            						let headclasslines = filter(copy(styleheadlines), "v:val =~ '\\([a-zA-Z0-9:]\\+\\)\\?\\.[a-zA-Z0-9_-]\\+'")
                            					else
                            						let stylesheet = split(headjoined, '[{}]')
                            						" Get all lines which fit id syntax
                            						let classlines = filter(copy(stylesheet), "v:val =~ '#[a-zA-Z0-9_-]\\+'")
                            						" Filter out possible color definitions
                            						call filter(classlines, "v:val !~ ':\\s*#[a-zA-Z0-9_-]\\+'")
                            						" Filter out complex border definitions
                            						call filter(classlines, "v:val !~ '\\(none\\|hidden\\|dotted\\|dashed\\|solid\\|double\\|groove\\|ridge\\|inset\\|outset\\)\\s*#[a-zA-Z0-9_-]\\+'")
                            						let templines = join(classlines, ' ')
                            						let headclasslines = split(templines)
                            						call filter(headclasslines, "v:val =~ '#[a-zA-Z0-9_-]\\+'")
                            					endif
                            					let internal = 1
                            				else
                            					let internal = 0
                            				endif
                            				let styletable = []
                            				let secimportfiles = []
                            				let filestable = filter(copy(head), "v:val =~ '\\(@import\\|link.*stylesheet\\)'")
                            				for line in filestable
                            					if line =~ "@import"
                            						let styletable += [matchstr(line, "import\\s\\+\\(url(\\)\\?[\"']\\?\\zs\\f\\+\\ze")]
                            					elseif line =~ "<link"
                            						let styletable += [matchstr(line, "href\\s*=\\s*[\"']\\zs\\f\\+\\ze")]
                            					endif
                            				endfor
                            				for file in styletable
                            					if filereadable(file)
                            						let stylesheet = readfile(file)
                            						let secimport = filter(copy(stylesheet), "v:val =~ '@import'")
                            						if len(secimport) > 0
                            							for line in secimport
                            								let secfile = matchstr(line, "import\\s\\+\\(url(\\)\\?[\"']\\?\\zs\\f\\+\\ze")
                            								let secfile = fnamemodify(file, ":p:h").'/'.secfile
                            								let secimportfiles += [secfile]
                            							endfor
                            						endif
                            					endif
                            				endfor
                            				let cssfiles = styletable + secimportfiles
                            				let classes = []
                            				for file in cssfiles
                            				  	let classlines = []
                            					if filereadable(file)
                            						let stylesheet = readfile(file)
                            						let stylefile = join(stylesheet, ' ')
                            						let stylefile = substitute(stylefile, '+>\*[,', ' ', 'g')
                            						if search_for == 'class'
                            							let stylesheet = split(stylefile)
                            							let classlines = filter(copy(stylesheet), "v:val =~ '\\([a-zA-Z0-9:]\\+\\)\\?\\.[a-zA-Z0-9_-]\\+'")
                            						else
                            							let stylesheet = split(stylefile, '[{}]')
                            							" Get all lines which fit id syntax
                            							let classlines = filter(copy(stylesheet), "v:val =~ '#[a-zA-Z0-9_-]\\+'")
                            							" Filter out possible color definitions
                            							call filter(classlines, "v:val !~ ':\\s*#[a-zA-Z0-9_-]\\+'")
                            							" Filter out complex border definitions
                            							call filter(classlines, "v:val !~ '\\(none\\|hidden\\|dotted\\|dashed\\|solid\\|double\\|groove\\|ridge\\|inset\\|outset\\)\\s*#[a-zA-Z0-9_-]\\+'")
                            							let templines = join(classlines, ' ')
                            							let stylelines = split(templines)
                            							let classlines = filter(stylelines, "v:val =~ '#[a-zA-Z0-9_-]\\+'")
                            
                            						endif
                            					endif
                            					" We gathered classes definitions from all external files
                            					let classes += classlines
                            				endfor
                            				if internal == 1
                            					let classes += headclasslines
                            				endif
                            
                            				if search_for == 'class'
                            					let elements = {}
                            					for element in classes
                            						if element =~ '^\.'
                            							let class = matchstr(element, '^\.\zs[a-zA-Z][a-zA-Z0-9_-]*\ze')
                            							let class = substitute(class, ':.*', '', '')
                            							if has_key(elements, 'common')
                            								let elements['common'] .= ' '.class
                            							else
                            								let elements['common'] = class
                            							endif
                            						else
                            							let class = matchstr(element, '[a-zA-Z1-6]*\.\zs[a-zA-Z][a-zA-Z0-9_-]*\ze')
                            							let tagname = tolower(matchstr(element, '[a-zA-Z1-6]*\ze.'))
                            							if tagname != ''
                            								if has_key(elements, tagname)
                            									let elements[tagname] .= ' '.class
                            								else
                            									let elements[tagname] = class
                            								endif
                            							endif
                            						endif
                            					endfor
                            
                            					if has_key(elements, tag) && has_key(elements, 'common')
                            						let values = split(elements[tag]." ".elements['common'])
                            					elseif has_key(elements, tag) && !has_key(elements, 'common')
                            						let values = split(elements[tag])
                            					elseif !has_key(elements, tag) && has_key(elements, 'common')
                            						let values = split(elements['common'])
                            					else
                            						return []
                            					endif
                            
                            				elseif search_for == 'id'
                            					" Find used IDs
                            					" 1. Catch whole file
                            					let filelines = getline(1, line('$'))
                            					" 2. Find lines with possible id
                            					let used_id_lines = filter(filelines, 'v:val =~ "id\\s*=\\s*[\"''][a-zA-Z0-9_-]\\+"')
                            					" 3a. Join all filtered lines
                            					let id_string = join(used_id_lines, ' ')
                            					" 3b. And split them to be sure each id is in separate item
                            					let id_list = split(id_string, 'id\s*=\s*')
                            					" 4. Extract id values
                            					let used_id = map(id_list, 'matchstr(v:val, "[\"'']\\zs[a-zA-Z0-9_-]\\+\\ze")')
                            					let joined_used_id = ','.join(used_id, ',').','
                            
                            					let allvalues = map(classes, 'matchstr(v:val, ".*#\\zs[a-zA-Z0-9_-]\\+")')
                            
                            					let values = []
                            
                            					for element in classes
                            						if joined_used_id !~ ','.element.','
                            							let values += [element]
                            						endif
                            
                            					endfor
                            
                            				endif
                            
                            				" We need special version of sbase
                            				let classbase = matchstr(context, ".*[\"']")
                            				let classquote = matchstr(classbase, '.$')
                            
                            				let entered_class = matchstr(attr, ".*=\\s*[\"']\\zs.*")
                            
                            				for m in sort(values)
                            					if m =~? '^'.entered_class
                            						call add(res, m . classquote)
                            					elseif m =~? entered_class
                            						call add(res2, m . classquote)
                            					endif
                            				endfor
                            
                            				return res + res2
                            
                            			elseif context =~? "style\\s*=\\s*[\"'][^\"']*$"
                            				return csscomplete#CompleteCSS(0, context)
                            
                            			endif
                            			" }}}
                            			" Complete on-events {{{
                            			if context =~? 'on[a-z]*\s*=\s*\(''[^'']*\|"[^"]*\)$'
                            				" We have to:
                            				" 1. Find external files
                            				let b:js_extfiles = []
                            				let l = line('.')
                            				let c = col('.')
                            				call cursor(1,1)
                            				while search('<\@<=script\>', 'W') && line('.') <= l
                            					if synIDattr(synID(line('.'),col('.')-1,0),"name") !~? 'comment'
                            						let sname = matchstr(getline('.'), '<script[^>]*src\s*=\s*\([''"]\)\zs.\{-}\ze\1')
                            						if filereadable(sname)
                            							let b:js_extfiles += readfile(sname)
                            						endif
                            					endif
                            				endwhile
                            				" 2. Find at least one <script> tag
                            				call cursor(1,1)
                            				let js_scripttags = []
                            				while search('<script\>', 'W') && line('.') < l
                            					if matchstr(getline('.'), '<script[^>]*src') == ''
                            						let js_scripttag = getline(line('.'), search('</script>', 'W'))
                            						let js_scripttags += js_scripttag
                            					endif
                            				endwhile
                            				let b:js_extfiles += js_scripttags
                            
                            				" 3. Proper call for javascriptcomplete#CompleteJS
                            				call cursor(l,c)
                            				let js_context = matchstr(a:base, '\k\+$')
                            				let js_shortcontext = substitute(a:base, js_context.'$', '', '')
                            				let b:compl_context = context
                            				let b:jsrange = [l, l]
                            				unlet! l c
                            				return javascriptcomplete#CompleteJS(0, js_context)
                            
                            			endif
                            
                            			" }}}
                            			let stripbase = matchstr(context, ".*\\(on[a-zA-Z]*\\|style\\|class\\)\\s*=\\s*[\"']\\zs.*")
                            			" Now we have context stripped from all chars up to style/class.
                            			" It may fail with some strange style value combinations.
                            			if stripbase !~ "[\"']"
                            				return []
                            			endif
                            		endif
                            		" Value of attribute completion {{{
                            		" If attr contains =\s*[\"'] we catched value of attribute
                            		if attr =~ "=\s*[\"']" || attr =~ "=\s*$"
                            			" Let do attribute specific completion
                            			let attrname = matchstr(attr, '.*\ze\s*=')
                            			let entered_value = matchstr(attr, ".*=\\s*[\"']\\?\\zs.*")
                            			let values = []
                            			" Load data {{{
                            			if !exists("b:html_doctype")
                            				call htmlcomplete#CheckDoctype()
                            			endif
                            			if !exists("b:html_omni")
                            				"runtime! autoload/xml/xhtml10s.vim
                            				call htmlcomplete#LoadData()
                            			endif
                            			" }}}
                            			if attrname == 'href'
                            				" Now we are looking for local anchors defined by name or id
                            				if entered_value =~ '^#'
                            					let file = join(getline(1, line('$')), ' ')
                            					" Split it be sure there will be one id/name element in
                            					" item, it will be also first word [a-zA-Z0-9_-] in element
                            					let oneelement = split(file, "\\(meta \\)\\@<!\\(name\\|id\\)\\s*=\\s*[\"']")
                            					for i in oneelement
                            						let values += ['#'.matchstr(i, "^[a-zA-Z][a-zA-Z0-9%_-]*")]
                            					endfor
                            				endif
                            			else
                            				if has_key(b:html_omni, tag) && has_key(b:html_omni[tag][1], attrname)
                            					let values = b:html_omni[tag][1][attrname]
                            				else
                            					return []
                            				endif
                            			endif
                            
                            			if len(values) == 0
                            				return []
                            			endif
                            
                            			" We need special version of sbase
                            			let attrbase = matchstr(context, ".*[\"']")
                            			let attrquote = matchstr(attrbase, '.$')
                            			if attrquote !~ "['\"]"
                            				let attrquoteopen = '"'
                            				let attrquote = '"'
                            			else
                            				let attrquoteopen = ''
                            			endif
                            
                            			for m in values
                            				" This if is needed to not offer all completions as-is
                            				" alphabetically but sort them. Those beginning with entered
                            				" part will be as first choices
                            				if m =~ '^'.entered_value
                            					call add(res, attrquoteopen . m . attrquote)
                            				elseif m =~ entered_value
                            					call add(res2, attrquoteopen . m . attrquote)
                            				endif
                            			endfor
                            
                            			return res + res2
                            
                            		endif
                            		" }}}
                            		" Attribute completion {{{
                            		" Shorten context to not include last word
                            		let sbase = matchstr(context, '.*\ze\s.*')
                            
                            		" Load data {{{
                            		if !exists("b:html_doctype")
                            			call htmlcomplete#CheckDoctype()
                            		endif
                            		if !exists("b:html_omni")
                            			call htmlcomplete#LoadData()
                            		endif
                            		" }}}
                            
                            		if has_key(b:html_omni, tag)
                            			let attrs = keys(b:html_omni[tag][1])
                            		else
                            			return []
                            		endif
                            
                            		for m in sort(attrs)
                            			if m =~ '^'.attr
                            				call add(res, m)
                            			elseif m =~ attr
                            				call add(res2, m)
                            			endif
                            		endfor
                            		let menu = res + res2
                            		if has_key(b:html_omni, 'vimxmlattrinfo')
                            			let final_menu = []
                            			for i in range(len(menu))
                            				let item = menu[i]
                            				if has_key(b:html_omni['vimxmlattrinfo'], item)
                            					let m_menu = b:html_omni['vimxmlattrinfo'][item][0]
                            					let m_info = b:html_omni['vimxmlattrinfo'][item][1]
                            				else
                            					let m_menu = ''
                            					let m_info = ''
                            				endif
                            				if len(b:html_omni[tag][1][item]) > 0 && b:html_omni[tag][1][item][0] =~ '^\(BOOL\|'.item.'\)$'
                            					let item = item
                            					let m_menu = 'Bool'
                            				else
                            					let item .= '="'
                            				endif
                            				let final_menu += [{'word':item, 'menu':m_menu, 'info':m_info}]
                            			endfor
                            		else
                            			let final_menu = []
                            			for i in range(len(menu))
                            				let item = menu[i]
                            				if len(b:html_omni[tag][1][item]) > 0 && b:html_omni[tag][1][item][0] =~ '^\(BOOL\|'.item.'\)$'
                            					let item = item
                            				else
                            					let item .= '="'
                            				endif
                            				let final_menu += [item]
                            			endfor
                            			return final_menu
                            
                            		endif
                            		return final_menu
                            
                            	endif
                            	" }}}
                            	" Close tag {{{
                            	let b:unaryTagsStack = "base meta link hr br param img area input col"
                            	if context =~ '^\/'
                            		if context =~ '^\/.'
                            			return []
                            		else
                            			let opentag = xmlcomplete#GetLastOpenTag("b:unaryTagsStack")
                            			return [opentag.">"]
                            		endif
                            	endif
                            	" }}}
                            	" Load data {{{
                            	if !exists("b:html_doctype")
                            		call htmlcomplete#CheckDoctype()
                            	endif
                            	if !exists("b:html_omni")
                            		"runtime! autoload/xml/xhtml10s.vim
                            		call htmlcomplete#LoadData()
                            	endif
                            	" }}}
                            	" Tag completion {{{
                            	" Deal with tag completion.
                            	let opentag = tolower(xmlcomplete#GetLastOpenTag("b:unaryTagsStack"))
                            	" MM: TODO: GLOT works always the same but with some weird situation it
                            	" behaves as intended in HTML but screws in PHP
                            	if opentag == '' || &filetype == 'php' && !has_key(b:html_omni, opentag)
                            		" Hack for sometimes failing GetLastOpenTag.
                            		" As far as I tested fail isn't GLOT fault but problem
                            		" of invalid document - not properly closed tags and other mish-mash.
                            		" Also when document is empty. Return list of *all* tags.
                            	    let tags = keys(b:html_omni)
                            		call filter(tags, 'v:val !~ "^vimxml"')
                            	else
                            		if has_key(b:html_omni, opentag)
                            			let tags = b:html_omni[opentag][0]
                            		else
                            			return []
                            		endif
                            	endif
                            	" }}}
                            
                            	if exists("uppercase_tag") && uppercase_tag == 1
                            		let context = tolower(context)
                            	endif
                            	" Handle XML keywords: DOCTYPE
                            	if opentag == ''
                            		let tags += [
                            				\ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">',
                            				\ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">',
                            				\ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">',
                            				\ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN" "http://www.w3.org/TR/REC-html40/frameset.dtd">',
                            				\ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">',
                            				\ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">',
                            				\ '!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd">',
                            				\ '!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">',
                            				\ '!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">',
                            				\ '!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">',
                            				\ '!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/1999/xhtml">'
                            				\ ]
                            	endif
                            
                            	for m in sort(tags)
                            		if m =~ '^'.context
                            			call add(res, m)
                            		elseif m =~ context
                            			call add(res2, m)
                            		endif
                            	endfor
                            	let menu = res + res2
                            	if has_key(b:html_omni, 'vimxmltaginfo')
                            		let final_menu = []
                            		for i in range(len(menu))
                            			let item = menu[i]
                            			if has_key(b:html_omni['vimxmltaginfo'], item)
                            				let m_menu = b:html_omni['vimxmltaginfo'][item][0]
                            				let m_info = b:html_omni['vimxmltaginfo'][item][1]
                            			else
                            				let m_menu = ''
                            				let m_info = ''
                            			endif
                            			if &filetype == 'html' && exists("uppercase_tag") && uppercase_tag == 1 && item !~ 'DOCTYPE'
                            				let item = toupper(item)
                            			endif
                            			if item =~ 'DOCTYPE'
                            				let abbr = 'DOCTYPE '.matchstr(item, 'DTD \zsX\?HTML .\{-}\ze\/\/')
                            			else
                            				let abbr = item
                            			endif
                            			let final_menu += [{'abbr':abbr, 'word':item, 'menu':m_menu, 'info':m_info}]
                            		endfor
                            	else
                            		let final_menu = menu
                            	endif
                            	return final_menu
                            
                            	" }}}
                              endif
                            endfunction
                            
    1              0.000007 function! htmlcomplete#LoadData() " {{{
                            	if !exists("b:html_omni_flavor")
                            		if &filetype == 'html'
                            			let b:html_omni_flavor = 'html401t'
                            		else
                            			let b:html_omni_flavor = 'xhtml10s'
                            		endif
                            	endif
                            	" With that if we still have bloated memory but create new buffer
                            	" variables only by linking to existing g:variable, not sourcing whole
                            	" file.
                            	if exists('g:xmldata_'.b:html_omni_flavor)
                            		exe 'let b:html_omni = g:xmldata_'.b:html_omni_flavor
                            	else
                            		exe 'runtime! autoload/xml/'.b:html_omni_flavor.'.vim'
                            		exe 'let b:html_omni = g:xmldata_'.b:html_omni_flavor
                            	endif
                            endfunction
                            " }}}
    1              0.000003 function! htmlcomplete#CheckDoctype() " {{{
                            	if exists('b:html_omni_flavor')
                            		let old_flavor = b:html_omni_flavor
                            	else
                            		let old_flavor = ''
                            	endif
                            	let i = 1
                            	while i < 10 && i < line("$")
                            		let line = getline(i)
                            		if line =~ '<!DOCTYPE.*\<DTD HTML 3\.2'
                            			let b:html_omni_flavor = 'html32'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.0 Transitional'
                            			let b:html_omni_flavor = 'html40t'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.0 Frameset'
                            			let b:html_omni_flavor = 'html40f'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.0'
                            			let b:html_omni_flavor = 'html40s'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.01 Transitional'
                            			let b:html_omni_flavor = 'html401t'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.01 Frameset'
                            			let b:html_omni_flavor = 'html401f'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD HTML 4\.01'
                            			let b:html_omni_flavor = 'html401s'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD XHTML 1\.0 Transitional'
                            			let b:html_omni_flavor = 'xhtml10t'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD XHTML 1\.0 Frameset'
                            			let b:html_omni_flavor = 'xhtml10f'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD XHTML 1\.0 Strict'
                            			let b:html_omni_flavor = 'xhtml10s'
                            			let b:html_doctype = 1
                            			break
                            		elseif line =~ '<!DOCTYPE.*\<DTD XHTML 1\.1'
                            			let b:html_omni_flavor = 'xhtml11'
                            			let b:html_doctype = 1
                            			break
                            		endif
                            		let i += 1
                            	endwhile
                            	if !exists("b:html_doctype")
                            		return
                            	else
                            		" Tie g:xmldata with b:html_omni this way we need to sourca data file only
                            		" once, not every time per buffer.
                            		if old_flavor == b:html_omni_flavor
                            			return
                            		else
                            			if exists('g:xmldata_'.b:html_omni_flavor)
                            				exe 'let b:html_omni = g:xmldata_'.b:html_omni_flavor
                            			else
                            				exe 'runtime! autoload/xml/'.b:html_omni_flavor.'.vim'
                            				exe 'let b:html_omni = g:xmldata_'.b:html_omni_flavor
                            			endif
                            			return
                            		endif
                            	endif
                            endfunction
                            " }}}
                            " vim:set foldmethod=marker:

SCRIPT  /Users/liss/.local/share/nvim/plugged/vim-markdown/after/ftplugin/markdown.vim
Sourced 3 times
Total time:   0.003143
 Self time:   0.003023

count  total (s)   self (s)
                            " vim: ts=4 sw=4:
                            " folding for Markdown headers, both styles (atx- and setex-)
                            " http://daringfireball.net/projects/markdown/syntax#header
                            "
                            " this code can be placed in file
                            "   $HOME/.vim/after/ftplugin/markdown.vim
                            "
                            " original version from Steve Losh's gist: https://gist.github.com/1038710
                            
    3              0.000027 function! s:is_mkdCode(lnum)
                                let name = synIDattr(synID(a:lnum, 1, 0), 'name')
                                return (name =~ '^mkd\%(Code$\|Snippet\)' || name != '' && name !~ '^\%(mkd\|html\)')
                            endfunction
                            
    3              0.000024 if get(g:, "vim_markdown_folding_style_pythonic", 0)
                                function! Foldexpr_markdown(lnum)
                                    let l1 = getline(a:lnum)
                                    "~~~~~ keep track of fenced code blocks ~~~~~
                                    "If we hit a code block fence
                                    if l1 =~ '````*' || l1 =~ '\~\~\~\~*'
                                        " toggle the variable that says if we're in a code block
                                        if b:fenced_block == 0
                                            let b:fenced_block = 1
                                        elseif b:fenced_block == 1
                                            let b:fenced_block = 0
                                        endif
                                    " else, if we're caring about front matter
                                    elseif g:vim_markdown_frontmatter == 1
                                        " if we're in front matter and not on line 1
                                        if b:front_matter == 1 && a:lnum > 2
                                            let l0 = getline(a:lnum-1)
                                            " if the previous line fenced front matter
                                            if l0 == '---'
                                                " we must not be in front matter
                                                let b:front_matter = 0
                                            endif
                                        " else, if we're on line one
                                        elseif a:lnum == 1
                                            " if we hit a front matter fence
                                            if l1 == '---'
                                                " we're in the front matter
                                                let b:front_matter = 1
                                            endif
                                        endif
                                    endif
                            
                                    " if we're in a code block or front matter
                                    if b:fenced_block == 1 || b:front_matter == 1
                                        if a:lnum == 1
                                            " fold any 'preamble'
                                            return '>1'
                                        else
                                            " keep previous foldlevel
                                            return '='
                                        endif
                                    endif
                            
                                    let l2 = getline(a:lnum+1)
                                    " if the next line starts with two or more '='
                                    " and is not code
                                    if l2 =~ '^==\+\s*' && !s:is_mkdCode(a:lnum+1)
                                        " next line is underlined (level 1)
                                        return '>0'
                                    " else, if the nex line starts with two or more '-'
                                    " and is not code
                                    elseif l2 =~ '^--\+\s*' && !s:is_mkdCode(a:lnum+1)
                                        " next line is underlined (level 2)
                                        return '>1'
                                    endif
                            
                                    "if we're on a non-code line starting with a pound sign
                                    if l1 =~ '^#' && !s:is_mkdCode(a:lnum)
                                        " set the fold level to the number of hashes -1
                                        " return '>'.(matchend(l1, '^#\+') - 1)
                                        " set the fold level to the number of hashes
                                        return '>'.(matchend(l1, '^#\+'))
                                    " else, if we're on line 1
                                    elseif a:lnum == 1
                                        " fold any 'preamble'
                                        return '>1'
                                    else
                                        " keep previous foldlevel
                                        return '='
                                    endif
                                endfunction
                            
                                function! Foldtext_markdown()
                                    let line = getline(v:foldstart)
                                    let has_numbers = &number || &relativenumber
                                    let nucolwidth = &fdc + has_numbers * &numberwidth
                                    let windowwidth = winwidth(0) - nucolwidth - 6
                                    let foldedlinecount = v:foldend - v:foldstart
                                    let line = strpart(line, 0, windowwidth - 2 -len(foldedlinecount))
                                    let line = substitute(line, '\%("""\|''''''\)', '', '')
                                    let fillcharcount = windowwidth - len(line) - len(foldedlinecount) + 1
                                    return line . ' ' . repeat("-", fillcharcount) . ' ' . foldedlinecount
                                endfunction
                            else " vim_markdown_folding_style_pythonic == 0
    3              0.000008     function! Foldexpr_markdown(lnum)
                                    if (a:lnum == 1)
                                        let l0 = ''
                                    else
                                        let l0 = getline(a:lnum-1)
                                    endif
                            
                                    " keep track of fenced code blocks
                                    if l0 =~ '````*' || l0 =~ '\~\~\~\~*'
                                        if b:fenced_block == 0
                                            let b:fenced_block = 1
                                        elseif b:fenced_block == 1
                                            let b:fenced_block = 0
                                        endif
                                    elseif g:vim_markdown_frontmatter == 1
                                        if b:front_matter == 1
                                            if l0 == '---'
                                                let b:front_matter = 0
                                            endif
                                        elseif a:lnum == 2
                                            if l0 == '---'
                                                let b:front_matter = 1
                                            endif
                                        endif
                                    endif
                            
                                    if b:fenced_block == 1 || b:front_matter == 1
                                        " keep previous foldlevel
                                        return '='
                                    endif
                            
                                    let l2 = getline(a:lnum+1)
                                    if  l2 =~ '^==\+\s*' && !s:is_mkdCode(a:lnum+1)
                                        " next line is underlined (level 1)
                                        return '>1'
                                    elseif l2 =~ '^--\+\s*' && !s:is_mkdCode(a:lnum+1)
                                        " next line is underlined (level 2)
                                        if s:vim_markdown_folding_level >= 2
                                            return '>1'
                                        else
                                            return '>2'
                                        endif
                                    endif
                            
                                    let l1 = getline(a:lnum)
                                    if l1 =~ '^#' && !s:is_mkdCode(a:lnum)
                                        " fold level according to option
                                        if s:vim_markdown_folding_level == 1 || matchend(l1, '^#\+') > s:vim_markdown_folding_level
                                            if a:lnum == line('$')
                                                return matchend(l1, '^#\+') - 1
                                            else
                                                return -1
                                            endif
                                        else
                                            " headers are not folded
                                            return 0
                                        endif
                                    endif
                            
                                    if l0 =~ '^#' && !s:is_mkdCode(a:lnum-1)
                                        " previous line starts with hashes
                                        return '>'.matchend(l0, '^#\+')
                                    else
                                        " keep previous foldlevel
                                        return '='
                                    endif
                                endfunction
    3              0.000006 endif
                            
                            
    3              0.000303 let b:fenced_block = 0
    3              0.000023 let b:front_matter = 0
    3              0.000022 let s:vim_markdown_folding_level = get(g:, "vim_markdown_folding_level", 1)
                            
    3              0.000011 function! s:MarkdownSetupFolding()
                                if !get(g:, "vim_markdown_folding_disabled", 0)
                                    if get(g:, "vim_markdown_folding_style_pythonic", 0)
                                        if get(g:, "vim_markdown_override_foldtext", 1)
                                            setlocal foldtext=Foldtext_markdown()
                                        endif
                                    endif
                                    setlocal foldexpr=Foldexpr_markdown(v:lnum)
                                    setlocal foldmethod=expr
                                endif
                            endfunction
                            
    3              0.000009 function! s:MarkdownSetupFoldLevel()
                                if get(g:, "vim_markdown_folding_style_pythonic", 0)
                                    " set default foldlevel
                                    execute "setlocal foldlevel=".s:vim_markdown_folding_level
                                endif
                            endfunction
                            
    3   0.000244   0.000212 call s:MarkdownSetupFoldLevel()
    3   0.000278   0.000191 call s:MarkdownSetupFolding()
                            
    3              0.000013 augroup Mkd
                                " These autocmds need to be kept in sync with the autocmds calling
                                " s:MarkdownRefreshSyntax in ftplugin/markdown.vim.
    3              0.000049     autocmd BufWinEnter,BufWritePost <buffer> call s:MarkdownSetupFolding()
    3              0.000022     autocmd InsertEnter,InsertLeave <buffer> call s:MarkdownSetupFolding()
    3              0.000014     autocmd CursorHold,CursorHoldI <buffer> call s:MarkdownSetupFolding()
    3              0.000015 augroup END

SCRIPT  /Users/liss/.local/share/nvim/plugged/vim-markdown/indent/markdown.vim
Sourced 3 times
Total time:   0.000552
 Self time:   0.000552

count  total (s)   self (s)
    3              0.000032 if exists("b:did_indent") | finish | endif
    3              0.000008 let b:did_indent = 1
                            
    3              0.000020 setlocal indentexpr=GetMarkdownIndent()
    3              0.000035 setlocal nolisp
    3              0.000008 setlocal autoindent
                            
                            " Automatically continue blockquote on line break
    3              0.000011 setlocal formatoptions+=r
    3              0.000011 setlocal comments=b:>
    3              0.000012 if get(g:, "vim_markdown_auto_insert_bullets", 1)
                                " Do not automatically insert bullets when auto-wrapping with text-width
    3              0.000010     setlocal formatoptions-=c
                                " Accept various markers as bullets
    3              0.000010     setlocal comments+=b:*,b:+,b:-
    3              0.000002 endif
                            
                            " Only define the function once
    3              0.000014 if exists("*GetMarkdownIndent") | finish | endif
                            
    1              0.000003 function! s:IsMkdCode(lnum)
                                let name = synIDattr(synID(a:lnum, 1, 0), 'name')
                                return (name =~ '^mkd\%(Code$\|Snippet\)' || name != '' && name !~ '^\%(mkd\|html\)')
                            endfunction
                            
    1              0.000001 function! s:IsLiStart(line)
                                return a:line !~ '^ *\([*-]\)\%( *\1\)\{2}\%( \|\1\)*$' &&
                                  \    a:line =~ '^\s*[*+-] \+'
                            endfunction
                            
    1              0.000001 function! s:IsHeaderLine(line)
                                return a:line =~ '^\s*#'
                            endfunction
                            
    1              0.000001 function! s:IsBlankLine(line)
                                return a:line =~ '^$'
                            endfunction
                            
    1              0.000001 function! s:PrevNonBlank(lnum)
                                let i = a:lnum
                                while i > 1 && s:IsBlankLine(getline(i))
                                    let i -= 1
                                endwhile
                                return i
                            endfunction
                            
    1              0.000002 function GetMarkdownIndent()
                                if v:lnum > 2 && s:IsBlankLine(getline(v:lnum - 1)) && s:IsBlankLine(getline(v:lnum - 2))
                                    return 0
                                endif
                                let list_ind = get(g:, "vim_markdown_new_list_item_indent", 4)
                                " Find a non-blank line above the current line.
                                let lnum = s:PrevNonBlank(v:lnum - 1)
                                " At the start of the file use zero indent.
                                if lnum == 0 | return 0 | endif
                                let ind = indent(lnum)
                                let line = getline(lnum)    " Last line
                                let cline = getline(v:lnum) " Current line
                                if s:IsLiStart(cline)
                                    " Current line is the first line of a list item, do not change indent
                                    return indent(v:lnum)
                                elseif s:IsHeaderLine(cline) && !s:IsMkdCode(v:lnum)
                                    " Current line is the header, do not indent
                                    return 0
                                elseif s:IsLiStart(line)
                                    if s:IsMkdCode(lnum)
                                        return ind
                                    else
                                        " Last line is the first line of a list item, increase indent
                                        return ind + list_ind
                                    end
                                else
                                    return ind
                                endif
                            endfunction

SCRIPT  /usr/local/Cellar/neovim/HEAD-c6cd608/share/nvim/runtime/syntax/markdown.vim
Sourced 2 times
Total time:   0.001320
 Self time:   0.001320

count  total (s)   self (s)
                            " Vim syntax file
                            " Language:     Markdown
                            " Maintainer:   Tim Pope <vimNOSPAM@tpope.org>
                            " Filenames:    *.markdown
                            " Last Change:  2016 Aug 29
                            
    2              0.000031 if exists("b:current_syntax")
    2              0.000007   finish
                            endif
                            
                            if !exists('main_syntax')
                              let main_syntax = 'markdown'
                            endif
                            
                            runtime! syntax/html.vim
                            unlet! b:current_syntax
                            
                            if !exists('g:markdown_fenced_languages')
                              let g:markdown_fenced_languages = []
                            endif
                            for s:type in map(copy(g:markdown_fenced_languages),'matchstr(v:val,"[^=]*$")')
                              if s:type =~ '\.'
                                let b:{matchstr(s:type,'[^.]*')}_subtype = matchstr(s:type,'\.\zs.*')
                              endif
                              exe 'syn include @markdownHighlight'.substitute(s:type,'\.','','g').' syntax/'.matchstr(s:type,'[^.]*').'.vim'
                              unlet! b:current_syntax
                            endfor
                            unlet! s:type
                            
                            syn sync minlines=10
                            syn case ignore
                            
                            syn match markdownValid '[<>]\c[a-z/$!]\@!'
                            syn match markdownValid '&\%(#\=\w*;\)\@!'
                            
                            syn match markdownLineStart "^[<@]\@!" nextgroup=@markdownBlock,htmlSpecialChar
                            
                            syn cluster markdownBlock contains=markdownH1,markdownH2,markdownH3,markdownH4,markdownH5,markdownH6,markdownBlockquote,markdownListMarker,markdownOrderedListMarker,markdownCodeBlock,markdownRule
                            syn cluster markdownInline contains=markdownLineBreak,markdownLinkText,markdownItalic,markdownBold,markdownCode,markdownEscape,@htmlTop,markdownError
                            
                            syn match markdownH1 "^.\+\n=\+$" contained contains=@markdownInline,markdownHeadingRule,markdownAutomaticLink
                            syn match markdownH2 "^.\+\n-\+$" contained contains=@markdownInline,markdownHeadingRule,markdownAutomaticLink
                            
                            syn match markdownHeadingRule "^[=-]\+$" contained
                            
                            syn region markdownH1 matchgroup=markdownHeadingDelimiter start="##\@!"      end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
                            syn region markdownH2 matchgroup=markdownHeadingDelimiter start="###\@!"     end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
                            syn region markdownH3 matchgroup=markdownHeadingDelimiter start="####\@!"    end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
                            syn region markdownH4 matchgroup=markdownHeadingDelimiter start="#####\@!"   end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
                            syn region markdownH5 matchgroup=markdownHeadingDelimiter start="######\@!"  end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
                            syn region markdownH6 matchgroup=markdownHeadingDelimiter start="#######\@!" end="#*\s*$" keepend oneline contains=@markdownInline,markdownAutomaticLink contained
                            
                            syn match markdownBlockquote ">\%(\s\|$\)" contained nextgroup=@markdownBlock
                            
                            syn region markdownCodeBlock start="    \|\t" end="$" contained
                            
                            " TODO: real nesting
                            syn match markdownListMarker "\%(\t\| \{0,4\}\)[-*+]\%(\s\+\S\)\@=" contained
                            syn match markdownOrderedListMarker "\%(\t\| \{0,4}\)\<\d\+\.\%(\s\+\S\)\@=" contained
                            
                            syn match markdownRule "\* *\* *\*[ *]*$" contained
                            syn match markdownRule "- *- *-[ -]*$" contained
                            
                            syn match markdownLineBreak " \{2,\}$"
                            
                            syn region markdownIdDeclaration matchgroup=markdownLinkDelimiter start="^ \{0,3\}!\=\[" end="\]:" oneline keepend nextgroup=markdownUrl skipwhite
                            syn match markdownUrl "\S\+" nextgroup=markdownUrlTitle skipwhite contained
                            syn region markdownUrl matchgroup=markdownUrlDelimiter start="<" end=">" oneline keepend nextgroup=markdownUrlTitle skipwhite contained
                            syn region markdownUrlTitle matchgroup=markdownUrlTitleDelimiter start=+"+ end=+"+ keepend contained
                            syn region markdownUrlTitle matchgroup=markdownUrlTitleDelimiter start=+'+ end=+'+ keepend contained
                            syn region markdownUrlTitle matchgroup=markdownUrlTitleDelimiter start=+(+ end=+)+ keepend contained
                            
                            syn region markdownLinkText matchgroup=markdownLinkTextDelimiter start="!\=\[\%(\_[^]]*]\%( \=[[(]\)\)\@=" end="\]\%( \=[[(]\)\@=" nextgroup=markdownLink,markdownId skipwhite contains=@markdownInline,markdownLineStart
                            syn region markdownLink matchgroup=markdownLinkDelimiter start="(" end=")" contains=markdownUrl keepend contained
                            syn region markdownId matchgroup=markdownIdDelimiter start="\[" end="\]" keepend contained
                            syn region markdownAutomaticLink matchgroup=markdownUrlDelimiter start="<\%(\w\+:\|[[:alnum:]_+-]\+@\)\@=" end=">" keepend oneline
                            
                            let s:concealends = has('conceal') ? ' concealends' : ''
                            exe 'syn region markdownItalic matchgroup=markdownItalicDelimiter start="\S\@<=\*\|\*\S\@=" end="\S\@<=\*\|\*\S\@=" keepend contains=markdownLineStart' . s:concealends
                            exe 'syn region markdownItalic matchgroup=markdownItalicDelimiter start="\S\@<=_\|_\S\@=" end="\S\@<=_\|_\S\@=" keepend contains=markdownLineStart' . s:concealends
                            exe 'syn region markdownBold matchgroup=markdownBoldDelimiter start="\S\@<=\*\*\|\*\*\S\@=" end="\S\@<=\*\*\|\*\*\S\@=" keepend contains=markdownLineStart,markdownItalic' . s:concealends
                            exe 'syn region markdownBold matchgroup=markdownBoldDelimiter start="\S\@<=__\|__\S\@=" end="\S\@<=__\|__\S\@=" keepend contains=markdownLineStart,markdownItalic' . s:concealends
                            exe 'syn region markdownBoldItalic matchgroup=markdownBoldItalicDelimiter start="\S\@<=\*\*\*\|\*\*\*\S\@=" end="\S\@<=\*\*\*\|\*\*\*\S\@=" keepend contains=markdownLineStart' . s:concealends
                            exe 'syn region markdownBoldItalic matchgroup=markdownBoldItalicDelimiter start="\S\@<=___\|___\S\@=" end="\S\@<=___\|___\S\@=" keepend contains=markdownLineStart' . s:concealends
                            
                            syn region markdownCode matchgroup=markdownCodeDelimiter start="`" end="`" keepend contains=markdownLineStart
                            syn region markdownCode matchgroup=markdownCodeDelimiter start="`` \=" end=" \=``" keepend contains=markdownLineStart
                            syn region markdownCode matchgroup=markdownCodeDelimiter start="^\s*```.*$" end="^\s*```\ze\s*$" keepend
                            
                            syn match markdownFootnote "\[^[^\]]\+\]"
                            syn match markdownFootnoteDefinition "^\[^[^\]]\+\]:"
                            
                            if main_syntax ==# 'markdown'
                              for s:type in g:markdown_fenced_languages
                                exe 'syn region markdownHighlight'.substitute(matchstr(s:type,'[^=]*$'),'\..*','','').' matchgroup=markdownCodeDelimiter start="^\s*```\s*'.matchstr(s:type,'[^=]*').'\>.*$" end="^\s*```\ze\s*$" keepend contains=@markdownHighlight'.substitute(matchstr(s:type,'[^=]*$'),'\.','','g')
                              endfor
                              unlet! s:type
                            endif
                            
                            syn match markdownEscape "\\[][\\`*_{}()<>#+.!-]"
                            syn match markdownError "\w\@<=_\w\@="
                            
                            hi def link markdownH1                    htmlH1
                            hi def link markdownH2                    htmlH2
                            hi def link markdownH3                    htmlH3
                            hi def link markdownH4                    htmlH4
                            hi def link markdownH5                    htmlH5
                            hi def link markdownH6                    htmlH6
                            hi def link markdownHeadingRule           markdownRule
                            hi def link markdownHeadingDelimiter      Delimiter
                            hi def link markdownOrderedListMarker     markdownListMarker
                            hi def link markdownListMarker            htmlTagName
                            hi def link markdownBlockquote            Comment
                            hi def link markdownRule                  PreProc
                            
                            hi def link markdownFootnote              Typedef
                            hi def link markdownFootnoteDefinition    Typedef
                            
                            hi def link markdownLinkText              htmlLink
                            hi def link markdownIdDeclaration         Typedef
                            hi def link markdownId                    Type
                            hi def link markdownAutomaticLink         markdownUrl
                            hi def link markdownUrl                   Float
                            hi def link markdownUrlTitle              String
                            hi def link markdownIdDelimiter           markdownLinkDelimiter
                            hi def link markdownUrlDelimiter          htmlTag
                            hi def link markdownUrlTitleDelimiter     Delimiter
                            
                            hi def link markdownItalic                htmlItalic
                            hi def link markdownItalicDelimiter       markdownItalic
                            hi def link markdownBold                  htmlBold
                            hi def link markdownBoldDelimiter         markdownBold
                            hi def link markdownBoldItalic            htmlBoldItalic
                            hi def link markdownBoldItalicDelimiter   markdownBoldItalic
                            hi def link markdownCodeDelimiter         Delimiter
                            
                            hi def link markdownEscape                Special
                            hi def link markdownError                 Error
                            
                            let b:current_syntax = "markdown"
                            if main_syntax ==# 'markdown'
                              unlet main_syntax
                            endif
                            
                            " vim:set sw=2:

SCRIPT  /Users/liss/.local/share/nvim/plugged/vim-pencil/autoload/pencil.vim
Sourced 1 time
Total time:   0.002266
 Self time:   0.002266

count  total (s)   self (s)
                            " ============================================================================
                            " File:        pencil.vim
                            " Description: autoload functions for vim-pencil plugin
                            " Maintainer:  Reed Esau <github.com/reedes>
                            " Created:     December 28, 2013
                            " License:     The MIT License (MIT)
                            " ============================================================================
                            
    1              0.000006 scriptencoding utf-8
                            
    1              0.000012 if exists('autoloaded_pencil') | fini | en
    1              0.000004 let autoloaded_pencil = 1
                            
    1              0.000003 let s:WRAP_MODE_DEFAULT = -1
    1              0.000002 let s:WRAP_MODE_OFF     = 0
    1              0.000001 let s:WRAP_MODE_HARD    = 1
    1              0.000033 let s:WRAP_MODE_SOFT    = 2
                            
                            " Wrap-mode detector
                            " Scan lines at end and beginning of file to determine the wrap mode.
                            " Modelines has priority over long lines found.
    1              0.000006 fun! s:detect_wrap_mode() abort
                            
                              let b:max_textwidth = -1      " assume no relevant modeline
                              call s:doModelines()
                            
                              if b:max_textwidth > 0
                                " modelines(s) found with positive textwidth, so hard line breaks
                                return s:WRAP_MODE_HARD
                              en
                            
                              if b:max_textwidth ==# 0 || g:pencil#wrapModeDefault ==# 'soft'
                                " modeline(s) found only with zero textwidth, so it's soft line wrap
                                " or, the user wants to default to soft line wrap
                                return s:WRAP_MODE_SOFT
                              en
                            
                              " attempt to rule out soft line wrap
                              " scan initial lines in an attempt to detect long lines
                              for l:line in getline(1, g:pencil#softDetectSample)
                                if len(l:line) > g:pencil#softDetectThreshold
                                  return s:WRAP_MODE_SOFT
                                en
                              endfo
                            
                              " punt
                              return s:WRAP_MODE_DEFAULT
                            endf
                            
    1              0.000006 fun! s:imap(preserve_completion, key, icmd) abort
                              if a:preserve_completion
                                exe ':ino <buffer> <silent> <expr> ' . a:key . " pumvisible() ? '" . a:key . "' : '" . a:icmd . "'"
                              el
                                exe ':ino <buffer> <silent> ' . a:key . ' ' . a:icmd
                              en
                            endf
                            
    1              0.000003 fun! s:maybe_enable_autoformat() abort
                              " don't enable autoformat if in a blacklisted code block or table,
                              " allowing for reprieve via whitelist in certain cases
                            
                              " a flag to suspend autoformat for the Insert
                              if b:pencil_suspend_af
                                let b:pencil_suspend_af = 0   " clear the flag
                                return
                              en
                            
                              let l:filetype = get(g:pencil#autoformat_aliases, &filetype, &filetype)
                              let l:af_cfg = get(g:pencil#autoformat_config, l:filetype, {})
                              let l:black = get(l:af_cfg, 'black', [])
                              let l:white = get(l:af_cfg, 'white', [])
                              let l:has_black_re = len(l:black) > 0
                              let l:has_white_re = len(l:white) > 0
                              let l:black_re = l:has_black_re ? '\v(' . join( l:black, '|') . ')' : ''
                              let l:white_re = l:has_white_re ? '\v(' . join( l:white, '|') . ')' : ''
                              let l:enforce_previous_line = get(l:af_cfg, 'enforce-previous-line', 0)
                            
                              let l:okay_to_enable = 1
                              let l:line = line('.')
                              let l:col = col('.')
                              let l:last_col = col('$')
                              let l:stack = []
                              let l:found_empty = 0
                              " at end of line there may be no synstack, so scan back
                              while l:col > 0
                                let l:stack = synstack(l:line, l:col)
                                if l:stack != []
                                  break
                                en
                                " the last column will always be empty, so ignore it
                                if l:col < l:last_col
                                  let l:found_empty = 1
                                en
                                let l:col -= 1
                              endw
                              " if needed, scan towards end of line looking for highlight groups
                              if l:stack == []
                                let l:col = col('.') + 1
                                while l:col <= l:last_col
                                  let l:stack = synstack(l:line, l:col)
                                  if l:stack != []
                                    break
                                  en
                                  " the last column will always be empty, so ignore it
                                  if l:col < l:last_col
                                    let l:found_empty = 1
                                  en
                                  let l:col += 1
                                endw
                              en
                              " enforce blacklist by scanning for syntax matches
                              if l:has_black_re
                                for l:sid in l:stack
                                  if match(synIDattr(l:sid, 'name'), l:black_re) >= 0
                                    let l:okay_to_enable = 0
                                    "echohl WarningMsg
                                    "echo 'hit blacklist line=' . l:line . ' col=' . l:col .
                                    "      \ ' name=' . synIDattr(l:sid, 'name')
                                    "echohl NONE
                                    break
                                  en
                                endfo
                              en
                              " enforce whitelist by detecting inline `markup` for which we DO want
                              " autoformat to be enabled (e.g., tpope's markdownCode)
                              if l:has_white_re && !l:okay_to_enable
                                " one final check for an empty stack at the start and end of line,
                                " either of which greenlights a whitelist check
                                if !l:found_empty
                                  if synstack(l:line, 1) == [] ||
                                    \ (l:last_col > 1 && synstack(l:line, l:last_col-1) == [])
                                    let l:found_empty = 1
                                  en
                                en
                                if l:found_empty
                                  for l:sid in l:stack
                                    if match(synIDattr(l:sid, 'name'), l:white_re) >= 0
                                      let l:okay_to_enable = 1
                                      break
                                    en
                                  endfo
                                en
                              en
                              " disallow enable if start of previous line is in blacklist,
                              if l:has_black_re && l:enforce_previous_line && l:okay_to_enable && l:line > 1
                                let l:prev_stack = synstack(l:line - 1, 1)
                                for l:sid in l:prev_stack
                                  if len(l:sid) > 0 &&
                                          \ match(synIDattr(l:sid, 'name'), l:black_re) >= 0
                                    let l:okay_to_enable = 0
                                    break
                                  en
                                endfo
                              en
                              if l:okay_to_enable
                                set formatoptions+=a
                              en
                            endf
                            
    1              0.000003 fun! pencil#setAutoFormat(af) abort
                              " 1=enable, 0=disable, -1=toggle
                              if !exists('b:last_autoformat')
                                let b:last_autoformat = 0
                              en
                              let l:nu_af = a:af ==# -1 ? !b:last_autoformat : a:af
                              let l:is_hard =
                                 \ exists('b:pencil_wrap_mode') &&
                                 \ b:pencil_wrap_mode ==# s:WRAP_MODE_HARD
                              if l:nu_af && l:is_hard
                                aug pencil_autoformat
                                  au InsertEnter <buffer> call s:maybe_enable_autoformat()
                                  au InsertLeave <buffer> set formatoptions-=a
                                aug END
                              el
                                sil! au! pencil_autoformat * <buffer>
                                if l:nu_af && !l:is_hard
                                  echohl WarningMsg
                                  echo 'autoformat can only be enabled in hard line break mode'
                                  echohl NONE
                                  return
                                en
                              en
                              let b:last_autoformat = l:nu_af
                            endf
                            
                            " Create mappings for word processing
                            " args:
                            "   'wrap': 'detect|off|hard|soft|toggle'
    1              0.000002 fun! pencil#init(...) abort
                              let l:args = a:0 ? a:1 : {}
                            
                              " flag to suspend autoformat for the next Insert
                              let b:pencil_suspend_af = 0
                            
                              if !exists('b:pencil_wrap_mode')
                                let b:pencil_wrap_mode = s:WRAP_MODE_OFF
                              en
                              if !exists('b:max_textwidth')
                                let b:max_textwidth = -1
                              en
                            
                              " If user explicitly requested wrap_mode thru args, go with that.
                              let l:wrap_arg = get(l:args, 'wrap', 'detect')
                            
                              if (b:pencil_wrap_mode && l:wrap_arg ==# 'toggle') ||
                               \ l:wrap_arg =~# '^\(0\|off\|disable\|false\)$'
                                let b:pencil_wrap_mode = s:WRAP_MODE_OFF
                              elsei l:wrap_arg ==# 'hard'
                                let b:pencil_wrap_mode = s:WRAP_MODE_HARD
                              elsei l:wrap_arg ==# 'soft'
                                let b:pencil_wrap_mode = s:WRAP_MODE_SOFT
                              elsei l:wrap_arg ==# 'default'
                                let b:pencil_wrap_mode = s:WRAP_MODE_DEFAULT
                              el
                                " this can return s:WRAP_MODE_ for soft, hard or default
                                let b:pencil_wrap_mode = s:detect_wrap_mode()
                              en
                            
                              " translate default(-1) to soft(1) or hard(2) or off(0)
                              if b:pencil_wrap_mode ==# s:WRAP_MODE_DEFAULT
                                if g:pencil#wrapModeDefault =~# '^\(0\|off\|disable\|false\)$'
                                  let b:pencil_wrap_mode = s:WRAP_MODE_OFF
                                elsei g:pencil#wrapModeDefault ==# 'soft'
                                  let b:pencil_wrap_mode = s:WRAP_MODE_SOFT
                                el
                                  let b:pencil_wrap_mode = s:WRAP_MODE_HARD
                                en
                              en
                            
                              " autoformat is only used in Hard mode, and then only during
                              " Insert mode
                              call pencil#setAutoFormat(
                                    \ b:pencil_wrap_mode ==# s:WRAP_MODE_HARD &&
                                    \ get(l:args, 'autoformat', g:pencil#autoformat))
                            
                              if b:pencil_wrap_mode ==# s:WRAP_MODE_HARD
                                if &modeline ==# 0 && b:max_textwidth > 0
                                  " Compensate for disabled modeline
                                  exe 'setl textwidth=' . b:max_textwidth
                                elsei &textwidth ==# 0
                                  exe 'setl textwidth=' .
                                    \ get(l:args, 'textwidth', g:pencil#textwidth)
                                el
                                  setl textwidth<
                                en
                                setl nowrap
                            
                                " flag to suspend autoformat for next Insert
                                " optional user-defined mapping
                                if exists('g:pencil#map#suspend_af') &&
                                 \ g:pencil#map#suspend_af !=# ''
                                  exe 'no <buffer> <silent> ' . g:pencil#map#suspend_af . ' :let b:pencil_suspend_af=1<CR>'
                                en
                            
                              elsei b:pencil_wrap_mode ==# s:WRAP_MODE_SOFT
                                setl textwidth=0
                                setl wrap
                            
                                if has('linebreak')
                                  setl linebreak
                                  " TODO breakat not working yet with n and m-dash
                                  setl breakat-=*         " avoid breaking footnote*
                                  setl breakat-=@         " avoid breaking at email addresses
                                en
                            
                                if exists('&colorcolumn')
                                  setl colorcolumn=0      " doesn't align as expected
                                en
                              el
                                setl textwidth<
                                setl wrap< nowrap<
                            
                                if has('linebreak')
                                  setl linebreak< nolinebreak<
                                  setl breakat<
                                en
                            
                                if exists('&colorcolumn')
                                  setl colorcolumn<
                                en
                              en
                            
                              if (  v:version > 704 ||
                               \   (v:version ==# 704 && has('patch-7.4.338')))
                                if b:pencil_wrap_mode ==# s:WRAP_MODE_SOFT
                                  setl breakindent
                                el
                                  setl breakindent<
                                en
                              en
                            
                              " global settings
                              if b:pencil_wrap_mode
                                set display+=lastline
                                set backspace=indent,eol,start
                                if get(l:args, 'joinspaces', g:pencil#joinspaces)
                                  set joinspaces         " two spaces after .!?
                                el
                                  set nojoinspaces       " only one space after a .!? (default)
                                en
                              en
                            
                              " because ve=onemore is relatively rare and could break
                              " other plugins, restrict its presence to buffer
                              " Better: restore ve to original setting
                              if has('virtualedit')
                                if b:pencil_wrap_mode && get(l:args, 'cursorwrap', g:pencil#cursorwrap)
                                  set whichwrap+=<,>,b,s,h,l,[,]
                                  aug pencil_cursorwrap
                                    au BufEnter <buffer> set virtualedit+=onemore
                                    au BufLeave <buffer> set virtualedit-=onemore
                                  aug END
                                el
                                  sil! au! pencil_cursorwrap * <buffer>
                                en
                              en
                            
                              " Because syntax for fenced code blocks will mess with the
                              " definition of a word (via iskeyword) we'll impose a prose-
                              " oriented definition.
                              " e.g., let g:markdown_fenced_languages = ['sh',]  " adds '.'
                              "
                              " Support $20 30% D&D #40 highest-rated O'Toole Mary's
                              " TODO how to separate quote from apostrophe use?
                              if b:pencil_wrap_mode
                                aug pencil_iskeyword
                                  au BufEnter <buffer> setl isk& | setl isk-=_ | setl isk+=$,%,&,#,-,',+
                                aug END
                              el
                                sil! au! pencil_iskeyword * <buffer>
                              en
                            
                              " window/buffer settings
                              if b:pencil_wrap_mode
                                setl nolist
                                setl wrapmargin=0
                                setl autoindent         " needed by formatoptions=n
                                setl indentexpr=
                                if has('smartindent')
                                  setl nosmartindent      " avoid c-style indents in prose
                                en
                                if has('cindent')
                                  setl nocindent          " avoid c-style indents in prose
                                en
                            
                                setl formatoptions+=n   " recognize numbered lists
                                setl formatoptions+=1   " don't break line before 1 letter word
                                setl formatoptions+=t   " autoformat of text (vim default)
                                "setl formatoptions+=2   " preserve indent based on 2nd line for rest of paragraph
                            
                                " clean out stuff we likely don't want
                                setl formatoptions-=v   " only break line at blank entered during insert
                                setl formatoptions-=w   " avoid erratic behavior if mixed spaces
                                setl formatoptions-=a   " autoformat will turn on with Insert in HardPencil mode
                                setl formatoptions-=2   " doesn't work with with fo+=n, says docs
                            
                                " plasticboy/vim-markdown sets these to handle bullet points
                                " as comments. Not changing for now.
                                "setl formatoptions-=o   " don't insert comment leader
                                "setl formatoptions-=c   " no autoformat of comments
                                "setl formatoptions+=r   " don't insert comment leader
                            
                                if has('conceal') && v:version >= 703
                                  exe ':setl conceallevel=' .
                                    \ get(l:args, 'conceallevel',  g:pencil#conceallevel)
                                  exe ':setl concealcursor=' .
                                    \ get(l:args, 'concealcursor', g:pencil#concealcursor)
                                en
                              el
                                if has('smartindent')
                                  setl smartindent< nosmartindent<
                                en
                                if has('cindent')
                                  setl cindent< nocindent<
                                en
                                if has('conceal')
                                  setl conceallevel<
                                  setl concealcursor<
                                en
                            
                                setl indentexpr<
                                setl autoindent< noautoindent<
                                setl list< nolist<
                                setl wrapmargin<
                                setl formatoptions<
                              en
                            
                              if b:pencil_wrap_mode ==# s:WRAP_MODE_SOFT
                                exe 'nn <buffer> <silent>' . Mapkey('$', 'n') . ' g$'
                                exe 'nn <buffer> <silent>' . Mapkey('0', 'n') . ' g0'
                                exe 'vn <buffer> <silent>' . Mapkey('$', 'v') . ' g$'
                                exe 'vn <buffer> <silent>' . Mapkey('0', 'v') . ' g0'
                                no <buffer> <silent> <Home> g<Home>
                                no <buffer> <silent> <End>  g<End>
                                nn <buffer> <silent> g0 0
                                nn <buffer> <silent> g$ $
                                vn <buffer> <silent> g0 0
                                vn <buffer> <silent> g$ $
                            
                                " preserve behavior of home/end keys in popups
                                call s:imap(1, '<Home>', '<C-o>g<Home>')
                                call s:imap(1, '<End>' , '<C-o>g<End>' )
                              el
                                sil! nun <buffer> $
                                sil! nun <buffer> 0
                                sil! vu  <buffer> $
                                sil! vu  <buffer> 0
                                sil! nun <buffer> <Home>
                                sil! nun <buffer> <End>
                                sil! iu  <buffer> <Home>
                                sil! iu  <buffer> <End>
                              en
                            
                              if b:pencil_wrap_mode
                                exe 'nn <buffer> <silent> ' . Mapkey('j', 'n') . ' gj'
                                exe 'nn <buffer> <silent> ' . Mapkey('k', 'n') . ' gk'
                                exe 'vn <buffer> <silent> ' . Mapkey('j', 'v') . ' gj'
                                exe 'vn <buffer> <silent> ' . Mapkey('k', 'v') . ' gk'
                                no <buffer> <silent> <Up>   gk
                                no <buffer> <silent> <Down> gj
                                nn <buffer> <silent> gj j
                                nn <buffer> <silent> gk k
                                vn <buffer> <silent> gj j
                                vn <buffer> <silent> gk k
                            
                                " preserve behavior of up/down keys in popups
                                call s:imap(1, '<Up>'  , '<C-o>g<Up>'  )
                                call s:imap(1, '<Down>', '<C-o>g<Down>')
                              el
                                sil! nun <buffer> j
                                sil! nun <buffer> k
                                sil! vu  <buffer> j
                                sil! vu  <buffer> k
                                sil! unm <buffer> <Up>
                                sil! unm <buffer> <Down>
                                sil! nun <buffer> gj j
                                sil! nun <buffer> gk k
                                sil! vu <buffer> gj j
                                sil! vu <buffer> gk k
                            
                                sil! iu <buffer> <Up>
                                sil! iu <buffer> <Down>
                              en
                            
                              " set undo points around common punctuation,
                              " line <c-u> and word <c-w> deletions
                              if b:pencil_wrap_mode
                                ino <buffer> . .<c-g>u
                                ino <buffer> ! !<c-g>u
                                ino <buffer> ? ?<c-g>u
                                ino <buffer> , ,<c-g>u
                                ino <buffer> ; ;<c-g>u
                                ino <buffer> : :<c-g>u
                                ino <buffer> <c-u> <c-g>u<c-u>
                                ino <buffer> <c-w> <c-g>u<c-w>
                            
                                " map <cr> only if not already mapped
                                if empty(maparg('<cr>', 'i'))
                                  ino <buffer> <cr> <c-g>u<cr>
                                  let b:pencil_cr_mapped = 1
                                el
                                  let b:pencil_cr_mapped = 0
                                en
                              el
                                sil! iu <buffer> .
                                sil! iu <buffer> !
                                sil! iu <buffer> ?
                                sil! iu <buffer> ,
                                sil! iu <buffer> ;
                                sil! iu <buffer> :
                                sil! iu <buffer> <c-u>
                                sil! iu <buffer> <c-w>
                            
                                " unmap <cr> only if we mapped it ourselves
                                if exists('b:pencil_cr_mapped') && b:pencil_cr_mapped
                                  sil! iu <buffer> <cr>
                                en
                              en
                            endf
                            
                            " attempt to find a non-zero textwidth, etc.
    1              0.000004 fun! s:doOne(item) abort
                              let l:matches = matchlist(a:item, '^\([a-z]\+\)=\([a-zA-Z0-9_\-.]\+\)$')
                              if len(l:matches) > 1
                                if l:matches[1] =~# 'textwidth\|tw'
                                  let l:tw = str2nr(l:matches[2])
                                  if l:tw > b:max_textwidth
                                    let b:max_textwidth = l:tw
                                  en
                                en
                              en
                            endf
                            
                            " attempt to find a non-zero textwidth, etc.
    1              0.000002 fun! s:doModeline(line) abort
                              let l:matches = matchlist(a:line, '\%(\S\@<!\%(vi\|vim\([<>=]\?\)\([0-9]\+\)\?\)\|\sex\):\s*\%(set\s\+\)\?\([^:]\+\):\S\@!')
                              if len(l:matches) > 0
                                for l:item in split(l:matches[3])
                                  call s:doOne(l:item)
                                endfo
                              en
                              let l:matches = matchlist(a:line, '\%(\S\@<!\%(vi\|vim\([<>=]\?\)\([0-9]\+\)\?\)\|\sex\):\(.\+\)')
                              if len(l:matches) > 0
                                for l:item in split(l:matches[3], '[ \t:]')
                                  call s:doOne(l:item)
                                endfo
                              en
                            endf
                            
                            " sample lines for detection, capturing both
                            " modeline(s) and max line length
                            " Hat tip to https://github.com/ciaranm/securemodelines
    1              0.000002 fun! s:doModelines() abort
                              if line('$') > &modelines
                                let l:lines={ }
                                call map(filter(getline(1, &modelines) +
                                      \ getline(line('$') - &modelines, '$'),
                                      \ 'v:val =~# ":"'), 'extend(l:lines, { v:val : 0 } )')
                                for l:line in keys(l:lines)
                                  call s:doModeline(l:line)
                                endfo
                              el
                                for l:line in getline(1, '$')
                                  call s:doModeline(l:line)
                                endfo
                              en
                            endf
                            
                            " Pass in a key sequence and the first letter of a vim mode. Returns key
                            " mapping mapped to it in that mode, else the original key sequence if none.
    1              0.000002 function! Mapkey (keys, mode) abort
                              redir => mappings | silent! map | redir END
                              for map in split(mappings, '\n')
                                let seq = matchstr(map, '\s\+\zs\S*')
                                if maparg(seq, a:mode) == a:keys
                                  return seq
                                endif
                              endfor
                              return a:keys
                            endfunction
                            
                            " vim:ts=2:sw=2:sts=2

SCRIPT  /Users/liss/.local/share/nvim/plugged/vista.vim/autoload/vista/extension/markdown.vim
Sourced 1 time
Total time:   0.001249
 Self time:   0.001249

count  total (s)   self (s)
                            " Copyright (c) 2019 Liu-Cheng Xu
                            " MIT License
                            " vim: ts=2 sw=2 sts=2 et
                            
    1              0.000017 let s:provider = fnamemodify(expand('<sfile>'), ':t:r')
                            
    1              0.000006 function! s:IsHeader(cur_line, next_line) abort
                              return a:cur_line =~# '^#\+' ||
                                    \ a:cur_line =~# '^\S' && (a:next_line =~# '^=\+\s*$' || a:next_line =~# '^-\+\s*$')
                            endfunction
                            
    1              0.000002 function! s:GatherHeaderMetadata() abort
                              let is_fenced_block = 0
                            
                              let s:lnum2tag = {}
                            
                              let headers = []
                            
                              let idx = 0
                              let lines = t:vista.source.lines()
                            
                              for line in lines
                                let line = substitute(line, '#', "\\\#", 'g')
                                let next_line = get(lines, idx + 1, '')
                            
                                if l:line =~# '````*' || l:line =~# '\~\~\~\~*'
                                  let is_fenced_block = !is_fenced_block
                                endif
                            
                                let is_header = s:IsHeader(l:line, l:next_line)
                            
                                if is_header && !is_fenced_block
                                    let matched = matchlist(l:line, '\(\#*\)\(.*\)')
                                    let text = vista#util#Trim(matched[2])
                                    let s:lnum2tag[len(headers)] = text
                                    call add(headers, {'lnum': idx+1, 'text': text, 'level': strlen(matched[1])})
                                endif
                            
                                let idx += 1
                              endfor
                            
                              return headers
                            endfunction
                            
                            " Use s:lnum2tag so that we don't have to extract the header from the rendered line.
    1              0.000004 function! vista#extension#markdown#GetHeader(lnum) abort
                              return get(s:lnum2tag, a:lnum, v:null)
                            endfunction
                            
    1              0.000025 function! s:ApplyAutoUpdate() abort
                              if has_key(t:vista, 'bufnr') && t:vista.winnr() != -1
                                call vista#SetProvider(s:provider)
                                let rendered = vista#renderer#markdown_like#MD(s:GatherHeaderMetadata())
                                call vista#util#SetBufline(t:vista.bufnr, rendered)
                              endif
                            endfunction
                            
    1              0.000003 function! vista#extension#markdown#AutoUpdate(fpath) abort
                              call s:AutoUpdate(a:fpath)
                            endfunction
                            
    1              0.000002 function! s:ShouldUseMarkdownExtension(source_filetype) abort
                              if a:source_filetype ==# 'markdown'
                                return v:true
                              " vimwiki can reuse the markdown extension.
                              elseif a:source_filetype ==# 'vimwiki'
                                    \ && vista#GetExplicitExecutive(a:source_filetype) ==# 'markdown'
                                return v:true
                              else
                                return v:false
                              endif
                            endfunction
                            
    1              0.000002 function! s:AutoUpdate(fpath) abort
                              let source_filetype = t:vista.source.filetype()
                              if s:ShouldUseMarkdownExtension(source_filetype)
                                call s:ApplyAutoUpdate()
                              elseif source_filetype ==# 'rst'
                                call vista#extension#rst#AutoUpdate(a:fpath)
                              else
                                call vista#executive#ctags#AutoUpdate(a:fpath)
                              endif
                            endfunction
                            
                            " Credit: originally from `:Toc` of vim-markdown
    1              0.000002 function! vista#extension#markdown#Execute(_bang, should_display) abort
                              call vista#OnExecute(s:provider, function('s:AutoUpdate'))
                            
                              if a:should_display
                                let rendered = vista#renderer#markdown_like#MD(s:GatherHeaderMetadata())
                                call vista#sidebar#OpenOrUpdate(rendered)
                              endif
                            endfunction

SCRIPT  /Users/liss/.local/share/nvim/plugged/ale/ale_linters/markdown/alex.vim
Sourced 1 time
Total time:   0.004420
 Self time:   0.002149

count  total (s)   self (s)
                            " Author: Johannes Wienke <languitar@semipol.de>
                            " Description: alex for markdown files
                            
    1   0.004098   0.001827 call ale#handlers#alex#DefineLinter('markdown', '')

SCRIPT  /Users/liss/.local/share/nvim/plugged/ale/autoload/ale/handlers/alex.vim
Sourced 1 time
Total time:   0.000870
 Self time:   0.000870

count  total (s)   self (s)
    1              0.000015 scriptencoding utf-8
                            " Author: Johannes Wienke <languitar@semipol.de>
                            " Description: Error handling for errors in alex output format
                            
    1              0.000030 function! ale#handlers#alex#GetExecutable(buffer) abort
                                return ale#node#FindExecutable(a:buffer, 'alex', [
                                \   'node_modules/.bin/alex',
                                \   'node_modules/alex/cli.js',
                                \])
                            endfunction
                            
    1              0.000004 function! ale#handlers#alex#CreateCommandCallback(flags) abort
                                return {b -> ale#node#Executable(b, ale#handlers#alex#GetExecutable(b))
                                \            . ' %s '
                                \            . a:flags}
                            endfunction
                            
    1              0.000003 function! ale#handlers#alex#Handle(buffer, lines) abort
                                " Example output:
                                "       6:256-6:262  warning  Be careful with â€œkilledâ€, itâ€™s profane in some cases      killed           retext-profanities
                                let l:pattern = '\v^ *(\d+):(\d+)-(\d+):(\d+) +warning +(.{-})  +(.{-})  +(.{-})$'
                                let l:output = []
                            
                                for l:match in ale#util#GetMatches(a:lines, l:pattern)
                                    call add(l:output, {
                                    \   'lnum': l:match[1] + 0,
                                    \   'col': l:match[2] + 0,
                                    \   'end_lnum': l:match[3] + 0,
                                    \   'end_col': l:match[4] - 1,
                                    \   'text': l:match[5] . ' (' . (l:match[7]) . ')',
                                    \   'type': 'W',
                                    \})
                                endfor
                            
                                return l:output
                            endfunction
                            
                            " Define a linter for a specific filetype. Accept flags to adapt to the filetype.
                            "    no flags  treat input as markdown
                            "    --html    treat input as HTML
                            "    --text    treat input as plaintext
    1              0.000004 function! ale#handlers#alex#DefineLinter(filetype, flags) abort
                                call ale#Set('alex_executable', 'alex')
                                call ale#Set('alex_use_global', get(g:, 'ale_use_global_executables', 0))
                            
                                call ale#linter#Define(a:filetype, {
                                \   'name': 'alex',
                                \   'executable': function('ale#handlers#alex#GetExecutable'),
                                \   'command': ale#handlers#alex#CreateCommandCallback(a:flags),
                                \   'output_stream': 'stderr',
                                \   'callback': 'ale#handlers#alex#Handle',
                                \   'lint_file': 1,
                                \})
                            endfunction

SCRIPT  /Users/liss/.local/share/nvim/plugged/ale/ale_linters/markdown/languagetool.vim
Sourced 1 time
Total time:   0.005292
 Self time:   0.003106

count  total (s)   self (s)
                            " Author: Vincent (wahrwolf [Ã¤t] wolfpit.net)
                            " Description: languagetool for markdown files
                            
                            
    1   0.004350   0.002164 call ale#handlers#languagetool#DefineLinter('markdown')

SCRIPT  /Users/liss/.local/share/nvim/plugged/ale/autoload/ale/handlers/languagetool.vim
Sourced 1 time
Total time:   0.001565
 Self time:   0.001516

count  total (s)   self (s)
                            " Author: Vincent (wahrwolf [at] wolfpit.net)
                            " Description: languagetool for markdown files
                            "
    1   0.000055   0.000021 call ale#Set('languagetool_executable', 'languagetool')
    1   0.000025   0.000010 call ale#Set('languagetool_options', '--autoDetect')
                            
    1              0.000005 function! ale#handlers#languagetool#GetExecutable(buffer) abort
                                return ale#Var(a:buffer, 'languagetool_executable')
                            endfunction
                            
    1              0.000003 function! ale#handlers#languagetool#GetCommand(buffer) abort
                                let l:executable = ale#handlers#languagetool#GetExecutable(a:buffer)
                                let l:options = ale#Var(a:buffer, 'languagetool_options')
                            
                                return ale#Escape(l:executable)
                                \ . (empty(l:options) ? '' : ' ' . l:options) . ' %s'
                            endfunction
                            
    1              0.000006 function! ale#handlers#languagetool#HandleOutput(buffer, lines) abort
                                " Match lines like:
                                " 1.) Line 5, column 1, Rule ID:
                                let l:head_pattern = '^\v.+.\) Line (\d+), column (\d+), Rule ID. (.+)$'
                                let l:head_matches = ale#util#GetMatches(a:lines, l:head_pattern)
                            
                                " Match lines like:
                                " Message: Did you forget a comma after a conjunctive/linking adverb?
                                let l:message_pattern = '^\vMessage. (.+)$'
                                let l:message_matches = ale#util#GetMatches(a:lines, l:message_pattern)
                            
                                " Match lines like:
                                "   ^^^^^ "
                                let l:markers_pattern = '^\v *(\^+) *$'
                                let l:markers_matches = ale#util#GetMatches(a:lines, l:markers_pattern)
                            
                                let l:output = []
                            
                            
                                " Okay tbh I was to lazy to figure out a smarter solution here
                                " We just check that the arrays are same sized and merge everything
                                " together
                                let l:i = 0
                            
                                while l:i < len(l:head_matches)
                                \   && (
                                \       (len(l:head_matches) == len(l:markers_matches))
                                \       && (len(l:head_matches) == len(l:message_matches))
                                \   )
                                    let l:item = {
                                    \   'lnum'    : str2nr(l:head_matches[l:i][1]),
                                    \   'col'     : str2nr(l:head_matches[l:i][2]),
                                    \   'end_col' : str2nr(l:head_matches[l:i][2]) + len(l:markers_matches[l:i][1])-1,
                                    \   'type'    : 'W',
                                    \   'code'    : l:head_matches[l:i][3],
                                    \   'text'    : l:message_matches[l:i][1]
                                    \}
                                    call add(l:output, l:item)
                                    let l:i+=1
                                endwhile
                            
                                return l:output
                            endfunction
                            
                            " Define the languagetool linter for a given filetype.
                            " TODO:
                            " - Add language detection settings based on user env (for mothertongue)
                            " - Add fixer
                            " - Add config options for rules
    1              0.000004 function! ale#handlers#languagetool#DefineLinter(filetype) abort
                                call ale#linter#Define(a:filetype, {
                                \   'name': 'languagetool',
                                \   'executable': function('ale#handlers#languagetool#GetExecutable'),
                                \   'command': function('ale#handlers#languagetool#GetCommand'),
                                \   'output_stream': 'stdout',
                                \   'callback': 'ale#handlers#languagetool#HandleOutput',
                                \   'lint_file': 1,
                                \})
                            endfunction

SCRIPT  /Users/liss/.local/share/nvim/plugged/ale/ale_linters/markdown/markdownlint.vim
Sourced 1 time
Total time:   0.001489
 Self time:   0.001090

count  total (s)   self (s)
                            " Author: Ty-Lucas Kelley <tylucaskelley@gmail.com>
                            " Description: Adds support for markdownlint
                            
    1   0.000431   0.000032 call ale#linter#Define('markdown', {
                            \   'name': 'markdownlint',
                            \   'executable': 'markdownlint',
                            \   'lint_file': 1,
                            \   'output_stream': 'both',
                            \   'command': 'markdownlint %s',
                            \   'callback': 'ale#handlers#markdownlint#Handle'
                            \})

SCRIPT  /Users/liss/.local/share/nvim/plugged/ale/ale_linters/markdown/mdl.vim
Sourced 1 time
Total time:   0.003021
 Self time:   0.000706

count  total (s)   self (s)
                            " Author: Steve Dignam <steve@dignam.xyz>, Josh Leeb-du Toit <joshleeb.com>
                            " Description: Support for mdl, a markdown linter.
                            
    1   0.000036   0.000016 call ale#Set('markdown_mdl_executable', 'mdl')
    1   0.000029   0.000009 call ale#Set('markdown_mdl_options', '')
                            
    1              0.000004 function! ale_linters#markdown#mdl#GetExecutable(buffer) abort
                                return ale#Var(a:buffer, 'markdown_mdl_executable')
                            endfunction
                            
    1              0.000004 function! ale_linters#markdown#mdl#GetCommand(buffer) abort
                                let l:executable = ale_linters#markdown#mdl#GetExecutable(a:buffer)
                                let l:exec_args = l:executable =~? 'bundle$'
                                \   ? ' exec mdl'
                                \   : ''
                            
                                let l:options = ale#Var(a:buffer, 'markdown_mdl_options')
                            
                                return ale#Escape(l:executable) . l:exec_args
                                \   . ' -j' . (!empty(l:options) ? ' ' . l:options : '')
                            endfunction
                            
    1              0.000003 function! ale_linters#markdown#mdl#Handle(buffer, lines) abort
                                let l:output = []
                            
                                for l:error in ale#util#FuzzyJSONDecode(a:lines, [])
                                    call add(l:output, {
                                    \   'lnum': l:error['line'],
                                    \   'code': l:error['rule']  . '/' . join(l:error['aliases'], '/'),
                                    \   'text': l:error['description'],
                                    \   'type': 'W',
                                    \})
                                endfor
                            
                                return l:output
                            endfunction
                            
    1   0.002329   0.000054 call ale#linter#Define('markdown', {
                            \   'name': 'mdl',
                            \   'executable': function('ale_linters#markdown#mdl#GetExecutable'),
                            \   'command': function('ale_linters#markdown#mdl#GetCommand'),
                            \   'callback': 'ale_linters#markdown#mdl#Handle'
                            \})

SCRIPT  /Users/liss/.local/share/nvim/plugged/ale/ale_linters/markdown/proselint.vim
Sourced 1 time
Total time:   0.001771
 Self time:   0.001121

count  total (s)   self (s)
                            " Author: poohzrn https://github.com/poohzrn
                            " Description: proselint for Markdown files
                            
    1   0.000688   0.000038 call ale#linter#Define('markdown', {
                            \   'name': 'proselint',
                            \   'executable': 'proselint',
                            \   'command': 'proselint %t',
                            \   'callback': 'ale#handlers#unix#HandleAsWarning',
                            \})

SCRIPT  /Users/liss/.local/share/nvim/plugged/ale/ale_linters/markdown/redpen.vim
Sourced 1 time
Total time:   0.001281
 Self time:   0.000780

count  total (s)   self (s)
                            " Author: rhysd https://rhysd.github.io
                            " Description: Redpen, a proofreading tool (http://redpen.cc)
                            
    1   0.000537   0.000035 call ale#linter#Define('markdown', {
                            \   'name': 'redpen',
                            \   'executable': 'redpen',
                            \   'command': 'redpen -f markdown -r json %t',
                            \   'callback': 'ale#handlers#redpen#HandleRedpenOutput',
                            \})

SCRIPT  /Users/liss/.local/share/nvim/plugged/ale/ale_linters/markdown/remark_lint.vim
Sourced 1 time
Total time:   0.001673
 Self time:   0.001236

count  total (s)   self (s)
    1              0.000014 scriptencoding utf-8
                            " Author rhysd https://rhysd.github.io/, Dirk Roorda (dirkroorda), AdriÃ¡n GonzÃ¡lez Rus (@adrigzr)
                            " Description: remark-lint for Markdown files
    1   0.000044   0.000024 call ale#Set('markdown_remark_lint_executable', 'remark')
    1   0.000021   0.000007 call ale#Set('markdown_remark_lint_use_global', get(g:, 'ale_use_global_executables', 0))
    1   0.000012   0.000004 call ale#Set('markdown_remark_lint_options', '')
                            
    1              0.000003 function! ale_linters#markdown#remark_lint#GetCommand(buffer) abort
                                let l:options = ale#Var(a:buffer, 'markdown_remark_lint_options')
                            
                                return '%e' . ale#Pad(l:options) . ' --no-stdout --no-color'
                            endfunction
                            
    1              0.000007 function! ale_linters#markdown#remark_lint#Handle(buffer, lines) abort
                                " matches: '  1:4  warning  Incorrect list-item indent: add 1 space  list-item-indent  remark-lint'
                                " matches: '  18:71-19:1  error  Missing new line after list item  list-item-spacing  remark-lint',
                                let l:pattern = '^ \+\(\d\+\):\(\d\+\)\(-\(\d\+\):\(\d\+\)\)\?  \(warning\|error\)  \(.\+\)$'
                                let l:output = []
                            
                                for l:match in ale#util#GetMatches(a:lines, l:pattern)
                                    let l:item = {
                                    \   'lnum': l:match[1] + 0,
                                    \   'col': l:match[2] + 0,
                                    \   'type': l:match[6] is# 'error' ? 'E' : 'W',
                                    \   'text': l:match[7],
                                    \}
                            
                                    if l:match[3] isnot# ''
                                        let l:item.end_lnum = l:match[4] + 0
                                        let l:item.end_col = l:match[5] + 0
                                    endif
                            
                                    call add(l:output, l:item)
                                endfor
                            
                                return l:output
                            endfunction
                            
    1   0.000431   0.000036 call ale#linter#Define('markdown', {
                            \   'name': 'remark_lint',
                            \   'aliases': ['remark-lint'],
                            \   'executable': {b -> ale#node#FindExecutable(b, 'markdown_remark_lint', [
                            \       'node_modules/.bin/remark',
                            \   ])},
                            \   'command': function('ale_linters#markdown#remark_lint#GetCommand'),
                            \   'callback': 'ale_linters#markdown#remark_lint#Handle',
                            \   'output_stream': 'stderr',
                            \})

SCRIPT  /Users/liss/.local/share/nvim/plugged/ale/ale_linters/markdown/textlint.vim
Sourced 1 time
Total time:   0.003225
 Self time:   0.000827

count  total (s)   self (s)
                            " Author: tokida https://rouger.info, Yasuhiro Kiyota <yasuhiroki.duck@gmail.com>
                            " Description: textlint, a proofreading tool (https://textlint.github.io/)
                            
    1   0.002479   0.000081 call ale#linter#Define('markdown', {
                            \   'name': 'textlint',
                            \   'executable': function('ale#handlers#textlint#GetExecutable'),
                            \   'command': function('ale#handlers#textlint#GetCommand'),
                            \   'callback': 'ale#handlers#textlint#HandleTextlintOutput',
                            \})

SCRIPT  /Users/liss/.local/share/nvim/plugged/ale/ale_linters/markdown/vale.vim
Sourced 1 time
Total time:   0.000880
 Self time:   0.000249

count  total (s)   self (s)
                            " Author: chew-z https://github.com/chew-z
                            " Description: vale for Markdown files
                            
    1   0.000663   0.000032 call ale#linter#Define('markdown', {
                            \   'name': 'vale',
                            \   'executable': 'vale',
                            \   'command': 'vale --output=JSON %t',
                            \   'callback': 'ale#handlers#vale#Handle',
                            \})

SCRIPT  /Users/liss/.local/share/nvim/plugged/ale/ale_linters/markdown/writegood.vim
Sourced 1 time
Total time:   0.003158
 Self time:   0.001700

count  total (s)   self (s)
                            " Author: Sumner Evans <sumner.evans98@gmail.com>
                            " Description: write-good for Markdown files
                            
    1   0.001957   0.000499 call ale#handlers#writegood#DefineLinter('markdown')

SCRIPT  /Users/liss/.local/share/nvim/plugged/ale/autoload/ale/handlers/writegood.vim
Sourced 1 time
Total time:   0.000853
 Self time:   0.000561

count  total (s)   self (s)
                            " Author: Sumner Evans <sumner.evans98@gmail.com>
                            " Description: Error handling for errors in the write-good format.
                            
    1              0.000006 function! ale#handlers#writegood#ResetOptions() abort
                                call ale#Set('writegood_options', '')
                                call ale#Set('writegood_executable', 'write-good')
                                call ale#Set('writegood_use_global', get(g:, 'ale_use_global_executables', 0))
                            endfunction
                            
                            " Reset the options so the tests can test how they are set.
    1   0.000355   0.000062 call ale#handlers#writegood#ResetOptions()
                            
    1              0.000003 function! ale#handlers#writegood#GetExecutable(buffer) abort
                                return ale#node#FindExecutable(a:buffer, 'writegood', [
                                \   'node_modules/.bin/write-good',
                                \   'node_modules/write-good/bin/write-good.js',
                                \])
                            endfunction
                            
    1              0.000021 function! ale#handlers#writegood#GetCommand(buffer) abort
                                let l:executable = ale#handlers#writegood#GetExecutable(a:buffer)
                                let l:options = ale#Var(a:buffer, 'writegood_options')
                            
                                return ale#node#Executable(a:buffer, l:executable)
                                \   . (!empty(l:options) ? ' ' . l:options : '')
                                \   . ' %t'
                            endfunction
                            
    1              0.000002 function! ale#handlers#writegood#Handle(buffer, lines) abort
                                " Look for lines like the following.
                                "
                                " "it is" is wordy or unneeded on line 20 at column 53
                                " "easily" can weaken meaning on line 154 at column 29
                                let l:marks_pattern = '\v^ *(\^+) *$'
                                let l:pattern = '\v^(".*"\s.*)\son\sline\s(\d+)\sat\scolumn\s(\d+)$'
                                let l:output = []
                                let l:last_len = 0
                            
                                for l:match in ale#util#GetMatches(a:lines, [l:marks_pattern, l:pattern])
                                    if empty(l:match[2])
                                        let l:last_len = len(l:match[1])
                                    else
                                        let l:col = l:match[3] + 1
                            
                                        " Add the linter error. Note that we need to add 1 to the col because
                                        " write-good reports the column corresponding to the space before the
                                        " offending word or phrase.
                                        call add(l:output, {
                                        \   'text': l:match[1],
                                        \   'lnum': l:match[2] + 0,
                                        \   'col': l:col,
                                        \   'end_col': l:last_len ? (l:col + l:last_len - 1) : l:col,
                                        \   'type': 'W',
                                        \})
                            
                                        let l:last_len = 0
                                    endif
                                endfor
                            
                                return l:output
                            endfunction
                            
                            " Define the writegood linter for a given filetype.
    1              0.000002 function! ale#handlers#writegood#DefineLinter(filetype) abort
                                call ale#linter#Define(a:filetype, {
                                \   'name': 'writegood',
                                \   'aliases': ['write-good'],
                                \   'executable': function('ale#handlers#writegood#GetExecutable'),
                                \   'command': function('ale#handlers#writegood#GetCommand'),
                                \   'callback': 'ale#handlers#writegood#Handle',
                                \})
                            endfunction

SCRIPT  /Users/liss/.local/share/nvim/plugged/vim-test/autoload/test/base.vim
Sourced 1 time
Total time:   0.001047
 Self time:   0.001047

count  total (s)   self (s)
    1              0.000015 function! test#base#test_file(runner, file) abort
                              return test#{a:runner}#test_file(a:file)
                            endfunction
                            
    1              0.000004 function! test#base#build_position(runner, type, position) abort
                              return test#{a:runner}#build_position(a:type, a:position)
                            endfunction
                            
    1              0.000003 function! test#base#options(runner, args, ...) abort
                              let options = get(g:, 'test#'.a:runner.'#options', [])
                              if empty(a:000) && type(options) == type('')
                                let options = split(options)
                              elseif !empty(a:000) && type(options) == type({})
                                let options = split(get(options, 'all', '')) + split(get(options, a:000[0], ''))
                              else
                                let options = []
                              endif
                              if exists('*test#'.a:runner.'#build_options')
                                return test#{a:runner}#build_options(a:args, options)
                              else
                                return options + a:args
                              endif
                            endfunction
                            
    1              0.000004 function! test#base#executable(runner) abort
                              if exists('g:test#'.a:runner.'#executable')
                                return g:test#{a:runner}#executable
                              else
                                return test#{a:runner}#executable()
                              endif
                            endfunction
                            
    1              0.000002 function! test#base#build_args(runner, args) abort
                              return test#{a:runner}#build_args(a:args)
                            endfunction
                            
    1              0.000002 function! test#base#file_exists(file) abort
                              return !empty(glob(a:file)) || bufexists(a:file)
                            endfunction
                            
    1              0.000001 function! test#base#escape_regex(string) abort
                              return escape(a:string, '?+*\^$.|{}[]()')
                            endfunction
                            
    1              0.000001 function! test#base#no_colors() abort
                              let strategy = get(g:, 'test#strategy', 'basic')
                              return has('gui_running') && strategy ==# 'basic'
                            endfunction
                            
                            " Takes a position and a dictionary of patterns, and returns list of strings
                            " that were matched in the file by the patterns from the given position
                            " upwards. It can be used when a runner doesn't support running nearest tests
                            " with line numbers, but supports regexes.
                            "
                            " The "position" argument is a dictionary created by this plugin:
                            "
                            "   {
                            "     'file': 'test/foo_test.rb',
                            "     'line': 11,
                            "     'col': 2,
                            "   }
                            "
                            " The "patterns" argument is a dictionary where keys are either "test" or
                            " "namespace", and values are lists of regexes:
                            "
                            "   {
                            "     'test': ['\v^\s*def (test_\w+)'],
                            "     'namespace': ['\v^\s*%(class|module) (\S+)'],
                            "   }
                            "
                            " If a line is matched, the substring corresponding to the 1st match group will
                            " be returned. So for the above patterns this function might return something
                            " like this:
                            "
                            "   {
                            "     'test': ['test_calculates_time'],
                            "     'test_line': 54, " Line where 'test_calculates_time' was found
                            "     'namespace': ['CalculatorTest'],
                            "   }
    1              0.000002 function! test#base#nearest_test(position, patterns) abort
                              return test#base#nearest_test_in_lines(a:position['file'], a:position['line'], 1, a:patterns)
                            endfunction
                            
                            " This function is used internally by the test#base#nearest_test function
                            " So it behaves exactly like describe for test#base#nearest_test except that
                            " it can search forward or backward depending on the search range.
                            "
                            " Instead of taking a "position" argument, this function takes 3:
                            "   - "filename" is the equivalent of "position['file']"
                            "   - "from_line" the line number from where to start the search, is the
                            "   equivalent fo "position['line']"
                            "   - "to_line" the line number where to end the search (it would be 1 in
                            "   test#base#nearest_test)
                            "
                            " If "from_line" is greater than "to_line" or equals '$' then the search will
                            " be backward.
                            " Otherwise it will be forward.
    1              0.000002 function! test#base#nearest_test_in_lines(filename, from_line, to_line, patterns) abort
                              let test         = []
                              let namespace    = []
                              let last_indent  = -1
                              let current_line = a:from_line + 1
                              let test_line    = -1
                            
                              let is_reverse = '$' == a:from_line ? 1 : a:from_line > a:to_line
                              let lines = is_reverse
                                \ ? reverse(getbufline(a:filename, a:to_line, a:from_line))
                                \ : getbufline(a:filename, a:from_line, a:to_line)
                            
                              for line in lines
                                let current_line    = current_line + (is_reverse ? -1 : 1)
                                let test_match      = s:find_match(line, a:patterns['test'])
                                let namespace_match = s:find_match(line, a:patterns['namespace'])
                            
                                let indent = len(matchstr(line, '^\s*'))
                                if !empty(test_match) && last_indent == -1
                                  call add(test, filter(test_match[1:], '!empty(v:val)')[0])
                                  let last_indent = indent
                                  let test_line   = current_line
                                elseif !empty(namespace_match) && (indent < last_indent || last_indent == -1)
                                  call add(namespace, filter(namespace_match[1:], '!empty(v:val)')[0])
                                  let last_indent = indent
                                endif
                              endfor
                            
                              return {'test': test, 'test_line': test_line, 'namespace': reverse(namespace)}
                            endfunction
                            
    1              0.000006 function! s:find_match(line, patterns) abort
                              let matches = map(copy(a:patterns), 'matchlist(a:line, v:val)')
                              return get(filter(matches, '!empty(v:val)'), 0, [])
                            endfunction

SCRIPT  /Users/liss/.local/share/nvim/plugged/vim-test/autoload/test/clojure/fireplacetest.vim
Sourced 1 time
Total time:   0.001256
 Self time:   0.001256

count  total (s)   self (s)
    1              0.000023 if !exists('g:test#clojure#fireplacetest#file_pattern')
    1              0.000012   let g:test#clojure#fireplacetest#file_pattern = '\v(_test|^test/.+)\.cljs?$'
    1              0.000002 end
                            
    1              0.000004 function! test#clojure#fireplacetest#test_file(file) abort
                              return a:file =~# g:test#clojure#fireplacetest#file_pattern
                            endfunction
                            
    1              0.000002 function! test#clojure#fireplacetest#build_position(type, position) abort
                              call s:require_fireplace()
                            
                              if a:type ==# 'nearest'
                                if expand('%:.') == a:position['file']
                                  return [':.RunTests']
                                else
                                  return [':edit +'.a:position['line'].' '.a:position['file'].' | :.RunTests']
                                endif
                              elseif a:type ==# 'file'
                                return [':RunTests '.fireplace#ns(a:position['file'])]
                              else
                                return [':0RunTests']
                              endif
                            endfunction
                            
    1              0.000002 function! test#clojure#fireplacetest#build_args(args) abort
                              if get(a:args, 0, '') =~# 'RunTests'
                                return a:args
                              else
                                return [':RunTests '.join(a:args)]
                              endif
                            endfunction
                            
    1              0.000002 function! test#clojure#fireplacetest#executable() abort
                            endfunction
                            
    1              0.000005 function! s:require_fireplace() abort
                              if !exists('g:loaded_fireplace')
                                throw 'Test.vim requires Fireplace.vim to run Clojure tests'
                              endif
                            endfunction

SCRIPT  /Users/liss/.local/share/nvim/plugged/vim-test/autoload/test/elm/elmtest.vim
Sourced 1 time
Total time:   0.002832
 Self time:   0.002832

count  total (s)   self (s)
                            
    1              0.000107 if !exists('g:test#elm#elmtest#file_pattern')
    1              0.000029   let g:test#elm#elmtest#file_pattern = '\vtests?\/.*\.elm$'
    1              0.000717 endif
                            
    1              0.000032 function! test#elm#elmtest#test_file(file) abort
                              return a:file =~# g:test#elm#elmtest#file_pattern
                            endfunction
                            
    1              0.000005 function! test#elm#elmtest#build_position(type, position) abort
                              if a:type ==# 'nearest'
                                " The test file must be modified to use `only` to only run a single test
                                " or group of tests (see
                                " https://github.com/elm-community/elm-test#not-running-tests), so just
                                " run the file and leave narrowing things down up to the user.
                                return [a:position['file']]
                              elseif a:type ==# 'file'
                                return [a:position['file']]
                              else
                                return []
                              endif
                            endfunction
                            
    1              0.000003 function! test#elm#elmtest#build_args(args) abort
                              return a:args
                            endfunction
                            
    1              0.000002 function! test#elm#elmtest#executable() abort
                              return 'elm-test'
                            endfunction

SCRIPT  /Users/liss/.local/share/nvim/plugged/vim-test/autoload/test/rust/cargotest.vim
Sourced 1 time
Total time:   0.001672
 Self time:   0.001672

count  total (s)   self (s)
    1              0.000020 if !exists('g:test#rust#cargotest#file_pattern')
    1              0.000006   let g:test#rust#cargotest#file_pattern = '\v\.rs$'
    1              0.000002 endif
                            
    1              0.000003 function! test#rust#cargotest#test_file(file) abort
                              return a:file =~# g:test#rust#cargotest#file_pattern
                            endfunction
                            
    1              0.000002 function! test#rust#cargotest#build_position(type, position) abort
                              return []
                            endfunction
                            
    1              0.000002 function! test#rust#cargotest#build_args(args) abort
                              return a:args
                            endfunction
                            
    1              0.000002 function! test#rust#cargotest#executable() abort
                              return 'cargo test'
                            endfunction

SCRIPT  /Users/liss/.local/share/nvim/plugged/vim-test/autoload/test/elixir/exunit.vim
Sourced 1 time
Total time:   0.001253
 Self time:   0.001253

count  total (s)   self (s)
    1              0.000023 if !exists('g:test#elixir#exunit#file_pattern')
    1              0.000014   let g:test#elixir#exunit#file_pattern = '\v_test\.exs$'
    1              0.000002 endif
                            
    1              0.000005 function! test#elixir#exunit#test_file(file) abort
                              return a:file =~# g:test#elixir#exunit#file_pattern
                            endfunction
                            
    1              0.000004 function! test#elixir#exunit#build_position(type, position) abort
                              if test#elixir#exunit#executable() ==# 'mix test'
                                if a:type ==# 'nearest'
                                  return [a:position['file'].':'.a:position['line']]
                                elseif a:type ==# 'file'
                                  return [a:position['file']]
                                else
                                  return []
                                endif
                              else
                                if a:type ==# 'nearest' || a:type ==# 'file'
                                  return [a:position['file']]
                                else
                                  return ['*.exs']
                                end
                              end
                            endfunction
                            
    1              0.000004 function! test#elixir#exunit#build_args(args) abort
                              let args = a:args
                            
                              if test#base#no_colors()
                                let args = ['--no-color'] + args
                              endif
                            
                              return args
                            endfunction
                            
    1              0.000002 function! test#elixir#exunit#executable() abort
                              if filereadable('mix.exs')
                                return 'mix test'
                              else
                                return 'elixir'
                              end
                            endfunction

SCRIPT  /Users/liss/.local/share/nvim/plugged/vim-test/autoload/test/ruby/minitest.vim
Sourced 1 time
Total time:   0.001489
 Self time:   0.001489

count  total (s)   self (s)
    1              0.000017 if !exists('g:test#ruby#minitest#file_pattern')
    1              0.000005   let g:test#ruby#minitest#file_pattern = '\v_test\.rb$'
    1              0.000001 endif
                            
    1              0.000004 function! test#ruby#minitest#test_file(file) abort
                              return a:file =~# g:test#ruby#minitest#file_pattern
                            endfunction
                            
    1              0.000002 function! test#ruby#minitest#build_position(type, position) abort
                              if a:type ==# 'nearest'
                                let name = s:nearest_test(a:position)
                                if !empty(name)
                                  return [a:position['file'], '--name', '/'.name.'/']
                                else
                                  return [a:position['file']]
                                endif
                              elseif a:type ==# 'file'
                                return [a:position['file']]
                              else
                                return []
                              endif
                            endfunction
                            
    1              0.000003 function! test#ruby#minitest#build_args(args) abort
                              for idx in range(0, len(a:args) - 1)
                                if test#base#file_exists(a:args[idx])
                                  let path = remove(a:args, idx) | break
                                endif
                              endfor
                            
                              if exists('path') && isdirectory(path)
                                let path = fnamemodify(path, ':p:.') . '**/*_test.rb'
                              elseif !exists('path')
                                let path = 'test/**/*_test.rb'
                              endif
                            
                              for option in ['--name', '--seed']
                                let idx = index(a:args, option)
                                if idx != -1
                                  let value = remove(a:args, idx + 1)
                                  let a:args[idx] = option.'='.shellescape(value, 1)
                                endif
                              endfor
                            
                              let kind = matchstr(test#base#executable('ruby#minitest'), 'ruby\|rake')
                              return s:build_{kind}_args(get(l:, 'path'), a:args)
                            endfunction
                            
    1              0.000004 function! s:build_rake_args(path, args) abort
                              let cmd = []
                              if !empty(a:path) | call add(cmd, 'TEST="'.escape(a:path, '"').'"') | endif
                              if !empty(a:args) | call add(cmd, 'TESTOPTS="'.escape(join(a:args), '"`').'"') | endif
                            
                              return cmd
                            endfunction
                            
    1              0.000002 function! s:build_ruby_args(path, args) abort
                              if a:path =~# '*'
                                return ['-e', shellescape('Dir["./'.a:path.'"].each &method(:require)'), '--'] + a:args
                              else
                                return [a:path] + a:args
                              endif
                            endfunction
                            
    1              0.000001 function! test#ruby#minitest#executable() abort
                              if filereadable('Rakefile') && system('cat Rakefile') =~# 'Rake::TestTask' ||
                               \ (exists('b:rails_root') || filereadable('./bin/rails'))
                                if !empty(glob('.zeus.sock'))
                                  return 'zeus rake test'
                                elseif filereadable('./bin/rake') && get(g:, 'test#ruby#use_binstubs', 1)
                                  return './bin/rake test'
                                elseif filereadable('Gemfile') && get(g:, 'test#ruby#bundle_exec', 1)
                                  return 'bundle exec rake test'
                                else
                                  return 'rake test'
                                endif
                              else
                                if filereadable('Gemfile') && get(g:, 'test#ruby#bundle_exec', 1)
                                  return 'bundle exec ruby -I test'
                                else
                                  return 'ruby -I test'
                                endif
                              endif
                            endfunction
                            
                            " http://chriskottom.com/blog/2014/12/command-line-flags-for-minitest-in-the-raw/
    1              0.000006 function! s:nearest_test(position) abort
                              let syntax = s:syntax(a:position['file'])
                              let name = test#base#nearest_test(a:position, g:test#ruby#patterns)
                            
                              let namespace = filter([test#base#escape_regex(join(name['namespace'], '::'))], '!empty(v:val)')
                              if empty(name['test'])
                                let test = []
                              else
                                let test_name = test#base#escape_regex(name['test'][0]).'$'
                                if syntax ==# 'rails'    " test('foo') { ... }
                                  let test = ['test_'.substitute(test_name, '\s\+', '_', 'g')]
                                elseif syntax ==# 'spec' " it('foo') { ... }
                                  let test = ['test_\d+_'.test_name]
                                else
                                  let test = [test_name]
                                endif
                              endif
                            
                              return join(namespace + test, '#')
                            endfunction
                            
    1              0.000002 function! s:syntax(file) abort
                              let lines = split(system('cat '.a:file), '\n')
                            
                              if !empty(filter(copy(lines), "v:val =~# g:test#ruby#patterns['test'][1]"))
                                return 'rails'
                              elseif !empty(filter(copy(lines), "v:val =~# g:test#ruby#patterns['test'][2]"))
                                return 'spec'
                              else
                                return 'test'
                              endif
                            endfunction

SCRIPT  /Users/liss/.local/share/nvim/plugged/vim-test/autoload/test/ruby/rspec.vim
Sourced 1 time
Total time:   0.001350
 Self time:   0.001350

count  total (s)   self (s)
    1              0.000017 if !exists('g:test#ruby#rspec#file_pattern')
    1              0.000010   let g:test#ruby#rspec#file_pattern = '\v(_spec\.rb|spec/.*\.feature)$'
    1              0.000002 endif
                            
    1              0.000003 function! test#ruby#rspec#test_file(file) abort
                              return a:file =~# g:test#ruby#rspec#file_pattern
                            endfunction
                            
    1              0.000002 function! test#ruby#rspec#build_position(type, position) abort
                              if a:type ==# 'nearest'
                                return [a:position['file'].':'.a:position['line']]
                              elseif a:type ==# 'file'
                                return [a:position['file']]
                              else
                                return []
                              endif
                            endfunction
                            
    1              0.000002 function! test#ruby#rspec#build_args(args) abort
                              let args = a:args
                            
                              if test#base#no_colors()
                                let args = ['--no-color'] + args
                              endif
                            
                              return args
                            endfunction
                            
    1              0.000023 function! test#ruby#rspec#executable() abort
                              if !empty(glob('.zeus.sock'))
                                return 'zeus rspec'
                              elseif filereadable('./bin/spring') && get(g:, 'test#ruby#use_spring_binstub', 0)
                                return './bin/spring rspec'
                              elseif filereadable('./bin/rspec') && get(g:, 'test#ruby#use_binstubs', 1)
                                return './bin/rspec'
                              elseif filereadable('Gemfile') && get(g:, 'test#ruby#bundle_exec', 1)
                                return 'bundle exec rspec'
                              else
                                return 'rspec'
                              endif
                            endfunction

SCRIPT  /Users/liss/.local/share/nvim/plugged/vim-test/autoload/test/javascript/mocha.vim
Sourced 1 time
Total time:   0.001423
 Self time:   0.001423

count  total (s)   self (s)
    1              0.000018 if !exists('g:test#javascript#mocha#file_pattern')
    1              0.000005   let g:test#javascript#mocha#file_pattern = '\vtests?/.*\.(js|jsx|coffee)$'
    1              0.000001 endif
                            
    1              0.000003 function! test#javascript#mocha#test_file(file) abort
                              return a:file =~# g:test#javascript#mocha#file_pattern
                                \ && test#javascript#has_package('mocha')
                            endfunction
                            
    1              0.000002 function! test#javascript#mocha#build_position(type, position) abort
                              if a:type ==# 'nearest'
                                let name = s:nearest_test(a:position)
                                if !empty(name)
                                  let name = '--grep '.shellescape(name, 1)
                                endif
                                return [a:position['file'], name]
                              elseif a:type ==# 'file'
                                return [a:position['file']]
                              else
                                let test_dir = get(filter(['test/', 'tests/'], 'isdirectory(v:val)'), 0)
                                return ['--recursive', test_dir]
                              endif
                            endfunction
                            
    1              0.000002 function! test#javascript#mocha#build_args(args) abort
                              let args = a:args
                            
                              if test#base#no_colors()
                                let args = ['--no-colors'] + args
                                let args = args + ['|', 'sed -e "s///g"']
                              endif
                            
                              return args
                            endfunction
                            
    1              0.000001 function! test#javascript#mocha#executable() abort
                              if test#javascript#has_package('mocha-webpack')
                                if filereadable('node_modules/.bin/mocha-webpack')
                                  return 'node_modules/.bin/mocha-webpack'
                                else
                                  return 'mocha-webpack'
                                endif
                              else
                                if filereadable('node_modules/.bin/mocha')
                                  return 'node_modules/.bin/mocha'
                                else
                                  return 'mocha'
                                endif
                              endif
                            endfunction
                            
    1              0.000005 function! s:nearest_test(position) abort
                              let name = test#base#nearest_test(a:position, g:test#javascript#patterns)
                              return (len(name['namespace']) ? '^' : '') .
                                   \ test#base#escape_regex(join(name['namespace'] + name['test'])) .
                                   \ (len(name['test']) ? '$' : '')
                            endfunction

SCRIPT  /Users/liss/.local/share/nvim/plugged/vim-test/autoload/test/javascript/jasmine.vim
Sourced 1 time
Total time:   0.001218
 Self time:   0.001218

count  total (s)   self (s)
    1              0.000018 if !exists('g:test#javascript#jasmine#file_pattern')
    1              0.000005   let g:test#javascript#jasmine#file_pattern = '\v^spec/.*spec\.(js|jsx|coffee)$'
    1              0.000001 endif
                            
    1              0.000025 function! test#javascript#jasmine#test_file(file) abort
                              return a:file =~? g:test#javascript#jasmine#file_pattern
                                \ && test#javascript#has_package('jasmine')
                            endfunction
                            
    1              0.000003 function! test#javascript#jasmine#build_position(type, position) abort
                              if a:type ==# 'nearest'
                                let name = s:nearest_test(a:position)
                                if !empty(name)
                                  let name = '--filter='.shellescape(name, 1)
                                endif
                                return [a:position['file'], name]
                              elseif a:type ==# 'file'
                                return [a:position['file']]
                              else
                                return []
                              endif
                            endfunction
                            
    1              0.000002 function! test#javascript#jasmine#build_args(args) abort
                              let args = a:args
                            
                              if test#base#no_colors()
                                let args = ['--no-color'] + args
                              endif
                            
                              return args
                            endfunction
                            
    1              0.000001 function! test#javascript#jasmine#executable() abort
                              if filereadable('node_modules/.bin/jasmine')
                                return 'node_modules/.bin/jasmine'
                              else
                                return 'jasmine'
                              endif
                            endfunction
                            
    1              0.000005 function! s:nearest_test(position) abort
                              let name = test#base#nearest_test(a:position, g:test#javascript#patterns)
                              return join(name['namespace'] + name['test'])
                            endfunction

SCRIPT  /Users/liss/.local/share/nvim/plugged/vim-test/autoload/test/go/gotest.vim
Sourced 1 time
Total time:   0.001132
 Self time:   0.001132

count  total (s)   self (s)
    1              0.000018 if !exists('g:test#go#gotest#file_pattern')
    1              0.000005   let g:test#go#gotest#file_pattern = '\v[^_].*_test\.go$'
    1              0.000002 endif
                            
    1              0.000003 function! test#go#gotest#test_file(file) abort
                              return test#go#test_file('gotest', g:test#go#gotest#file_pattern, a:file)
                            endfunction
                            
    1              0.000002 function! test#go#gotest#build_position(type, position) abort
                              if a:type ==# 'suite'
                                return ['./...']
                              else
                                let path = './'.fnamemodify(a:position['file'], ':h')
                            
                                if a:type ==# 'file'
                                  return path ==# './.' ? [] : [path . '/...']
                                elseif a:type ==# 'nearest'
                                  let name = s:nearest_test(a:position)
                                  return empty(name) ? [] : ['-run '.shellescape(name.'$', 1), path]
                                endif
                              endif
                            endfunction
                            
    1              0.000002 function! test#go#gotest#build_args(args) abort
                              return a:args
                            endfunction
                            
    1              0.000001 function! test#go#gotest#executable() abort
                              return 'go test'
                            endfunction
                            
    1              0.000021 function! s:nearest_test(position) abort
                              let name = test#base#nearest_test(a:position, g:test#go#patterns)
                              return join(name['test'])
                            endfunction

SCRIPT  /Users/liss/.local/share/nvim/plugged/vim-test/autoload/test/go.vim
Sourced 1 time
Total time:   0.001070
 Self time:   0.001070

count  total (s)   self (s)
    1              0.000023 let test#go#patterns = {
                              \ 'test':      ['\v^\s*func (\w+)'],
                              \ 'namespace': [],
                            \}
    1              0.000004 function! test#go#test_file(runner, file_pattern, file) abort
                              if fnamemodify(a:file, ':t') =~# a:file_pattern
                                " given the current runner, check if is can be used with the file
                                if exists('g:test#go#runner')
                                  return a:runner == g:test#go#runner
                                endif
                                let contains_ginkgo_import = (search('github.com/onsi/ginkgo', 'n') > 0)
                                if a:runner ==# 'ginkgo'
                                  return contains_ginkgo_import
                                else
                                  return !contains_ginkgo_import
                                endif
                              endif
                            endfunction

SCRIPT  /Users/liss/.local/share/nvim/plugged/vim-projectionist/autoload/projectionist.vim
Sourced 1 time
Total time:   0.003768
 Self time:   0.003768

count  total (s)   self (s)
                            " Location:     autoload/projectionist.vim
                            " Author:       Tim Pope <http://tpo.pe/>
                            
    1              0.000011 if exists("g:autoloaded_projectionist")
                              finish
                            endif
    1              0.000004 let g:autoloaded_projectionist = 1
                            
                            " Section: Utility
                            
    1              0.000006 function! s:sub(str, pat, repl) abort
                              return substitute(a:str, '\v\C'.a:pat, a:repl, '')
                            endfunction
                            
    1              0.000002 function! s:gsub(str, pat, repl) abort
                              return substitute(a:str, '\v\C'.a:pat, a:repl, 'g')
                            endfunction
                            
    1              0.000002 function! s:startswith(str, prefix) abort
                              return strpart(a:str, 0, len(a:prefix)) ==# a:prefix
                            endfunction
                            
    1              0.000001 function! s:endswith(str, suffix) abort
                              return strpart(a:str, len(a:str) - len(a:suffix)) ==# a:suffix
                            endfunction
                            
    1              0.000001 function! s:uniq(list) abort
                              let i = 0
                              let seen = {}
                              while i < len(a:list)
                                let str = string(a:list[i])
                                if has_key(seen, str)
                                  call remove(a:list, i)
                                else
                                  let seen[str] = 1
                                  let i += 1
                                endif
                              endwhile
                              return a:list
                            endfunction
                            
    1              0.000002 function! projectionist#lencmp(i1, i2) abort
                              return len(a:i1) - len(a:i2)
                            endfunction
                            
    1              0.000002 function! s:real(file) abort
                              let pre = substitute(matchstr(a:file, '^\a\a\+\ze:'), '^.', '\u&', '')
                              if empty(pre)
                                let path = s:absolute(a:file, getcwd())
                              elseif exists('*' . pre . 'Real')
                                let path = {pre}Real(a:file)
                              else
                                let path = a:file
                              endif
                              return exists('+shellslash') && !&shellslash ? tr(path, '/', '\') : path
                            endfunction
                            
    1              0.000001 function! projectionist#slash(...) abort
                              let s = exists('+shellslash') && !&shellslash ? '\' : '/'
                              return a:0 ? tr(a:1, '/', s) : s
                            endfunction
                            
    1              0.000001 function! s:slash(str) abort
                              return tr(a:str, projectionist#slash(), '/')
                            endfunction
                            
    1              0.000001 function! projectionist#json_parse(string) abort
                              let [null, false, true] = ['', 0, 1]
                              let string = type(a:string) == type([]) ? join(a:string, ' ') : a:string
                              let stripped = substitute(string, '\C"\(\\.\|[^"\\]\)*"', '', 'g')
                              if stripped !~# "[^,:{}\\[\\]0-9.\\-+Eaeflnr-u \n\r\t]"
                                try
                                  return eval(substitute(string, "[\r\n]", ' ', 'g'))
                                catch
                                endtry
                              endif
                              throw "invalid JSON: ".string
                            endfunction
                            
    1              0.000002 function! projectionist#shellescape(arg) abort
                              return a:arg =~# "^[[:alnum:]_/.:-]\\+$" ? a:arg : shellescape(a:arg)
                            endfunction
                            
    1              0.000001 function! projectionist#shellpath(arg) abort
                              if empty(a:arg)
                                return ''
                              elseif a:arg =~# '^[[:alnum:].+-]\+:'
                                return projectionist#shellescape(s:real(a:arg))
                              else
                                return projectionist#shellescape(a:arg)
                              endif
                            endfunction
                            
    1              0.000001 function! s:join(arg) abort
                              if type(a:arg) == type([])
                                return join(a:arg, ' ')
                              elseif type(a:arg) == type('')
                                return a:arg
                              else
                                return ''
                              endif
                            endfunction
                            
    1              0.000018 function! s:parse(mods, args) abort
                              let flags = ''
                              let pres = []
                              let cmd = {'args': []}
                              if a:mods ==# '' || a:mods ==# '<mods>'
                                let cmd.mods = ''
                              else
                                let cmd.mods = a:mods . ' '
                              endif
                              let args = copy(a:args)
                              while !empty(args)
                                if args[0] =~# "^++mods="
                                  let cmd.mods .= args[0][8:-1] . ' '
                                elseif args[0] =~# '^++'
                                  let flags .= ' ' . args[0]
                                elseif args[0] =~# '^+.'
                                  call add(pres, args[0][1:-1])
                                elseif args[0] !=# '+'
                                  call add(cmd.args, args[0])
                                endif
                                call remove(args, 0)
                              endwhile
                            
                              let cmd.pre = flags . (empty(pres) ? '' : ' +'.escape(join(pres, '|'), '| '))
                              return cmd
                            endfunction
                            
    1              0.000004 if !exists('s:loaded')
    1              0.000003   let s:loaded = {}
    1              0.000001 endif
    1              0.000001 function! s:fcall(fn, path, ...) abort
                              let ns = matchstr(a:path, '^\a\a\+\ze:')
                              if len(ns) && !has_key(s:loaded, ns) && len(findfile('autoload/' . ns . '.vim', escape(&rtp, ' ')))
                                exe 'runtime! autoload/' . ns . '.vim'
                                let s:loaded[ns] = 1
                              endif
                              if len(ns) && exists('*' . ns . '#' . a:fn)
                                return call(ns . '#' . a:fn, [a:path] + a:000)
                              else
                                return call(a:fn, [a:path] + a:000)
                              endif
                            endfunction
                            
    1              0.000002 function! s:mkdir_p(path) abort
                              if a:path !~# '^\a[[:alnum:].+-]\+:' && !isdirectory(a:path)
                                call mkdir(a:path, 'p')
                              endif
                            endfunction
                            
                            " Section: Querying
                            
    1              0.000001 function! s:roots() abort
                              return reverse(sort(keys(get(b:, 'projectionist', {})), function('projectionist#lencmp')))
                            endfunction
                            
    1              0.000186 function! projectionist#path(...) abort
                              let abs = '^[' . projectionist#slash() . '/]\|^\a\+:\|^\.\.\=\%(/\|$\)'
                              if a:0 && s:slash(a:1) =~# abs || (a:0 > 1 && a:2 is# 0)
                                return s:slash(a:1)
                              endif
                              if a:0 && type(a:1) ==# type(0)
                                let root = get(s:roots(), (a:1 < 0 ? -a:1 : a:1) - 1, '')
                                if a:0 > 1
                                  if a:2 =~# abs
                                    return a:2
                                  endif
                                  let file = a:2
                                endif
                              elseif a:0 > 1 && type(a:2) == type('')
                                let root = substitute(s:slash(a:2), '/$', '', '')
                                let file = a:1
                                if empty(root)
                                  return file
                                endif
                              elseif a:0 == 1 && empty(a:1)
                                return ''
                              else
                                let root = get(s:roots(), a:0 > 1 ? (a:2 < 0 ? -a:2 : a:2) - 1 : 0, '')
                                if a:0
                                  let file = a:1
                                endif
                              endif
                              if !empty(root) && exists('file')
                                return root . '/' . file
                              else
                                return root
                              endif
                            endfunction
                            
    1              0.000004 function! s:path(path, ...) abort
                              if a:0 || type(a:path) == type(0)
                                return call('projectionist#path', [a:path] + a:000)
                              else
                                return a:path
                              endif
                            endfunction
                            
    1              0.000002 function! projectionist#filereadable(...) abort
                              return s:fcall('filereadable', call('s:path', a:000))
                            endfunction
                            
    1              0.000001 function! projectionist#isdirectory(...) abort
                              return s:fcall('isdirectory', call('s:path', a:000))
                            endfunction
                            
    1              0.000001 function! projectionist#getftime(...) abort
                              return s:fcall('getftime', call('s:path', a:000))
                            endfunction
                            
    1              0.000001 function! projectionist#readfile(path, ...) abort
                              let args = copy(a:000)
                              let path = a:path
                              if get(args, 0, '') =~# '[\/.]' || type(get(args, 0, '')) == type(0) || type(path) == type(0)
                                let path = projectionist#path(path, remove(args, 0))
                              endif
                              return call('s:fcall', ['readfile'] + [path] + args)
                            endfunction
                            
    1              0.000001 function! projectionist#glob(file, ...) abort
                              let root = ''
                              if a:0
                                let root = projectionist#path('', a:1)
                              endif
                              let path = s:absolute(a:file, root)
                              if v:version >= 704
                                let files = s:fcall('glob', path, a:0 > 1 ? a:2 : 0, 1)
                              else
                                let files = split(s:fcall('glob', path), "\n")
                              endif
                              if len(root) || a:0 && a:1 is# 0
                                call map(files, 's:slash(v:val) . (v:val !~# "[\/]$" && projectionist#isdirectory(v:val) ? "/" : "")')
                              endif
                              if len(root)
                                call map(files, 'strpart(v:val, 0, len(root)) ==# root ? strpart(v:val, len(root)) : v:val')
                              endif
                              return files
                            endfunction
                            
    1              0.000002 function! projectionist#real(...) abort
                              return s:real(call('s:path', a:000))
                            endfunction
                            
    1              0.000001 function! s:all() abort
                              let all = []
                              for key in s:roots()
                                for value in b:projectionist[key]
                                  call add(all, [key, value])
                                endfor
                              endfor
                              return all
                            endfunction
                            
    1              0.000006 if !exists('g:projectionist_transformations')
    1              0.000003   let g:projectionist_transformations = {}
    1              0.000001 endif
                            
    1              0.000002 function! g:projectionist_transformations.dot(input, o) abort
                              return substitute(a:input, '/', '.', 'g')
                            endfunction
                            
    1              0.000017 function! g:projectionist_transformations.underscore(input, o) abort
                              return substitute(a:input, '/', '_', 'g')
                            endfunction
                            
    1              0.000002 function! g:projectionist_transformations.backslash(input, o) abort
                              return substitute(a:input, '/', '\\', 'g')
                            endfunction
                            
    1              0.000001 function! g:projectionist_transformations.colons(input, o) abort
                              return substitute(a:input, '/', '::', 'g')
                            endfunction
                            
    1              0.000001 function! g:projectionist_transformations.hyphenate(input, o) abort
                              return tr(a:input, '_', '-')
                            endfunction
                            
    1              0.000001 function! g:projectionist_transformations.blank(input, o) abort
                              return tr(a:input, '_-', '  ')
                            endfunction
                            
    1              0.000001 function! g:projectionist_transformations.uppercase(input, o) abort
                              return toupper(a:input)
                            endfunction
                            
    1              0.000001 function! g:projectionist_transformations.camelcase(input, o) abort
                              return substitute(a:input, '[_-]\(.\)', '\u\1', 'g')
                            endfunction
                            
    1              0.000001 function! g:projectionist_transformations.capitalize(input, o) abort
                              return substitute(a:input, '\%(^\|/\)\zs\(.\)', '\u\1', 'g')
                            endfunction
                            
    1              0.000017 function! g:projectionist_transformations.snakecase(input, o) abort
                              let str = a:input
                              let str = substitute(str, '\v(\u+)(\u\l)', '\1_\2', 'g')
                              let str = substitute(str, '\v(\l|\d)(\u)', '\1_\2', 'g')
                              let str = tolower(str)
                              return str
                            endfunction
                            
    1              0.000001 function! g:projectionist_transformations.dirname(input, o) abort
                              return substitute(a:input, '.[^'.projectionist#slash().'/]*$', '', '')
                            endfunction
                            
    1              0.000003 function! g:projectionist_transformations.basename(input, o) abort
                              return substitute(a:input, '.*['.projectionist#slash().'/]', '', '')
                            endfunction
                            
    1              0.000001 function! g:projectionist_transformations.singular(input, o) abort
                              let input = a:input
                              let input = s:sub(input, '%([Mm]ov|[aeio])@<!ies$', 'ys')
                              let input = s:sub(input, '[rl]@<=ves$', 'fs')
                              let input = s:sub(input, '%(nd|rt)@<=ices$', 'exs')
                              let input = s:sub(input, 's@<!s$', '')
                              let input = s:sub(input, '%([nrt]ch|tatus|lias|ss)@<=e$', '')
                              return input
                            endfunction
                            
    1              0.000001 function! g:projectionist_transformations.plural(input, o) abort
                              let input = a:input
                              let input = s:sub(input, '[aeio]@<!y$', 'ie')
                              let input = s:sub(input, '[rl]@<=f$', 've')
                              let input = s:sub(input, '%(nd|rt)@<=ex$', 'ice')
                              let input = s:sub(input, '%([osxz]|[cs]h)$', '&e')
                              let input .= 's'
                              return input
                            endfunction
                            
    1              0.000002 function! g:projectionist_transformations.open(input, o) abort
                              return '{'
                            endfunction
                            
    1              0.000001 function! g:projectionist_transformations.close(input, o) abort
                              return '}'
                            endfunction
                            
    1              0.000001 function! g:projectionist_transformations.nothing(input, o) abort
                              return ''
                            endfunction
                            
    1              0.000001 function! g:projectionist_transformations.vim(input, o) abort
                              return a:input
                            endfunction
                            
    1              0.000002 function! s:expand_placeholder(placeholder, expansions) abort
                              let transforms = split(a:placeholder[1:-2], '|')
                              if has_key(a:expansions, get(transforms, 0, '}'))
                                let value = a:expansions[remove(transforms, 0)]
                              else
                                let value = get(a:expansions, 'match', "\030")
                              endif
                              for transform in transforms
                                if !has_key(g:projectionist_transformations, transform)
                                  return "\030"
                                endif
                                let value = g:projectionist_transformations[transform](value, a:expansions)
                                if value =~# "\030"
                                  return "\030"
                                endif
                              endfor
                              if has_key(a:expansions, 'post_function')
                                let value = call(a:expansions.post_function, [value])
                              endif
                              return value
                            endfunction
                            
    1              0.000021 function! s:expand_placeholders(value, expansions, ...) abort
                              if type(a:value) ==# type([]) || type(a:value) ==# type({})
                                return filter(map(copy(a:value), 's:expand_placeholders(v:val, a:expansions, 1)'), 'type(v:val) !=# type("") || v:val !~# "[\001-\006\016-\037]"')
                              endif
                              let value = substitute(a:value, '{[^{}]*}', '\=s:expand_placeholder(submatch(0), a:expansions)', 'g')
                              return !a:0 && value =~# "[\001-\006\016-\037]" ? '' : value
                            endfunction
                            
    1              0.000004 let s:valid_key = '^\%([^*{}]*\*\*[^*{}]\{2\}\)\=[^*{}]*\*\=[^*{}]*$'
                            
    1              0.000002 function! s:match(file, pattern) abort
                              if a:pattern =~# '^[^*{}]*\*[^*{}]*$'
                                let pattern = s:slash(substitute(a:pattern, '\*', '**/*', ''))
                              elseif a:pattern =~# '^[^*{}]*\*\*[^*{}]\+\*[^*{}]*$'
                                let pattern = s:slash(a:pattern)
                              else
                                return ''
                              endif
                              let [prefix, infix, suffix] = split(pattern, '\*\*\=', 1)
                              let file = s:slash(a:file)
                              if !s:startswith(file, prefix) || !s:endswith(file, suffix)
                                return ''
                              endif
                              let match = file[strlen(prefix) : -strlen(suffix)-1]
                              if infix ==# '/'
                                return match
                              endif
                              let clean = substitute('/'.match, '\V'.infix.'\ze\[^/]\*\$', '/', '')[1:-1]
                              return clean ==# match ? '' : clean
                            endfunction
                            
    1              0.000002 function! projectionist#query_raw(key, ...) abort
                              let candidates = []
                              let file = a:0 ? a:1 : get(b:, 'projectionist_file', expand('%:p'))
                              for [path, projections] in s:all()
                                let pre = path . projectionist#slash()
                                let attrs = {'project': path, 'file': file}
                                let name = file[strlen(path)+1:-1]
                                if strpart(file, 0, len(path)) !=# path
                                  let name = ''
                                endif
                                if has_key(projections, name) && has_key(projections[name], a:key)
                                  call add(candidates, [projections[name][a:key], attrs])
                                endif
                                for pattern in reverse(sort(filter(keys(projections), 'v:val =~# s:valid_key && v:val =~# "\\*"'), function('projectionist#lencmp')))
                                  let match = s:match(name, pattern)
                                  if (!empty(match) || pattern ==# '*') && has_key(projections[pattern], a:key)
                                    let expansions = extend({'match': match}, attrs)
                                    call add(candidates, [projections[pattern][a:key], expansions])
                                  endif
                                endfor
                              endfor
                              return candidates
                            endfunction
                            
    1              0.000003 function! projectionist#query(key, ...) abort
                              let candidates = []
                              let file = a:0 > 1 ? a:2 : get(a:0 ? a:1 : {}, 'file', get(b:, 'projectionist_file', expand('%:p')))
                              for [value, expansions] in projectionist#query_raw(a:key, file)
                                call extend(expansions, a:0 ? a:1 : {}, 'keep')
                                call add(candidates, [expansions.project, s:expand_placeholders(value, expansions)])
                                unlet value
                              endfor
                              return candidates
                            endfunction
                            
    1              0.000002 function! s:absolute(path, in) abort
                              if a:path =~# '^\%([[:alnum:].+-]\+:\)\|^\.\?[\/]\|^$'
                                return a:path
                              else
                                return substitute(a:in, '[\/]$', '', '') . projectionist#slash() . a:path
                              endif
                            endfunction
                            
    1              0.000001 function! projectionist#query_file(key, ...) abort
                              let files = []
                              let _ = {}
                              for [root, _.match] in projectionist#query(a:key, a:0 ? a:1 : {})
                                call extend(files, map(filter(type(_.match) == type([]) ? copy(_.match) : [_.match], 'len(v:val)'), 's:absolute(v:val, root)'))
                              endfor
                              return s:uniq(files)
                            endfunction
                            
    1              0.000003 let s:projectionist_max_file_recursion = 3
                            
    1              0.000001 function! s:query_file_recursive(key, ...) abort
                              let keys = type(a:key) == type([]) ? a:key : [a:key]
                              let start_file = get(a:0 ? a:1 : {}, 'file', get(b:, 'projectionist_file', expand('%:p')))
                              let files = []
                              let visited_files = {start_file : 1}
                              let current_files = [start_file]
                              let depth = 0
                              while !empty(current_files) && depth < s:projectionist_max_file_recursion
                                let next_files = []
                                for file in current_files
                                  let query_opts = extend(a:0 ? copy(a:1) : {}, {'file': file})
                                  for key in keys
                                    let [root, match] = get(projectionist#query(key, query_opts), 0, ['', []])
                                    let subfiles = type(match) == type([]) ? copy(match) : [match]
                                    call map(filter(subfiles, 'len(v:val)'), 's:absolute(v:val, root)')
                                    if !empty(subfiles)
                                      break
                                    endif
                                  endfor
                                  for subfile in subfiles
                                    if !has_key(visited_files, subfile)
                                      let visited_files[subfile] = 1
                                      call add(files, subfile)
                                      call add(next_files, subfile)
                                    endif
                                  endfor
                                endfor
                                let current_files = next_files
                                let depth += 1
                              endwhile
                              return files
                            endfunction
                            
    1              0.000017 function! s:shelljoin(val) abort
                              return substitute(s:join(a:val), '["'']\([{}]\)["'']', '\1', 'g')
                            endfunction
                            
    1              0.000001 function! projectionist#query_exec(key, ...) abort
                              let opts = extend({'post_function': 'projectionist#shellpath'}, a:0 ? a:1 : {})
                              return filter(map(projectionist#query(a:key, opts), '[s:real(v:val[0]), s:shelljoin(v:val[1])]'), '!empty(v:val[0]) && !empty(v:val[1])')
                            endfunction
                            
    1              0.000001 function! projectionist#query_scalar(key) abort
                              let values = []
                              for [root, match] in projectionist#query(a:key)
                                if type(match) == type([])
                                  call extend(values, match)
                                elseif type(match) !=# type({})
                                  call add(values, match)
                                endif
                                unlet match
                              endfor
                              return values
                            endfunction
                            
    1              0.000006 function! s:query_exec_with_alternate(key) abort
                              let values = projectionist#query_exec(a:key)
                              for file in projectionist#query_file('alternate')
                                for [root, match] in projectionist#query_exec(a:key, {'file': file})
                                  if filereadable(file)
                                    call add(values, [root, match])
                                  endif
                                  unlet match
                                endfor
                              endfor
                              return values
                            endfunction
                            
                            " Section: Activation
                            
    1              0.000003 function! projectionist#append(root, ...) abort
                              if type(a:root) != type('') || empty(a:root)
                                return
                              endif
                              let projections = get(a:000, -1, {})
                              if type(projections) == type('') && !empty(projections)
                                try
                                  let l:.projections = projectionist#json_parse(projectionist#readfile(projections, a:root))
                                catch
                                  let l:.projections = {}
                                endtry
                              endif
                              if type(projections) == type({})
                                let root = projectionist#slash(substitute(a:root, '.\zs[' . projectionist#slash() . '/]$', '', ''))
                                if !has_key(b:projectionist, root)
                                  let b:projectionist[root] = []
                                endif
                                call add(b:projectionist[root], filter(projections, 'type(v:val) == type({})'))
                                return 1
                              endif
                            endfunction
                            
    1              0.000002 function! projectionist#define_navigation_command(command, patterns) abort
                              for [prefix, excmd] in items(s:prefixes)
                                execute 'command! -buffer -bar -bang -nargs=* -complete=customlist,s:projection_complete'
                                      \ prefix . substitute(a:command, '\A', '', 'g')
                                      \ ':execute s:open_projection("<mods>", "'.excmd.'<bang>",'.string(a:patterns).',<f-args>)'
                              endfor
                            endfunction
                            
    1              0.000015 function! projectionist#activate() abort
                              if empty(b:projectionist)
                                return
                              endif
                              if len(s:real(s:roots()[0]))
                                command! -buffer -bar -bang -nargs=? -range=1 -complete=customlist,s:dir_complete Pcd
                                      \ exe 'cd' projectionist#real(projectionist#path(<count>) . '/' . <q-args>)
                                command! -buffer -bar -bang -nargs=* -range=1 -complete=customlist,s:dir_complete Plcd
                                      \ exe (<bang>0 ? 'cd' : 'lcd') projectionist#real(projectionist#path(<count>) . '/' . <q-args>)
                                if exists(':Cd') != 2
                                  command! -buffer -bar -bang -nargs=? -range=1 -complete=customlist,s:dir_complete Cd
                                        \ exe 'cd' projectionist#real(projectionist#path(<line2>) . '/' . <q-args>)
                                endif
                                if exists(':Lcd') != 2
                                  command! -buffer -bar -bang -nargs=? -range=1 -complete=customlist,s:dir_complete Lcd
                                        \ exe (<bang>0 ? 'cd' : 'lcd') projectionist#real(projectionist#path(<line2>) . '/' . <q-args>)
                                endif
                                command! -buffer -bang -nargs=1 -range=0 -complete=command ProjectDo
                                      \ exe s:do('<bang>', <count>==<line1>?<count>:-1, <q-args>)
                              endif
                              for [command, patterns] in items(projectionist#navigation_commands())
                                call projectionist#define_navigation_command(command, patterns)
                              endfor
                              for [prefix, excmd] in items(s:prefixes) + [['', 'edit']]
                                execute 'command! -buffer -bar -bang -nargs=* -range=-1 -complete=customlist,s:edit_complete'
                                      \ 'A'.prefix
                                      \ ':execute s:edit_command("<mods>", "'.excmd.'<bang>", <count>, <f-args>)'
                              endfor
                            
                              for [root, makeprg] in projectionist#query_exec('make')
                                unlet! b:current_compiler
                                let compiler = fnamemodify(matchstr(makeprg, '\S\+'), ':t:r')
                                setlocal errorformat=%+I%.%#,
                                if exists(':Dispatch')
                                  silent! let compiler = dispatch#compiler_for_program(makeprg)
                                endif
                                if !empty(findfile('compiler/'.compiler.'.vim', escape(&rtp, ' ')))
                                  execute 'compiler' compiler
                                elseif compiler ==# 'make'
                                  setlocal errorformat<
                                endif
                                let &l:makeprg = makeprg
                                let &l:errorformat .= ',%\&chdir '.escape(root, ',')
                                break
                              endfor
                            
                              for [root, command] in projectionist#query_exec('console')
                                let offset = index(s:roots(), root) + 1
                                let b:start = '-dir=' . fnameescape(root) .
                                      \ ' -title=' . escape(fnamemodify(root, ':t'), '\ ') . '\ console ' .
                                      \ command
                                execute 'command! -bar -bang -buffer -nargs=* Console ' .
                                      \ (exists(':Start') < 2 ?
                                      \ 'ProjectDo ' . (offset == 1 ? '' : offset.' ') . '!' . command :
                                      \ 'Start<bang> ' . b:start) . ' <args>'
                                break
                              endfor
                            
                              for [root, command] in projectionist#query_exec('start')
                                let offset = index(s:roots(), root) + 1
                                let b:start = '-dir=' . fnameescape(root) . ' ' . command
                                break
                              endfor
                            
                              for [root, command] in s:query_exec_with_alternate('dispatch')
                                let b:dispatch = '-dir=' . fnameescape(root) . ' ' . command
                                break
                              endfor
                            
                              for dir in projectionist#query_file('path')
                                let dir = substitute(dir, '^\a\a\+:', '+&', '')
                                if stridx(','.&l:path.',', ','.escape(dir, ', ').',') < 0
                                  let &l:path = escape(dir, ', ') . ',' . &path
                                endif
                              endfor
                            
                              for root in s:roots()
                                let tags = s:real(root . projectionist#slash() . 'tags')
                                if len(tags) && stridx(','.&l:tags.',', ','.escape(tags, ', ').',') < 0
                                  let &l:tags = &tags . ',' . escape(tags, ', ')
                                endif
                              endfor
                            
                              if exists('#User#ProjectionistActivate')
                                doautocmd User ProjectionistActivate
                              endif
                            endfunction
                            
                            " Section: Completion
                            
    1              0.000003 function! projectionist#completion_filter(results, query, sep, ...) abort
                              if a:query =~# '\*'
                                let regex = s:gsub(a:query, '\*', '.*')
                                return filter(copy(a:results),'v:val =~# "^".regex')
                              endif
                            
                              let C = get(g:, 'projectionist_completion_filter', get(g:, 'completion_filter'))
                              if type(C) == type({}) && has_key(C, 'Apply')
                                let results = call(C.Apply, [a:results, a:query, a:sep, a:0 ? a:1 : {}], C)
                              elseif type(C) == type('') && exists('*'.C)
                                let results = call(C, [a:results, a:query, a:sep, a:0 ? a:1 : {}])
                              endif
                              if get(l:, 'results') isnot# 0
                                return results
                              endif
                              unlet! results
                            
                              let results = s:uniq(sort(copy(a:results)))
                              call filter(results,'v:val !~# "\\~$" && !empty(v:val)')
                              let filtered = filter(copy(results),'v:val[0:strlen(a:query)-1] ==# a:query')
                              if !empty(filtered) | return filtered | endif
                              if !empty(a:sep)
                                let regex = s:gsub(a:query,'[^'.a:sep.']','[&].*')
                                let filtered = filter(copy(results),'v:val =~# "^".regex')
                                if !empty(filtered) | return filtered | endif
                                let filtered = filter(copy(results),'a:sep.v:val =~# ''['.a:sep.']''.regex')
                                if !empty(filtered) | return filtered | endif
                              endif
                              let regex = s:gsub(a:query,'.','[&].*')
                              let filtered = filter(copy(results),'v:val =~# regex')
                              return filtered
                            endfunction
                            
    1              0.000004 function! s:dir_complete(lead, cmdline, _) abort
                              let pattern = substitute(a:lead, '^\@!\%(^\a\+:/*\)\@<!\%(^\.\.\=\)\@<!/', '*&', 'g') . '*/'
                              let c = matchstr(a:cmdline, '^\d\+')
                              let matches = projectionist#glob(pattern, projectionist#real(c ? c : 1))
                              return map(matches, 'fnameescape(v:val)')
                            endfunction
                            
                            " Section: Navigation commands
                            
    1              0.000009 let s:prefixes = {
                                  \ 'E': 'edit',
                                  \ 'S': 'split',
                                  \ 'V': 'vsplit',
                                  \ 'T': 'tabedit',
                                  \ 'D': 'read'}
                            
    1              0.000002 function! projectionist#navigation_commands() abort
                              let commands = {}
                              for [path, projections] in s:all()
                                for [pattern, projection] in items(projections)
                                  let name = s:gsub(get(projection, 'command', get(projection, 'type', get(projection, 'name', ''))), '\A', '')
                                  if !empty(name) && pattern =~# s:valid_key
                                    if !has_key(commands, name)
                                      let commands[name] = []
                                    endif
                                    let command = [path, pattern]
                                    call add(commands[name], command)
                                  endif
                                endfor
                              endfor
                              call filter(commands, '!empty(v:val)')
                              return commands
                            endfunction
                            
    1              0.000018 function! s:find_related_file(patterns) abort
                              let alternates = s:query_file_recursive(['related', 'alternate'], {'lnum': 0})
                              for alternate in alternates
                                for pattern in a:patterns
                                  if !empty(s:match(alternate, pattern))
                                    return alternate
                                  endif
                                endfor
                              endfor
                              let current_file = get(b:, 'projectionist_file', expand('%:p'))
                              for pattern in a:patterns
                                if pattern !~# '\*'
                                  continue
                                endif
                                for candidate in projectionist#glob(pattern)
                                  let candidate_alternates = s:query_file_recursive(
                                        \ ['related', 'alternate'],
                                        \ {'lnum': 0, 'file': candidate})
                                  for candidate_alternate in candidate_alternates
                                    if candidate_alternate ==# current_file
                                      return candidate
                                    endif
                                    for alternate in alternates
                                      if alternate ==# candidate_alternate
                                        return candidate
                                      endif
                                    endfor
                                  endfor
                                endfor
                              endfor
                            endfunction
                            
    1              0.000017 function! s:open_projection(mods, edit, variants, ...) abort
                              let formats = []
                              for variant in a:variants
                                call add(formats, variant[0] . projectionist#slash() . (variant[1] =~# '\*\*'
                                      \ ? variant[1] : substitute(variant[1], '\*', '**/*', '')))
                              endfor
                              let cmd = s:parse(a:mods, a:000)
                              if get(cmd.args, -1, '') ==# '`=`'
                                let s:last_formats = formats
                                return ''
                              endif
                              if len(cmd.args)
                                call filter(formats, 'v:val =~# "\\*"')
                                let name = join(cmd.args, ' ')
                                let dir = matchstr(name, '.*\ze/')
                                let base = matchstr(name, '[^\/]*$')
                                call map(formats, 'substitute(substitute(v:val, "\\*\\*\\([\\/]\\=\\)", empty(dir) ? "" : dir . "\\1", ""), "\\*", base, "")')
                              else
                                let related_file = s:find_related_file(formats)
                                if !empty(related_file)
                                  let formats = [related_file]
                                else
                                  call filter(formats, 'v:val !~# "\\*"')
                                endif
                              endif
                              if empty(formats)
                                return 'echoerr "Invalid number of arguments"'
                              endif
                              let target = formats[0]
                              for format in formats
                                if projectionist#filereadable(format)
                                  let target = format
                                  break
                                endif
                              endfor
                              call s:mkdir_p(fnamemodify(target, ':h'))
                              return cmd.mods . a:edit . cmd.pre . ' ' .
                                    \ fnameescape(fnamemodify(target, ':~:.'))
                            endfunction
                            
    1              0.000003 function! s:projection_complete(lead, cmdline, _) abort
                              execute matchstr(a:cmdline, '\a\@<![' . join(keys(s:prefixes), '') . ']\w\+') . ' `=`'
                              let results = []
                              for format in s:last_formats
                                if format !~# '\*'
                                  continue
                                endif
                                let glob = substitute(format, '[^\/]*\ze\*\*[\/]\*', '', 'g')
                                let results += map(projectionist#glob(glob), 's:match(v:val, format)')
                              endfor
                              call s:uniq(results)
                              return map(projectionist#completion_filter(results, a:lead, '/'), 'fnameescape(v:val)')
                            endfunction
                            
                            " Section: :A
                            
    1              0.000001 function! s:jumpopt(file) abort
                              let pattern = '!$\|[:+@#]\d\+$\|[+@#].*$'
                              let file = substitute(a:file, pattern, '', '')
                              let jump = matchstr(a:file, pattern)
                              if jump =~# '^[:+@#]\d\+$'
                                return [file, '+'.jump[1:-1].' ']
                              elseif jump ==# '!'
                                return [file, '+AD ']
                              elseif !empty(jump)
                                return [file, '+A'.escape(jump, ' ').' ']
                              else
                                return [file, '']
                              endif
                            endfunction
                            
    1              0.000002 function! s:edit_command(mods, edit, count, ...) abort
                              let cmd = s:parse(a:mods, a:000)
                              let file = join(cmd.args, ' ')
                              if len(file)
                                if file =~# '^[@#+]'
                                  return 'echoerr ":A: @/#/+ not supported"'
                                endif
                                let open = s:jumpopt(projectionist#path(file, a:count < 1 ? 1 : a:count))
                                if empty(open[0])
                                  return 'echoerr "Invalid count"'
                                endif
                              elseif a:edit =~# 'read'
                                call projectionist#apply_template()
                                return ''
                              else
                                let expansions = {}
                                if a:count > 0
                                  let expansions.lnum = a:count
                                endif
                                let alternates = projectionist#query_file('alternate', expansions)
                                let warning = get(filter(copy(alternates), 'v:val =~# "replace %.*}"'), 0, '')
                                if !empty(warning)
                                  return 'echoerr '.string(matchstr(warning, 'replace %.*}').' in alternate projection')
                                endif
                                call map(alternates, 's:jumpopt(v:val)')
                                let open = get(filter(copy(alternates), 'projectionist#getftime(v:val[0]) >= 0'), 0, [])
                                if empty(alternates)
                                  return 'echoerr "No alternate file"'
                                elseif empty(open)
                                  let choices = ['Create alternate file?']
                                  let i = 0
                                  for [alt, _] in alternates
                                    let i += 1
                                    call add(choices, i.' '.alt)
                                  endfor
                                  let i = inputlist(choices)
                                  if i > 0
                                    let open = get(alternates, i-1, [])
                                  endif
                                  if empty(open)
                                    return ''
                                  endif
                                endif
                              endif
                              let [file, jump] = open
                              call s:mkdir_p(fnamemodify(file, ':h'))
                              return cmd.mods . a:edit . cmd.pre . ' ' .
                                    \ jump . fnameescape(fnamemodify(file, ':~:.'))
                            endfunction
                            
    1              0.000002 function! s:edit_complete(lead, cmdline, _) abort
                              let pattern = substitute(a:lead, '^\@!\%(^\a\+:/*\)\@<!\%(^\.\.\=\)\@<!/', '*&', 'g') . '*'
                              let c = matchstr(a:cmdline, '^\d\+')
                              let matches = projectionist#glob(pattern, c ? c : 1)
                              return map(matches, 'fnameescape(v:val)')
                            endfunction
                            
                            " Section: :ProjectDo
                            
    1              0.000002 function! s:do(bang, count, cmd) abort
                              let cd = exists('*haslocaldir') && haslocaldir() ? 'lcd' : 'cd'
                              let cwd = getcwd()
                              let cmd = substitute(a:cmd, '^\d\+ ', '', '')
                              let offset = cmd ==# a:cmd ? 1 : matchstr(a:cmd, '^\d\+')
                              try
                                execute cd fnameescape(projectionist#real('', offset))
                                execute (a:count >= 0 ? a:count : '').substitute(cmd, '\>', a:bang, '')
                              catch
                                return 'echoerr '.string(v:exception)
                              finally
                                execute cd fnameescape(cwd)
                              endtry
                              return ''
                            endfunction
                            
                            " Section: Make
                            
    1              0.000001 function! s:qf_pre() abort
                              let dir = substitute(matchstr(','.&l:errorformat, ',\%(%\\&\)\=\%(ch\)\=dir[ =]\zs\%(\\.\|[^,]\)*'), '\\,' ,',', 'g')
                              let cwd = getcwd()
                              if !empty(dir) && dir !=# cwd
                                let cd = exists('*haslocaldir') && haslocaldir() ? 'lcd' : 'cd'
                                execute cd fnameescape(dir)
                                let s:qf_post = cd . ' ' . fnameescape(cwd)
                              endif
                            endfunction
                            
    1              0.000005 augroup projectionist_make
    1              0.000245   autocmd!
    1              0.000037   autocmd QuickFixCmdPre  *make* call s:qf_pre()
    1              0.000020   autocmd QuickFixCmdPost *make*
                                    \ if exists('s:qf_post') | execute remove(s:, 'qf_post') | endif
    1              0.000002 augroup END
                            
                            " Section: Templates
                            
    1              0.000003 function! projectionist#apply_template() abort
                              if !&modifiable
                                return ''
                              endif
                              let template = get(projectionist#query('template'), 0, ['', ''])[1]
                              if type(template) == type([]) && type(get(template, 0)) == type([])
                                let template = template[0]
                              endif
                              if type(template) == type([])
                                let l:.template = join(template, "\n")
                              endif
                              if !empty(template)
                                let template = s:gsub(template, '\t', repeat(' ', &sw))
                                if !&et
                                  let template = s:gsub(template, repeat(' ', &ts), "\t")
                                endif
                                silent %delete_
                                call setline(1, split(template, "\n"))
                                 if exists('#User#ProjectionistApplyTemplate')
                                   doautocmd User ProjectionistApplyTemplate
                                 endif
                                doautocmd BufReadPost
                              endif
                              return ''
                            endfunction

FUNCTION  FugitiveExtractGitDir()
Called 9 times
Total time:   0.010818
 Self time:   0.006718

count  total (s)   self (s)
    9   0.000148   0.000068   let path = s:Slash(a:path)
    9              0.000066   if path =~# '^fugitive:'
                                return matchstr(path, '\C^fugitive:\%(//\)\=\zs.\{-\}\ze\%(//\|::\|$\)')
                              elseif empty(path)
                                return ''
                              elseif isdirectory(path)
                                let path = fnamemodify(path, ':p:s?/$??')
                              else
    9              0.000358     let path = fnamemodify(path, ':p:h:s?/$??')
    9              0.000011   endif
    9              0.000168   let pre = substitute(matchstr(path, '^\a\a\+\ze:'), '^.', '\u&', '')
    9              0.000033   if len(pre) && exists('*' . pre . 'Real')
                                let path = s:Slash({pre}Real(path))
                              endif
    9              0.000374   let root = resolve(path)
    9              0.000021   if root !=# path
                                silent! exe (haslocaldir() ? 'lcd' : exists(':tcd') && haslocaldir(-1) ? 'tcd' : 'cd') '.'
                              endif
    9              0.000012   let previous = ""
    9              0.000100   let env_git_dir = len($GIT_DIR) ? s:Slash(simplify(fnamemodify(FugitiveVimPath($GIT_DIR), ':p:s?[\/]$??'))) : ''
    9   0.000298   0.000159   call s:Tree(env_git_dir)
   25              0.000061   while root !=# previous
   25              0.000312     if root =~# '\v^//%([^/]+/?)?$'
                                  break
                                endif
   25   0.001137   0.000285     if index(s:CeilingDirectories(), root) >= 0
                                  break
                                endif
   25              0.000153     if root ==# $GIT_WORK_TREE && FugitiveIsGitDir(env_git_dir)
                                  return env_git_dir
                                elseif has_key(s:dir_for_worktree, root)
                                  return s:dir_for_worktree[root]
                                endif
   25              0.002138     let dir = substitute(root, '[\/]$', '', '') . '/.git'
   25              0.000661     let type = getftype(dir)
   25   0.001503   0.000222     if type ==# 'dir' && FugitiveIsGitDir(dir)
    9              0.000019       return dir
                                elseif type ==# 'link' && FugitiveIsGitDir(dir)
                                  return resolve(dir)
                                elseif type !=# '' && filereadable(dir)
                                  let line = get(readfile(dir, '', 1), 0, '')
                                  let file_dir = s:Slash(FugitiveVimPath(matchstr(line, '^gitdir: \zs.*')))
                                  if file_dir !~# '^/\|^\a:' && FugitiveIsGitDir(root . '/' . file_dir)
                                    return simplify(root . '/' . file_dir)
                                  elseif len(file_dir) && FugitiveIsGitDir(file_dir)
                                    return file_dir
                                  endif
                                elseif FugitiveIsGitDir(root)
                                  return root
                                endif
   16              0.000084     let previous = root
   16              0.000084     let root = fnamemodify(root, ':h')
   16              0.000015   endwhile
                              return ''

FUNCTION  <SNR>172_OnCursorMovedNormalMode()
Called 488 times
Total time:   1.092187
 Self time:   1.082873

count  total (s)   self (s)
  488   0.037551   0.028236   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
  488              1.051605   exec s:python_command "ycm_state.OnCursorMoved()"

FUNCTION  <SNR>211_set_snippet_dict()
Called 16 times
Total time:   0.001924
 Self time:   0.000937

count  total (s)   self (s)
   16              0.000044   if empty(a:snippet_dict)
                                return
                              endif
                            
   16              0.000062   let action_pattern = '^snippet\s\+' . a:snippet_dict.name . '$'
   16   0.001370   0.000383   let snippet = neosnippet#parser#_initialize_snippet( a:snippet_dict, a:snippets_file, a:snippet_dict.linenr, action_pattern, a:snippet_dict.name)
   16              0.000058   let a:snippets[a:snippet_dict.name] = snippet
   16              0.000043   let a:dup_check[a:snippet_dict.name] = snippet
                            
   16              0.000062   for alias in get(a:snippet_dict, 'alias', [])
                                let alias_snippet = copy(snippet)
                                let alias_snippet.word = alias
                                if exists('*json_encode')
                                  let alias_snippet.user_data = json_encode({   'snippet': alias_snippet.snip,   'snippet_trigger': alias, })
                                endif
                            
                                let a:snippets[alias] = alias_snippet
                                let a:dup_check[alias] = alias_snippet
                              endfor

FUNCTION  neomru#append()
Called 18 times
Total time:   0.087358
 Self time:   0.013842

count  total (s)   self (s)
   18   0.001068   0.000323   let path = s:fnamemodify(a:filename, ':p')
   18              0.004790   if path !~ '\a\+:'
   18   0.000997   0.000654     let path = s:substitute_path_separator( simplify(s:resolve(path)))
   18              0.000030   endif
                            
                              " Append the current buffer to the mru list.
   18   0.013372   0.000289   if s:is_file_exist(path)
   14   0.045535   0.000284     call s:file_mru.append(path)
   14              0.000012   endif
                            
   18              0.003057   let filetype = getbufvar(bufnr(a:filename), '&filetype')
   18              0.000124   if filetype ==# 'vimfiler' && type(getbufvar(bufnr(a:filename), 'vimfiler')) == type({})
                                let path = getbufvar(bufnr(a:filename), 'vimfiler').current_dir
                              elseif filetype ==# 'vimshell' && type(getbufvar(bufnr(a:filename), 'vimshell')) == type({})
                                let path = getbufvar(bufnr(a:filename), 'vimshell').current_dir
                              else
   18   0.002923   0.002209     let path = s:fnamemodify(path, ':p:h')
   18              0.000018   endif
                            
   18   0.000376   0.000221   let path = s:substitute_path_separator(simplify(s:resolve(path)))
                              " Chomp last /.
   18              0.000717   let path = substitute(path, '/$', '', '')
                            
                              " Append the current buffer to the mru list.
   18   0.004274   0.000333   if s:is_directory_exist(path)
   18   0.009501   0.000216     call s:directory_mru.append(path)
   18              0.000013   endif

FUNCTION  deoplete#custom#_get()
Called 11 times
Total time:   0.000421
 Self time:   0.000421

count  total (s)   self (s)
   11              0.000299   if !exists('s:custom')
                                call deoplete#custom#_init()
                              endif
                            
   11              0.000019   return s:custom

FUNCTION  <SNR>158_wrap_cmd()
Called 13 times
Total time:   0.000560
 Self time:   0.000560

count  total (s)   self (s)
   13              0.000119   if has('win32')
                                if has('nvim')
                                  let cmd = &shell =~ '\v%(cmd|powershell)' ? a:cmd : ['sh', '-c', a:cmd]
                                else
                                  if &shell =~ 'cmd'
                                    let cmd = join([&shell, &shellcmdflag, '(', a:cmd, ')'])
                                  elseif empty(&shellxquote)
                                    let cmd = join([&shell, &shellcmdflag, &shellquote, a:cmd, &shellquote])
                                  else
                                    let cmd = join([&shell, &shellcmdflag, &shellxquote, a:cmd, &shellxquote])
                                  endif
                                endif
                              else
   13              0.000044     let cmd = ['sh', '-c', a:cmd]
   13              0.000009   endif
   13              0.000079   let options = { 'stdoutbuf': [''], 'vcs': a:vcs, 'bufnr': a:bufnr, }
   13              0.000029   return [cmd, options]

FUNCTION  <SNR>140_Lint()
Called 26 times
Total time:   0.275020
 Self time:   0.009392

count  total (s)   self (s)
                                " Use the filetype from the buffer
   26              0.000316     let l:filetype = getbufvar(a:buffer, '&filetype')
   26   0.055871   0.000780     let l:linters = ale#linter#Get(l:filetype)
                            
                                " Apply ignore lists for linters only if needed.
   26   0.000958   0.000411     let l:ignore_config = ale#Var(a:buffer, 'linters_ignore')
   26   0.000627   0.000245     let l:disable_lsp = ale#Var(a:buffer, 'disable_lsp')
   26              0.000232     let l:linters = !empty(l:ignore_config) || l:disable_lsp   ? ale#engine#ignore#Exclude(l:filetype, l:linters, l:ignore_config, l:disable_lsp)   : l:linters
                            
                                " Tell other sources that they can start checking the buffer now.
   26              0.000106     let g:ale_want_results_buffer = a:buffer
   26   0.005519   0.004050     silent doautocmd <nomodeline> User ALEWantResults
   26              0.000138     unlet! g:ale_want_results_buffer
                            
                                " Don't set up buffer data and so on if there are no linters to run.
   26              0.000253     if !has_key(g:ale_buffer_info, a:buffer) && empty(l:linters)
    3              0.000003         return
                                endif
                            
                                " Clear lint_file linters, or only run them if the file exists.
   23              0.000739     let l:lint_file = empty(l:linters)   || (a:should_lint_file && filereadable(expand('#' . a:buffer . ':p')))
                            
   23   0.209742   0.001603     call ale#engine#RunLinters(a:buffer, l:linters, l:lint_file)

FUNCTION  <SNR>185_RemoveUnicodeQuotes()
Called 608 times
Total time:   0.121402
 Self time:   0.121402

count  total (s)   self (s)
  608              0.001411     let l:text = a:text
  608              0.056193     let l:text = substitute(l:text, '[`Â´â€˜â€™]', '''', 'g')
  608              0.006447     let l:text = substitute(l:text, '\v\\u2018([^\\]+)\\u2019', '''\1''', 'g')
  608              0.054627     let l:text = substitute(l:text, '[â€œâ€]', '"', 'g')
                            
  608              0.001323     return l:text

FUNCTION  ale#job#Stop()
Called 6 times
Total time:   0.002977
 Self time:   0.002977

count  total (s)   self (s)
    6              0.000082     if !has_key(s:job_map, a:job_id)
                                    return
                                endif
                            
    6              0.000278     if has('nvim')
                                    " FIXME: NeoVim kills jobs on a timer, but will not kill any processes
                                    " which are child processes on Unix. Some work needs to be done to
                                    " kill child processes to stop long-running processes like pylint.
    6              0.002245         silent! call jobstop(a:job_id)
    6              0.000026     else
                                    let l:job = s:job_map[a:job_id].job
                            
                                    " We must close the channel for reading the buffer if it is open
                                    " when stopping a job. Otherwise, we will get errors in the status line.
                                    if ch_status(job_getchannel(l:job)) is# 'open'
                                        call ch_close_in(job_getchannel(l:job))
                                    endif
                            
                                    " Ask nicely for the job to stop.
                                    call job_stop(l:job)
                            
                                    if ale#job#IsRunning(l:job)
                                        " Set a 100ms delay for killing the job with SIGKILL.
                                        let s:job_kill_timers[timer_start(100, function('s:KillHandler'))] = l:job
                                    endif
                                endif

FUNCTION  ale#events#LintOnEnter()
Called 8 times
Total time:   0.101758
 Self time:   0.000467

count  total (s)   self (s)
                                " Unmark a file as being changed outside of Vim after we try to check it.
    8              0.000053     call setbufvar(a:buffer, 'ale_file_changed', 0)
                            
    8   0.000327   0.000187     if ale#Var(a:buffer, 'enabled') && g:ale_lint_on_enter
    8   0.101311   0.000159         call ale#Queue(0, 'lint_file', a:buffer)
    8              0.000009     endif

FUNCTION  neosnippet#init#check()
Called 39 times
Total time:   0.000439
 Self time:   0.000439

count  total (s)   self (s)
   39              0.000248   if !exists('s:is_initialized')
                                call neosnippet#init#_initialize()
                              endif

FUNCTION  <SNR>172_OnBufferEnter()
Called 8 times
Total time:   0.184339
 Self time:   0.085222

count  total (s)   self (s)
    8   0.000561   0.000184   if !s:VisitedBufferRequiresReparse()
                                return
                              endif
                            
    8   0.000376   0.000095   call s:SetUpCompleteopt()
    8   0.000224   0.000074   call s:SetCompleteFunc()
    8   0.000261   0.000098   call s:StartMessagePoll()
                            
    8              0.084413   exec s:python_command "ycm_state.OnBufferVisit()"
                              " Last parse may be outdated because of changes from other buffers. Force a
                              " new parse.
    8   0.098433   0.000286   call s:OnFileReadyToParse( 1 )

FUNCTION  <SNR>205__create_hash()
Called 3 times
Total time:   0.000363
 Self time:   0.000363

count  total (s)   self (s)
    3              0.000013   if len(a:dir) + len(a:str) < 150
    3              0.000331     let hash = substitute(substitute( a:str, ':', '=-', 'g'), '[/\\]', '=+', 'g')
    3              0.000003   else
                                let hash = s:S.hash(a:str)
                              endif
                            
    3              0.000003   return hash

FUNCTION  <SNR>146_ExitCallback()
Called 23 times
Total time:   0.884933
 Self time:   0.003392

count  total (s)   self (s)
   23              0.000130     if !has_key(s:buffer_data, a:buffer)
                                    return
                                endif
                            
   23              0.000100     let l:jobs = s:buffer_data[a:buffer].jobs
                            
   23              0.000083     if !has_key(l:jobs, a:data.job_id)
    6              0.000008         return
                                endif
                            
   17              0.000151     let l:job_type = remove(l:jobs, a:data.job_id)
                            
   17              0.000029     if g:ale_history_enabled
   17   0.001494   0.000180         call ale#history#SetExitCode(a:buffer, a:data.job_id, a:data.exit_code)
                            
                                    " Log the output of the command for ALEInfo if we should.
   17              0.000049         if g:ale_history_log_output && a:data.log_output is 1
   17   0.000941   0.000378             call ale#history#RememberOutput(   a:buffer,   a:data.job_id,   a:line_list[:])
   17              0.000016         endif
   17              0.000009     endif
                            
                                " If the callback starts any new jobs, use the same job type for them.
   17              0.000104     call setbufvar(a:buffer, 'ale_job_type', l:job_type)
   17   0.881158   0.001494     let l:value = a:Callback(a:buffer, a:line_list, {   'exit_code': a:data.exit_code,   'temporary_file': a:data.temporary_file,})
                            
   17              0.000093     let l:result = a:data.result
   17              0.000053     let l:result.value = l:value
                            
   17              0.000111     if get(l:result, 'result_callback', v:null) isnot v:null
                                    call call(l:result.result_callback, [l:value])
                                endif

FUNCTION  <SNR>12_isAnsible()
Called 4 times
Total time:   0.001130
 Self time:   0.001130

count  total (s)   self (s)
    4              0.000169   let filepath = expand("%:p")
    4              0.000014   let filename = expand("%:t")
    4              0.000216   if filepath =~ '\v/(tasks|roles|handlers)/.*\.ya?ml$' | return 1 | en
    4              0.000123   if filepath =~ '\v/(group|host)_vars/' | return 1 | en
    4              0.000262   if filename =~ '\v(playbook|site|main|local)\.ya?ml$' | return 1 | en
                            
    4              0.000023   let shebang = getline(1)
    4              0.000079   if shebang =~# '^#!.*/bin/env\s\+ansible-playbook\>' | return 1 | en
    4              0.000069   if shebang =~# '^#!.*/bin/ansible-playbook\>' | return 1 | en
                            
    4              0.000007   return 0

FUNCTION  <SNR>172_SendKeys()
Called 18 times
Total time:   0.000335
 Self time:   0.000335

count  total (s)   self (s)
                              " By default keys are added to the end of the typeahead buffer. If there are
                              " already keys in the buffer, they will be processed first and may change the
                              " state that our keys combination was sent for (e.g. <C-X><C-U><C-P> in normal
                              " mode instead of insert mode or <C-e> outside of completion mode). We avoid
                              " that by inserting the keys at the start of the typeahead buffer with the 'i'
                              " option. Also, we don't want the keys to be remapped to something else so we
                              " add the 'n' option.
   18              0.000180   call feedkeys( a:keys, 'in' )

FUNCTION  <SNR>151_generate_buffer_names()
Called 52 times
Total time:   0.547255
 Self time:   0.167413

count  total (s)   self (s)
   52              0.000157   let l:flensum = 0
                              "let l:current_bufnr = bufnr('%')
   52              0.000133   let l:len2bufnrs = {}
                              " key is always string in map
   52              0.000102   let l:bufnr2names = {}
                            
  576              0.001972   for nr in range(1, bufnr('$'))
  524              0.002701     if bufexists(nr) && buflisted(nr)
                                  " fname
  316              0.001280       let l:fname = bufname(nr)
  316              0.001073       if l:fname !=# ''
  316              0.001249         if has('modify_fname')
  316              0.002566           let l:fname = fnamemodify(l:fname, g:lightline_buffer_fname_mod)
  316              0.000255         endif
                                    " % is a legal char in file name, but a escape char in vim
  316              0.003132         let l:fname = substitute(l:fname, "%", "%%", "g")
  316              0.000395       else
                                    let l:fname = '[No Name]'
                                  endif
                            
                                  " attribute
  316              0.000542       let l:attribute = ''
  316              0.002971       if getbufvar(nr, '&mod')
   64              0.000353         let l:attribute = g:lightline_buffer_attribute_separator_icon . g:lightline_buffer_modified_icon
   64              0.000049       endif
  316              0.002484       if (getbufvar(nr, '&readonly') || !getbufvar(nr, '&modifiable')) && getbufvar(nr, '&filetype') != 'help'
                                    let l:attribute = g:lightline_buffer_attribute_separator_icon . g:lightline_buffer_readonly_icon
                                  endif
                            
                                  " icon
  316              0.000531       let l:icon = ''
  316              0.002046       if g:lightline_buffer_enable_devicons && exists('*WebDevIconsGetFileTypeSymbol')  " support for vim-devicons
                                    " WebDevIconsGetFileTypeSymbol output symbol and a space
                                    " not need to add a space by your self
  316   0.367383   0.009994         let l:icon = g:lightline_buffer_type_separator_icon . WebDevIconsGetFileTypeSymbol(l:fname, isdirectory(l:fname))
  316              0.000341       endif
                            
                                  " merge
  316              0.000592       let l:skip = 0
 1264              0.002607       for exclude in g:lightline_buffer_excludes
  948              0.007328         if match(l:fname, exclude) > -1
                                      let l:skip = 1
                                      break
                                    endif
  948              0.001544       endfor
                            
  316              0.000470       if !l:skip
  316   0.005649   0.003237         let l:foldlen = s:mb_str_len(l:fname)
  316              0.000801         if l:foldlen > g:lightline_buffer_maxflen
                                      let l:fname = s:shorten_name(l:fname, g:lightline_buffer_maxflen, g:lightline_buffer_maxfextlen, l:foldlen)
                                    endif
                            
  316              0.000695         let l:name = ''
                                    "if g:lightline_buffer_show_bufnr != 0 &&
                                    "    \ g:lightline_buffer_status_info.count >=
                                    "    \ g:lightline_buffer_show_bufnr
                                    "  let l:name = nr . ' '
                                    "endif
  316              0.002249         let l:name .= l:fname . l:attribute . l:icon
                            
                                    "if l:current_bufnr == nr
                                    "  let l:name = g:lightline_buffer_separator_left_icon .
                                    "      \ g:lightline_buffer_active_buffer_left_icon . l:name .
                                    "      \ g:lightline_buffer_active_buffer_right_icon .
                                    "      \ g:lightline_buffer_separator_right_icon
                                    "  let g:lightline_buffer_status_info.current = l:name
                                    "else
                                    "  let l:name = g:lightline_buffer_separator_left_icon . l:name .
                                    "      \ g:lightline_buffer_separator_right_icon
                                    "endif
                            
  316              0.001419         let l:bufnr2names[nr] = l:name
                            
  316   0.006610   0.004310         let l:namelen = s:mb_str_len(l:name)
                                    "if get(l:len2bufnrs, l:namelen) == 0
                                    "  let l:len2bufnrs[l:namelen] = []
                                    "endif
                                    "call add(l:len2bufnrs[l:namelen], nr)
                                    "l:len2bufnrs[l:namelen] += [nr]
  316              0.002426         if get(l:len2bufnrs, l:namelen) == 0
  248              0.000913           let l:len2bufnrs[l:namelen] = ''
  248              0.000196         endif
  316              0.001539         let l:len2bufnrs[l:namelen] .= nr . ' '
                            
  316              0.001962         let l:flensum += g:lightline_buffer_separator_left_icon_len + l:namelen + g:lightline_buffer_separator_right_icon_len
  316              0.000799         if g:lightline_buffer_show_bufnr != 0
                                      " add number and space
  316   0.006325   0.004999           let l:flensum += s:mb_str_len(nr) + 1
  316              0.000263         endif
  316              0.000449       endif
  316              0.000169     endif
  524              0.003952   endfor
   52              0.000281   let l:flensum += g:lightline_buffer_active_buffer_left_icon_len + g:lightline_buffer_active_buffer_right_icon_len
                            
   52              0.000309   let g:lightline_buffer_status_info.info = ''
   52   0.003921   0.002804   let l:namelens = sort(keys(l:len2bufnrs), "s:int_compare")
                            
                              " debug only
                              "for namelen in l:namelens
                              "  let g:lightline_buffer_status_info.info .= namelen . ': '
                              "  "for bufnr in l:len2bufnrs[namelen]
                              "  let l:bufnrs = split(l:len2bufnrs[namelen])
                              "  for bufnr in l:bufnrs
                              "    let g:lightline_buffer_status_info.info .= bufnr . ' ' .
                              "        \ l:bufnr2names[bufnr] . ', '
                              "  endfor
                              "  let g:lightline_buffer_status_info.info .= '; '
                              "endfor
   52              0.000537   let g:lightline_buffer_status_info.info = g:lightline_buffer_logo . tabpagenr() . '/' . tabpagenr('$')
                            
  240              0.000634   for namelen in l:namelens
  208              0.000786     if l:flensum + g:lightline_buffer_reservelen <= &columns
   20              0.000022       break
                                endif
                                "for bufnr in l:len2bufnrs[namelen]
  188              0.008473     let l:bufnrs = split(l:len2bufnrs[namelen])
  428              0.001341     for bufnr in l:bufnrs
  240              0.000696       if l:flensum + g:lightline_buffer_reservelen <= &columns
    4              0.000005         continue
                                  endif
  236   0.006482   0.004139       let l:foldlen = s:mb_str_len(l:bufnr2names[bufnr])
  236   0.013755   0.003109       let l:bufnr2names[bufnr] = s:shorten_name(l:bufnr2names[bufnr], g:lightline_buffer_minflen, g:lightline_buffer_minfextlen, l:foldlen)
  236   0.003304   0.002089       let l:fnewlen = s:mb_str_len(l:bufnr2names[bufnr])
  236              0.000631       let l:flensum -= l:foldlen - l:fnewlen
  236              0.002034     endfor
  188              0.000263   endfor
                              "let l:i = 0
                              "while l:i < len(l:names)
                              "  if l:flensum + g:lightline_buffer_reservelen > &columns
                              "    let l:foldlen = s:mb_str_len(l:names[l:i][1])
                              "    let l:names[l:i][1] = s:shorten_name(l:names[l:i][1],
                              "        \ g:lightline_buffer_minflen,
                              "        \ g:lightline_buffer_minfextlen, l:foldlen)
                              "    let l:fnewlen = s:mb_str_len(l:names[l:i][1])
                              "    let l:flensum -= l:foldlen - l:fnewlen
                              "  endif
                              "  let l:i += 1
                              "endwhile
   52              0.000121   let l:names = []
  368   0.006220   0.005125   for bufnr in sort(keys(l:bufnr2names), "s:int_compare")
  316              0.003009     call add(l:names, [bufnr, l:bufnr2names[bufnr]])
  316              0.000558   endfor
                            
                              "if len(l:names) > 1
                              "  if g:lightline_buffer_rotate == 1
                              "    call bufferline#algos#fixed_position#modify(l:names)
                              "  endif
                              "endif
                            
   52              0.000080   return l:names

FUNCTION  denite#util#path2directory()
Called 1 time
Total time:   0.000181
 Self time:   0.000170

count  total (s)   self (s)
    1   0.000181   0.000169   return denite#util#substitute_path_separator( isdirectory(a:path) ? a:path : fnamemodify(a:path, ':p:h'))

FUNCTION  <SNR>4_source()
Called 8 times
Total time:   0.098011
 Self time:   0.000474

count  total (s)   self (s)
    8              0.000013   let found = 0
   16              0.000025   for pattern in a:000
    9   0.002993   0.000070     for vim in s:glob(a:from, pattern)
    1   0.094848   0.000234       execute 'source' s:esc(vim)
    1              0.000002       let found = 1
    1              0.000001     endfor
    8              0.000019   endfor
    8              0.000009   return found

FUNCTION  test#rust#cargotest#test_file()
Called 6 times
Total time:   0.000086
 Self time:   0.000086

count  total (s)   self (s)
    6              0.000079   return a:file =~# g:test#rust#cargotest#file_pattern

FUNCTION  ale#linter#Get()
Called 26 times
Total time:   0.055091
 Self time:   0.008354

count  total (s)   self (s)
   26              0.000108     let l:possibly_duplicated_linters = []
                            
                                " Handle dot-separated filetypes.
   52              0.000497     for l:original_filetype in split(a:original_filetypes, '\.')
   26   0.006607   0.000414         let l:filetype = ale#linter#ResolveFiletype(l:original_filetype)
   26   0.001138   0.000426         let l:linter_names = s:GetLinterNames(l:original_filetype)
   26   0.040154   0.000322         let l:all_linters = ale#linter#GetAll(l:filetype)
   26              0.000067         let l:filetype_linters = []
                            
   26              0.000148         if type(l:linter_names) is v:t_string && l:linter_names is# 'all'
    2              0.000003             let l:filetype_linters = l:all_linters
    2              0.000004         elseif type(l:linter_names) is v:t_list
                                        " Select only the linters we or the user has specified.
   80              0.000198             for l:linter in l:all_linters
   56              0.000350                 let l:name_list = [l:linter.name] + l:linter.aliases
                            
   91              0.000213                 for l:name in l:name_list
   58              0.000285                     if index(l:linter_names, l:name) >= 0
   23              0.000127                         call add(l:filetype_linters, l:linter)
   23              0.000030                         break
                                                endif
   35              0.000074                 endfor
   56              0.000121             endfor
   24              0.000052         endif
                            
   26              0.000123         call extend(l:possibly_duplicated_linters, l:filetype_linters)
   26              0.000025     endfor
                            
   26              0.000527     let l:name_list = []
   26              0.000064     let l:combined_linters = []
                            
                                " Make sure we override linters so we don't get two with the same name,
                                " like 'eslint' for both 'javascript' and 'typescript'
                                "
                                " Note that the reverse calls here modify the List variables.
   49              0.000169     for l:linter in reverse(l:possibly_duplicated_linters)
   23              0.000136         if index(l:name_list, l:linter.name) < 0
   23              0.000104             call add(l:name_list, l:linter.name)
   23              0.000113             call add(l:combined_linters, l:linter)
   23              0.000021         endif
   23              0.000076     endfor
                            
   26              0.000082     return reverse(l:combined_linters)

FUNCTION  vista#renderer#LSPProcess()
Called 8 times
Total time:   0.000398
 Self time:   0.000288

count  total (s)   self (s)
    8              0.000027   if a:reload_only
    6   0.000308   0.000199     call vista#sidebar#Reload(a:processed_data)
    6              0.000019     return [v:false, a:should_display]
                              elseif a:should_display
                                call vista#renderer#RenderAndDisplay(a:processed_data)
                                return [a:reload_only, v:false]
                              else
    2              0.000006     return [a:reload_only, a:should_display]
                              endif

FUNCTION  necovim#get_cur_text()
Called 1 time
Total time:   0.000071
 Self time:   0.000071

count  total (s)   self (s)
    1              0.000006   let cur_text = a:input
    1              0.000009   if &filetype == 'vimshell' && exists('*vimshell#get_secondary_prompt')   && empty(b:vimshell.continuation)
                                return cur_text[len(vimshell#get_secondary_prompt()) :]
                              endif
                            
    1              0.000004   let line = line('.')
    1              0.000002   let cnt = 0
    1              0.000014   while cur_text =~ '^\s*\\' && line > 1 && cnt < 5
                                let cur_text = getline(line - 1) . substitute(cur_text, '^\s*\\', '', '')
                                let line -= 1
                                let cnt += 1
                              endwhile
                            
    1              0.000015   return split(cur_text, '\s\+|\s\+\|<bar>', 1)[-1]

FUNCTION  <SNR>161_GetLanguageSpecificOptition()
Called 9 times
Total time:   0.001092
 Self time:   0.001092

count  total (s)   self (s)
    9              0.000037   let opt = ''
                            
    9              0.000011   try
    9              0.000072     let types = g:vista#types#uctags#{a:filetype}#
    9              0.000024     let lang = types.lang
    9              0.000755     let kinds = join(keys(types.kinds), '')
    9              0.000089     let opt = printf('--language-force=%s --%s-kinds=%s', lang, lang, kinds)
                              " Ignore Vim(let):E121: Undefined variable
    9              0.000017   catch /^Vim\%((\a\+)\)\=:E121/
                              endtry
                            
    9              0.000015   return opt

FUNCTION  test#ruby#minitest#test_file()
Called 6 times
Total time:   0.000083
 Self time:   0.000083

count  total (s)   self (s)
    6              0.000063   return a:file =~# g:test#ruby#minitest#file_pattern

FUNCTION  <SNR>171_check_prev_completion()
Called 1 time
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000003   let prev = g:deoplete#_prev_completion
    1              0.000007   if a:event ==# 'Async' || a:event ==# 'Update' || mode() !=# 'i' || empty(get(prev, 'candidates', [])) || s:check_input_method()
    1              0.000001     return
                              endif
                            
                              let input = deoplete#util#get_input(a:event)
                              let complete_str = matchstr(input, '\w\+$')
                              let min_pattern_length = deoplete#custom#_get_option('min_pattern_length')
                              if prev.linenr != line('.') || len(complete_str) < min_pattern_length
                                return
                              endif
                            
                              call deoplete#mapping#_set_completeopt()
                            
                              let mode = deoplete#custom#_get_option('prev_completion_mode')
                              let candidates = copy(prev.candidates)
                            
                              if mode ==# 'filter' || mode ==# 'length'
                                let input = input[prev.complete_position :]
                                let escaped_input = escape(input, '~\.^$[]*')
                                let pattern = substitute(escaped_input, '\w', '\\w*\0', 'g')
                                call filter(candidates, 'v:val.word =~? pattern')
                                if mode ==# 'length'
                                  call filter(candidates, 'len(v:val.word) > len(input)')
                                endif
                              elseif mode ==# 'mirror'
                                " pass
                              else
                                return
                              endif
                            
                              let g:deoplete#_filtered_prev = { 'complete_position': prev.complete_position, 'candidates': candidates, }
                              call feedkeys("\<Plug>+", 'i')

FUNCTION  <SNR>158_callback_nvim_stdout()
Called 17 times
Total time:   0.000494
 Self time:   0.000494

count  total (s)   self (s)
   17              0.000224   let self.stdoutbuf[-1] .= a:data[0]
   17              0.000213   call extend(self.stdoutbuf, a:data[1:])

FUNCTION  LanguageClient#handleBufDelete()
Called 1 time
Total time:   0.000177
 Self time:   0.000028

count  total (s)   self (s)
    1              0.000003     try
    1   0.000167   0.000019         call LanguageClient#Notify('languageClient/handleBufDelete', { 'filename': LSP#filename(), })
    1              0.000001     catch
                                    call s:Debug('LanguageClient caught exception: ' . string(v:exception))
                                endtry

FUNCTION  <SNR>211_parse()
Called 1 time
Total time:   0.022847
 Self time:   0.013106

count  total (s)   self (s)
    1              0.000003   let dup_check = {}
    1              0.000002   let snippet_dict = {}
    1              0.000001   let linenr = 1
    1              0.000001   let snippets = {}
    1              0.000001   let sourced = 0
                            
   82              0.001673   for line in readfile(a:snippets_file)
   81              0.002141     if line =~# '^\h\w*.*\s$'
                                  " Delete spaces.
                                  let line = substitute(line, '\s\+$', '', '')
                                endif
                            
   81              0.000262     if line =~# '^#'
                                  " Ignore.
                                elseif line =~# '^include'
                                  " Include snippets file.
                                  let snippets = extend(snippets, s:include_snippets( [matchstr(line, '^include\s\+\zs.*$')]))
                                elseif line =~# '^extends'
                                  " Extend snippets files.
                                  let fts = split(matchstr(line, '^extends\s\+\zs.*$'), '\s*,\s*')
                                  for ft in fts
                                    let snippets = extend(snippets, s:include_snippets( [ft.'.snip', ft.'.snippets', ft.'/*']))
                                  endfor
                                elseif line =~# '^source'
                                  " Source Vim script file.
                                  for file in split(globpath(join( neosnippet#helpers#get_snippets_directory(), ','), matchstr(line, '^source\s\+\zs.*$')), '\n')
                                    execute 'source' fnameescape(file)
                                    let sourced = 1
                                  endfor
                                elseif line =~# '^delete\s'
                                  let name = matchstr(line, '^delete\s\+\zs.*$')
                                  if name !=# '' && has_key(snippets, name)
                                    call filter(snippets, 'v:val.real_name !=# name')
                                  endif
                                elseif line =~# '^snippet\s'
   16              0.000044       if !empty(snippet_dict)
                                    " Set previous snippet.
   15   0.002098   0.000265         call s:set_snippet_dict(snippet_dict, snippets, dup_check, a:snippets_file)
   15              0.000008       endif
                            
   16   0.002945   0.000273       let snippet_dict = s:parse_snippet_name( a:snippets_file, line, linenr, dup_check)
   16              0.000029     elseif !empty(snippet_dict)
   65              0.000608       if line =~# '^\s' || line ==# ''
   33              0.000109         if snippet_dict.word ==# '' && line =~# '^\t'
                                      " Substitute head tab character.
                                      let line = substitute(line, '^\t', '', '')
                                    else
   33              0.000424           let line = substitute(line, '^ *', '', '')
   33              0.000023         endif
                            
   33              0.000102         let snippet_dict.word .= line . "\n"
   33              0.000019       else
   32   0.005466   0.000322         call s:add_snippet_attribute( a:snippets_file, line, linenr, snippet_dict)
   32              0.000019       endif
   65              0.000030     endif
                            
   81              0.000118     let linenr += 1
   81              0.000230   endfor
                            
    1              0.000002   if !empty(snippet_dict)
                                " Set previous snippet.
    1   0.000100   0.000009     call s:set_snippet_dict(snippet_dict, snippets, dup_check, a:snippets_file)
    1              0.000000   endif
                            
    1              0.000002   return [snippets, sourced]

FUNCTION  neosnippet#helpers#get_filetype()
Called 12 times
Total time:   0.000413
 Self time:   0.000413

count  total (s)   self (s)
                              " context_filetype.vim installation check.
   12              0.000105   if !exists('s:exists_context_filetype')
                                silent! call context_filetype#version()
                                let s:exists_context_filetype = exists('*context_filetype#version')
                              endif
                            
   12              0.000069   let context_filetype = s:exists_context_filetype ? context_filetype#get_filetype() : &filetype
   12              0.000029   if context_filetype ==# ''
                                let context_filetype = 'nothing'
                              endif
                            
   12              0.000018   return context_filetype

FUNCTION  <SNR>156_get_path()
Called 6 times
Total time:   0.000585
 Self time:   0.000585

count  total (s)   self (s)
    6              0.000524   let path = resolve(fnamemodify(bufname(a:bufnr), ':p'))
    6              0.000026   if has('win32')
                                let path = substitute(path, '\v^(\w):\\\\', '\1:\\', '')
                              endif
    6              0.000008   return path

FUNCTION  ale#highlight#CreatePositions()
Called 1212 times
Total time:   0.007953
 Self time:   0.007953

count  total (s)   self (s)
 1212              0.001898     if a:line >= a:end_line
                                    " For single lines, just return the one position.
 1212              0.004599         return [[[a:line, a:col, a:end_col - a:col + 1]]]
                                endif
                            
                                " Get positions from the first line at the first column, up to a large
                                " integer for highlighting up to the end of the line, followed by
                                " the lines in-between, for highlighting entire lines, and
                                " a highlight for the last line, up to the end column.
                                let l:all_positions =   [[a:line, a:col, s:MAX_COL_SIZE]]   + range(a:line + 1, a:end_line - 1)   + [[a:end_line, 1, a:end_col]]
                            
                                return map(   range(0, len(l:all_positions) - 1, s:MAX_POS_VALUES),   'l:all_positions[v:val : v:val + s:MAX_POS_VALUES - 1]',)

FUNCTION  LSP#line()
Called 424 times
Total time:   0.002802
 Self time:   0.002802

count  total (s)   self (s)
  424              0.002234     return line('.') - 1

FUNCTION  denite#init#_deprecated_options()
Called 6 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    6              0.000028   return {}

FUNCTION  <SNR>99_abbrev()
Called 6 times
Total time:   0.000111
 Self time:   0.000111

count  total (s)   self (s)
    6              0.000038   if exists('g:endwise_abbreviations')
                                for word in split(get(b:, 'endwise_words', ''), ',')
                                  execute 'iabbrev <buffer><script>' word word.'<CR><SID>DiscretionaryEnd<Space><C-U><BS>'
                                endfor
                              endif

FUNCTION  <SNR>64_DevIconsGetArtifactFix()
Called 316 times
Total time:   0.004154
 Self time:   0.004154

count  total (s)   self (s)
  316              0.000968   if g:DevIconsAppendArtifactFix == 1
                                let artifactFix = g:DevIconsArtifactFixChar
                              else
  316              0.000700     let artifactFix = ''
  316              0.000220   endif
                            
  316              0.000614   return artifactFix

FUNCTION  defx#util#has_yarp()
Called 3 times
Total time:   0.000071
 Self time:   0.000071

count  total (s)   self (s)
    3              0.000060   return !has('nvim')

FUNCTION  ale#events#QuitRecently()
Called 3 times
Total time:   0.000132
 Self time:   0.000101

count  total (s)   self (s)
    3              0.000026     let l:time = getbufvar(a:buffer, 'ale_quitting', 0)
                            
    3   0.000068   0.000037     return l:time && ale#events#ClockMilliseconds() - l:time < 1000

FUNCTION  test#go#gotest#test_file()
Called 6 times
Total time:   0.002297
 Self time:   0.000643

count  total (s)   self (s)
    6   0.002292   0.000637   return test#go#test_file('gotest', g:test#go#gotest#file_pattern, a:file)

FUNCTION  <SNR>172_PollCompletion()
Called 35 times
Total time:   0.055971
 Self time:   0.003562

count  total (s)   self (s)
   35   0.022112   0.000702   if !s:Pyeval( 'ycm_state.CompletionRequestReady()' )
   19              0.000748     let s:pollers.completion.id = timer_start( s:pollers.completion.wait_milliseconds, function( 's:PollCompletion' ) )
   19              0.000047     return
                              endif
                            
   16   0.030444   0.000775   let response = s:Pyeval( 'ycm_state.GetCompletionResponse()' )
   16              0.000326   let s:completion = {   'start_column': response.completion_start_column,   'candidates': response.completions }
   16   0.001881   0.000550   call s:Complete()

FUNCTION  test#ruby#rspec#test_file()
Called 6 times
Total time:   0.000458
 Self time:   0.000458

count  total (s)   self (s)
    6              0.000448   return a:file =~# g:test#ruby#rspec#file_pattern

FUNCTION  <SNR>235_detect_wrap_mode()
Called 4 times
Total time:   0.021789
 Self time:   0.000200

count  total (s)   self (s)
                            
    4              0.000010   let b:max_textwidth = -1      " assume no relevant modeline
    4   0.021692   0.000103   call s:doModelines()
                            
    4              0.000015   if b:max_textwidth > 0
                                " modelines(s) found with positive textwidth, so hard line breaks
                                return s:WRAP_MODE_HARD
                              en
                            
    4              0.000017   if b:max_textwidth ==# 0 || g:pencil#wrapModeDefault ==# 'soft'
                                " modeline(s) found only with zero textwidth, so it's soft line wrap
                                " or, the user wants to default to soft line wrap
    4              0.000008     return s:WRAP_MODE_SOFT
                              en
                            
                              " attempt to rule out soft line wrap
                              " scan initial lines in an attempt to detect long lines
                              for l:line in getline(1, g:pencil#softDetectSample)
                                if len(l:line) > g:pencil#softDetectThreshold
                                  return s:WRAP_MODE_SOFT
                                en
                              endfo
                            
                              " punt
                              return s:WRAP_MODE_DEFAULT

FUNCTION  <SNR>228_MarkdownHighlightSources()
Called 1 time
Total time:   0.000979
 Self time:   0.000979

count  total (s)   self (s)
                                " Syntax highlight source code embedded in notes.
                                " Look for code blocks in the current file
    1              0.000003     let filetypes = {}
  114              0.000136     for line in getline(1, '$')
  113              0.000396         let ft = matchstr(line, '```\s*\zs[0-9A-Za-z_+-]*')
  113              0.000161         if !empty(ft) && ft !~ '^\d*$' | let filetypes[ft] = 1 | endif
  113              0.000096     endfor
    1              0.000003     if !exists('b:mkd_known_filetypes')
    1              0.000002         let b:mkd_known_filetypes = {}
    1              0.000000     endif
    1              0.000002     if !exists('b:mkd_included_filetypes')
                                    " set syntax file name included
    1              0.000002         let b:mkd_included_filetypes = {}
    1              0.000000     endif
    1              0.000003     if !a:force && (b:mkd_known_filetypes == filetypes || empty(filetypes))
                                    return
                                endif
                            
                                " Now we're ready to actually highlight the code blocks.
    1              0.000001     let startgroup = 'mkdCodeStart'
    1              0.000001     let endgroup = 'mkdCodeEnd'
    1              0.000003     for ft in keys(filetypes)
                                    if a:force || !has_key(b:mkd_known_filetypes, ft)
                                        if has_key(s:filetype_dict, ft)
                                            let filetype = s:filetype_dict[ft]
                                        else
                                            let filetype = ft
                                        endif
                                        let group = 'mkdSnippet' . toupper(substitute(filetype, "[+-]", "_", "g"))
                                        if !has_key(b:mkd_included_filetypes, filetype)
                                            let include = s:SyntaxInclude(filetype)
                                            let b:mkd_included_filetypes[filetype] = 1
                                        else
                                            let include = '@' . toupper(filetype)
                                        endif
                                        let command = 'syntax region %s matchgroup=%s start="^\s*```\s*%s$" matchgroup=%s end="\s*```$" keepend contains=%s%s'
                                        execute printf(command, group, startgroup, ft, endgroup, include, has('conceal') && get(g:, 'vim_markdown_conceal', 1) && get(g:, 'vim_markdown_conceal_code_blocks', 1) ? ' concealends' : '')
                                        execute printf('syntax cluster mkdNonListItem add=%s', group)
                            
                                        let b:mkd_known_filetypes[ft] = 1
                                    endif
                                endfor

FUNCTION  <SNR>150_expand()
Called 56 times
Total time:   0.607611
 Self time:   0.018563

count  total (s)   self (s)
   56              0.000142   let components = []
   56              0.000082   let expanded = []
   56              0.000075   let indices = []
   56              0.000075   let prevtype = ''
   56              0.000084   let previndex = -1
   56   0.594299   0.005251   let xs = s:flatten_twice(s:map(deepcopy(a:components), 'map(v:val, "s:convert(v:val, ''" . v:key . "'')")'))
  250              0.000798   for [component, expand, type, index] in xs
  194              0.000411     if prevtype !=# type
  139              0.000937       for i in range(previndex + 1, max([previndex, index - 1]))
                                    call add(indices, string(i))
                                    call add(components, [])
                                    call add(expanded, [])
                                  endfor
  139              0.000406       call add(indices, type)
  139              0.000301       call add(components, [])
  139              0.000272       call add(expanded, [])
  139              0.000142     endif
  194              0.000613     call extend(components[-1], component)
  194              0.001360     call extend(expanded[-1], repeat([expand], len(component)))
  194              0.000411     let prevtype = type
  194              0.000305     let previndex = index
  194              0.001093   endfor
   56              0.000448   for i in range(previndex + 1, max([previndex, len(a:components) - 1]))
                                call add(indices, string(i))
                                call add(components, [])
                                call add(expanded, [])
                              endfor
   56              0.000638   call add(indices, string(len(a:components)))
   56              0.000149   return [components, expanded, indices]

FUNCTION  denite#do_map()
Called 1 time
Total time:   0.000107
 Self time:   0.000092

count  total (s)   self (s)
    1   0.000083   0.000068   let args = denite#util#convert2list(get(a:000, 0, []))
    1              0.000006   let esc = (mode() ==# 'i' ? "\<C-o>" : '')
    1              0.000014   return printf(esc . ":\<C-u>call denite#_call_map(%s, %s, %s)\<CR>", string(a:name), 'v:false', string(args))

FUNCTION  <SNR>172_OnBufferUnload()
Called 11 times
Total time:   0.386879
 Self time:   0.386810

count  total (s)   self (s)
                              " Expanding <abuf> returns the unloaded buffer number as a string but we want
                              " it as a true number for the getbufvar function.
   11              0.000681   let buffer_number = str2nr( expand( '<abuf>' ) )
   11   0.000687   0.000618   if !s:AllowedToCompleteInBuffer( buffer_number )
                                return
                              endif
                            
   11              0.384796   exec s:python_command "ycm_state.OnBufferUnload( " . buffer_number . " )"

FUNCTION  <SNR>216_NetrwFile()
Called 1 time
Total time:   0.000180
 Self time:   0.000180

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwFile(fname<".a:fname.">) win#".winnr())
                            "  call Decho("g:netrw_keepdir  =".(exists("g:netrw_keepdir")?   g:netrw_keepdir   : 'n/a'),'~'.expand("<slnum>"))
                            "  call Decho("g:netrw_cygwin   =".(exists("g:netrw_cygwin")?    g:netrw_cygwin    : 'n/a'),'~'.expand("<slnum>"))
                            "  call Decho("g:netrw_liststyle=".(exists("g:netrw_liststyle")? g:netrw_liststyle : 'n/a'),'~'.expand("<slnum>"))
                            "  call Decho("w:netrw_liststyle=".(exists("w:netrw_liststyle")? w:netrw_liststyle : 'n/a'),'~'.expand("<slnum>"))
                            
                              " clean up any leading treedepthstring
    1              0.000022   if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                               let fname= substitute(a:fname,'^'.s:treedepthstring.'\+','','')
                            "   call Decho("clean up any leading treedepthstring: fname<".fname.">",'~'.expand("<slnum>"))
                              else
    1              0.000006    let fname= a:fname
    1              0.000002   endif
                            
    1              0.000003   if g:netrw_keepdir
                               " vim's idea of the current directory possibly may differ from netrw's
    1              0.000006    if !exists("b:netrw_curdir")
    1              0.000022     let b:netrw_curdir= getcwd()
    1              0.000002    endif
                            
    1              0.000012    if !exists("g:netrw_cygwin") && (has("win32") || has("win95") || has("win64") || has("win16"))
                                if fname =~ '^\' || fname =~ '^\a:\'
                                 " windows, but full path given
                                 let ret= fname
                            "     call Decho("windows+full path: isdirectory(".fname.")",'~'.expand("<slnum>"))
                                else
                                 " windows, relative path given
                                 let ret= s:ComposePath(b:netrw_curdir,fname)
                            "     call Decho("windows+rltv path: isdirectory(".fname.")",'~'.expand("<slnum>"))
                                endif
                            
                               elseif fname =~ '^/'
                                " not windows, full path given
    1              0.000004     let ret= fname
                            "    call Decho("unix+full path: isdirectory(".fname.")",'~'.expand("<slnum>"))
    1              0.000001    else
                                " not windows, relative path given
                                let ret= s:ComposePath(b:netrw_curdir,fname)
                            "    call Decho("unix+rltv path: isdirectory(".fname.")",'~'.expand("<slnum>"))
                               endif
    1              0.000001   else
                               " vim and netrw agree on the current directory
                               let ret= fname
                            "   call Decho("vim and netrw agree on current directory (g:netrw_keepdir=".g:netrw_keepdir.")",'~'.expand("<slnum>"))
                            "   call Decho("vim   directory: ".getcwd(),'~'.expand("<slnum>"))
                            "   call Decho("netrw directory: ".(exists("b:netrw_curdir")? b:netrw_curdir : 'n/a'),'~'.expand("<slnum>"))
                              endif
                            
                            "  call Dret("s:NetrwFile ".ret)
    1              0.000003   return ret

FUNCTION  <SNR>66_append()
Called 19 times
Total time:   0.091010
 Self time:   0.000636

count  total (s)   self (s)
   19              0.000223   if bufnr('%') != expand('<abuf>') || a:path == ''
                                return
                              endif
                            
   19   0.090680   0.000305   call neomru#_append()

FUNCTION  <SNR>4_esc()
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000006   return escape(a:path, ' ')

FUNCTION  test#get_runners()
Called 6 times
Total time:   0.002173
 Self time:   0.000276

count  total (s)   self (s)
    6              0.000041   if exists('g:test#runners')
                                let custom_runners = g:test#runners
                              elseif exists('g:test#custom_runners')
                                let custom_runners = g:test#custom_runners
                              else
    6              0.000021     let custom_runners = {}
    6              0.000006   endif
                            
    6   0.002030   0.000133   return s:extend(custom_runners, g:test#default_runners)

FUNCTION  <SNR>235_doModeline()
Called 8 times
Total time:   0.020938
 Self time:   0.020938

count  total (s)   self (s)
    8              0.009165   let l:matches = matchlist(a:line, '\%(\S\@<!\%(vi\|vim\([<>=]\?\)\([0-9]\+\)\?\)\|\sex\):\s*\%(set\s\+\)\?\([^:]\+\):\S\@!')
    8              0.000074   if len(l:matches) > 0
                                for l:item in split(l:matches[3])
                                  call s:doOne(l:item)
                                endfo
                              en
    8              0.011233   let l:matches = matchlist(a:line, '\%(\S\@<!\%(vi\|vim\([<>=]\?\)\([0-9]\+\)\?\)\|\sex\):\(.\+\)')
    8              0.000074   if len(l:matches) > 0
                                for l:item in split(l:matches[3], '[ \t:]')
                                  call s:doOne(l:item)
                                endfo
                              en

FUNCTION  ale#sign#FindCurrentSigns()
Called 17 times
Total time:   0.063355
 Self time:   0.000805

count  total (s)   self (s)
   17   0.002683   0.000373     let l:line_list = ale#sign#ReadSigns(a:buffer)
                            
   17   0.060576   0.000336     return ale#sign#ParseSigns(l:line_list)

FUNCTION  ale#command#ManageDirectory()
Called 23 times
Total time:   0.001450
 Self time:   0.000577

count  total (s)   self (s)
   23   0.001181   0.000309     call ale#command#InitData(a:buffer)
   23              0.000229     call add(s:buffer_data[a:buffer].directory_list, a:directory)

FUNCTION  xray#list#SaveOriginalListOptions()
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000010   let b:original_list      = &l:list
    1              0.000004   let b:original_listchars = &l:listchars

FUNCTION  ale#highlight#nvim_buf_add_highlight()
Called 1212 times
Total time:   0.017598
 Self time:   0.017598

count  total (s)   self (s)
                                " Ignore all errors for adding highlights.
 1212              0.001098     try
 1212              0.012687         call nvim_buf_add_highlight(a:buffer, a:ns_id, a:hl_group, a:line, a:col_start, a:col_end)
 1212              0.001023     catch
                                endtry

FUNCTION  denite#helper#call_denite()
Called 1 time
Total time:   0.402110
 Self time:   0.000125

count  total (s)   self (s)
    1   0.002799   0.000079   let [args, context] = denite#helper#_parse_options_args(a:args)
                            
    1              0.000002   let context.command = a:command
    1              0.000002   let context.firstline = a:line1
    1              0.000001   let context.lastline = a:line2
                            
    1   0.399301   0.000036   call denite#start(args, context)

FUNCTION  <SNR>142_IsBoolean()
Called 20 times
Total time:   0.000099
 Self time:   0.000099

count  total (s)   self (s)
   20              0.000086     return type(a:value) is v:t_number && (a:value == 0 || a:value == 1)

FUNCTION  <SNR>172_Pyeval()
Called 213 times
Total time:   0.401381
 Self time:   0.401381

count  total (s)   self (s)
  213              0.000624   if s:using_python3
  213              0.400279     return py3eval( a:eval_string )
                              endif
                              return pyeval( a:eval_string )

FUNCTION  <SNR>171_completion_timer_start()
Called 79 times
Total time:   0.049201
 Self time:   0.004194

count  total (s)   self (s)
   79              0.000717   if exists('s:completion_timer')
                                call s:completion_timer_stop()
                              endif
                            
   79   0.001857   0.001393   let delay = deoplete#custom#_get_option('auto_complete_delay')
   79              0.000129   if delay > 0
                                let s:completion_timer = timer_start( delay, {-> deoplete#handler#_completion_begin(a:event)})
                              else
   79   0.045207   0.000663     call deoplete#handler#_completion_begin(a:event)
   79              0.000055   endif

FUNCTION  ale#sign#GetSignName()
Called 185 times
Total time:   0.015856
 Self time:   0.009616

count  total (s)   self (s)
  185              0.000383     let l:priority = g:ale#util#style_warning_priority
                            
                                " Determine the highest priority item for the line.
  793              0.001038     for l:item in a:sublist
  608   0.008633   0.002393         let l:item_priority = ale#util#GetItemPriority(l:item)
                            
  608              0.000699         if l:item_priority > l:priority
  185              0.000244             let l:priority = l:item_priority
  185              0.000139         endif
  608              0.001191     endfor
                            
  185              0.000291     if l:priority is# g:ale#util#error_priority
                                    return 'ALEErrorSign'
                                endif
                            
  185              0.000237     if l:priority is# g:ale#util#warning_priority
  185              0.000193         return 'ALEWarningSign'
                                endif
                            
                                if l:priority is# g:ale#util#style_error_priority
                                    return 'ALEStyleErrorSign'
                                endif
                            
                                if l:priority is# g:ale#util#style_warning_priority
                                    return 'ALEStyleWarningSign'
                                endif
                            
                                if l:priority is# g:ale#util#info_priority
                                    return 'ALEInfoSign'
                                endif
                            
                                " Use the error sign for invalid severities.
                                return 'ALEErrorSign'

FUNCTION  32()
Called 3 times
Total time:   0.119906
 Self time:   0.000250

count  total (s)   self (s)
    3              0.000017   if a:reg == '"'
                                call s:clipboard.set(a:lines,a:regtype,'+')
                                if s:copy['*'] != s:copy['+']
                                  call s:clipboard.set(a:lines,a:regtype,'*')
                                end
                                return 0
                              end
                            
    3              0.000017   if type(s:copy[a:reg]) == v:t_func
                                call s:copy[a:reg](a:lines, a:regtype)
                                return 0
                              end
                            
    3              0.000005   if s:cache_enabled == 0
    3   0.119790   0.000134     call s:try_cmd(s:copy[a:reg], a:lines)
    3              0.000009     return 0
                              end
                            
                              if s:selections[a:reg].owner > 0
                                " The previous provider instance should exit when the new one takes
                                " ownership, but kill it to be sure we don't fill up the job table.
                                call jobstop(s:selections[a:reg].owner)
                              end
                              let s:selections[a:reg] = copy(s:selection)
                              let selection = s:selections[a:reg]
                              let selection.data = [a:lines, a:regtype]
                              let argv = split(s:copy[a:reg], " ")
                              let selection.argv = argv
                              let selection.detach = s:cache_enabled
                              let selection.cwd = "/"
                              let jobid = jobstart(argv, selection)
                              if jobid > 0
                                call jobsend(jobid, a:lines)
                                call jobclose(jobid, 'stdin')
                                let selection.owner = jobid
                              else
                                echohl WarningMsg
                                echomsg 'clipboard: failed to execute: '.(s:copy[a:reg])
                                echohl None
                                return 0
                              endif
                              return 1

FUNCTION  <SNR>172_UpdateMatches()
Called 11 times
Total time:   0.065237
 Self time:   0.065237

count  total (s)   self (s)
   11              0.065198   exec s:python_command "ycm_state.UpdateMatches()"

FUNCTION  <SNR>137_ExpireStatus()
Called 3 times
Total time:   0.000999
 Self time:   0.000264

count  total (s)   self (s)
    3              0.000026   if a:bufnr == -2
                                let s:head_cache = {}
                                let s:last_time = reltime()
                                return ''
                              endif
    3   0.000443   0.000057   let dir = s:Dir(a:bufnr)
    3              0.000012   if len(dir)
    3   0.000423   0.000074     let s:last_times[s:cpath(dir)] = reltime()
    3              0.000022     if has_key(s:head_cache, dir)
                                  call remove(s:head_cache, dir)
                                endif
    3              0.000002   endif
    3              0.000003   return ''

FUNCTION  <SNR>164_ClearOtherEvents()
Called 10 times
Total time:   0.000268
 Self time:   0.000268

count  total (s)   self (s)
   20              0.000066   for augroup in s:registered
   10              0.000057     if augroup != a:group && exists('#'.augroup)
                                  execute 'autocmd!' augroup
                                endif
   10              0.000012   endfor

FUNCTION  ale#handlers#writegood#ResetOptions()
Called 1 time
Total time:   0.000293
 Self time:   0.000030

count  total (s)   self (s)
    1   0.000029   0.000012     call ale#Set('writegood_options', '')
    1   0.000244   0.000006     call ale#Set('writegood_executable', 'write-good')
    1   0.000018   0.000010     call ale#Set('writegood_use_global', get(g:, 'ale_use_global_executables', 0))

FUNCTION  LanguageClient#handleBufNewFile()
Called 2 times
Total time:   0.000510
 Self time:   0.000129

count  total (s)   self (s)
    2              0.000007     try
    2   0.000475   0.000094         call LanguageClient#Notify('languageClient/handleBufNewFile', { 'filename': LSP#filename(), })
    2              0.000002     catch
                                    call s:Debug('LanguageClient caught exception: ' . string(v:exception))
                                endtry

FUNCTION  ale#util#GetLineCount()
Called 17 times
Total time:   0.000778
 Self time:   0.000778

count  total (s)   self (s)
   17              0.000706     return len(getbufline(a:buffer, 1, '$'))

FUNCTION  ale#FileTooLarge()
Called 388 times
Total time:   0.011204
 Self time:   0.011204

count  total (s)   self (s)
  388              0.005758     let l:max = getbufvar(a:buffer, 'ale_maximum_file_size', get(g:, 'ale_maximum_file_size', 0))
                            
  388              0.004537     return l:max > 0 ? (line2byte(line('$') + 1) > l:max) : 0

FUNCTION  ale#highlight#UpdateHighlights()
Called 25 times
Total time:   0.195373
 Self time:   0.058076

count  total (s)   self (s)
   25              0.000258     let l:item_list = get(b:, 'ale_enabled', 1) && g:ale_enabled   ? get(b:, 'ale_highlight_items', [])   : []
                            
   25   0.001397   0.000306     call ale#highlight#RemoveHighlights()
                            
 1237              0.002404     for l:item in l:item_list
 1212              0.002522         if l:item.type is# 'W'
 1212              0.004135             if get(l:item, 'sub_type', '') is# 'style'
                                            let l:group = 'ALEStyleWarning'
                                        else
 1212              0.001798                 let l:group = 'ALEWarning'
 1212              0.000683             endif
 1212              0.001312         elseif l:item.type is# 'I'
                                        let l:group = 'ALEInfo'
                                    elseif get(l:item, 'sub_type', '') is# 'style'
                                        let l:group = 'ALEStyleError'
                                    else
                                        let l:group = 'ALEError'
                                    endif
                            
 1212              0.013079         let l:range = {   'lnum': l:item.lnum,   'col': l:item.col,   'end_lnum': get(l:item, 'end_lnum', l:item.lnum),   'end_col': get(l:item, 'end_col', l:item.col)}
                            
 1212   0.150538   0.014333         call s:highlight_range(l:item.bufnr, l:range, l:group)
 1212              0.002228     endfor
                            
                                " If highlights are enabled and signs are not enabled, we should still
                                " offer line highlights by adding a separate set of highlights.
   25              0.000173     if !g:ale_set_signs
                                    let l:available_groups = {   'ALEWarningLine': hlexists('ALEWarningLine'),   'ALEInfoLine': hlexists('ALEInfoLine'),   'ALEErrorLine': hlexists('ALEErrorLine'),}
                            
                                    for l:item in l:item_list
                                        if l:item.type is# 'W'
                                            let l:group = 'ALEWarningLine'
                                        elseif l:item.type is# 'I'
                                            let l:group = 'ALEInfoLine'
                                        else
                                            let l:group = 'ALEErrorLine'
                                        endif
                            
                                        if l:available_groups[l:group]
                                            call s:highlight_line(l:item.bufnr, l:item.lnum, l:group)
                                        endif
                                    endfor
                                endif

FUNCTION  <lambda>42()
Called 1 time
Total time:   0.001935
 Self time:   0.000023

count  total (s)   self (s)
    1   0.001935   0.000022 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <SNR>188_CloseWindowIfNeeded()
Called 17 times
Total time:   0.001371
 Self time:   0.000479

count  total (s)   self (s)
   17   0.001297   0.000405     if ale#Var(a:buffer, 'keep_list_window_open') || !s:ShouldOpen(a:buffer)
   17              0.000018         return
                                endif
                            
                                let l:did_close_any_list = 0
                            
                                try
                                    " Only close windows if the quickfix list or loclist is completely empty,
                                    " including errors set through other means.
                                    if g:ale_set_quickfix
                                        if empty(getqflist())
                                            cclose
                                            let l:did_close_any_list = 1
                                        endif
                                    else
                                        let l:win_ids = s:WinFindBuf(a:buffer)
                            
                                        for l:win_id in l:win_ids
                                            if g:ale_set_loclist && empty(getloclist(l:win_id))
                                                lclose
                                                let l:did_close_any_list = 1
                                            endif
                                        endfor
                                    endif
                                " Ignore 'Cannot close last window' errors.
                                catch /E444/
                                endtry
                            
                                if l:did_close_any_list
                                    call s:RestoreViewIfNeeded(a:buffer)
                                endif

FUNCTION  pencil#setAutoFormat()
Called 4 times
Total time:   0.000245
 Self time:   0.000245

count  total (s)   self (s)
                              " 1=enable, 0=disable, -1=toggle
    4              0.000024   if !exists('b:last_autoformat')
    1              0.000002     let b:last_autoformat = 0
    1              0.000001   en
    4              0.000015   let l:nu_af = a:af ==# -1 ? !b:last_autoformat : a:af
    4              0.000023   let l:is_hard = exists('b:pencil_wrap_mode') && b:pencil_wrap_mode ==# s:WRAP_MODE_HARD
    4              0.000007   if l:nu_af && l:is_hard
                                aug pencil_autoformat
                                  au InsertEnter <buffer> call s:maybe_enable_autoformat()
                                  au InsertLeave <buffer> set formatoptions-=a
                                aug END
                              el
    4              0.000085     sil! au! pencil_autoformat * <buffer>
    4              0.000008     if l:nu_af && !l:is_hard
                                  echohl WarningMsg
                                  echo 'autoformat can only be enabled in hard line break mode'
                                  echohl NONE
                                  return
                                en
    4              0.000002   en
    4              0.000009   let b:last_autoformat = l:nu_af

FUNCTION  lightline#update()
Called 11 times
Total time:   0.032736
 Self time:   0.001938

count  total (s)   self (s)
   11              0.000101   if &buftype ==# 'popup' | return | endif
   11              0.000022   if s:_
                                if s:_ == 2 | return | endif
                                call lightline#init()
                                call lightline#colorscheme()
                              endif
   11              0.000056   if !s:lightline.enable.statusline
                                return
                              endif
   11              0.000043   let w = winnr()
   11   0.031082   0.000284   let s = winnr('$') == 1 && w > 0 ? [lightline#statusline(0)] : [lightline#statusline(0), lightline#statusline(1)]
   25              0.000073   for n in range(1, winnr('$'))
   14              0.000263     call setwinvar(n, '&statusline', s[n!=w])
   14              0.000117     call setwinvar(n, 'lightline', n!=w)
   14              0.000012   endfor

FUNCTION  ale#handlers#writegood#DefineLinter()
Called 1 time
Total time:   0.000402
 Self time:   0.000020

count  total (s)   self (s)
    1   0.000401   0.000019     call ale#linter#Define(a:filetype, {   'name': 'writegood',   'aliases': ['write-good'],   'executable': function('ale#handlers#writegood#GetExecutable'),   'command': function('ale#handlers#writegood#GetCommand'),   'callback': 'ale#handlers#writegood#Handle',})

FUNCTION  <SNR>137_ReloadWinStatus()
Called 3 times
Total time:   0.000035
 Self time:   0.000035

count  total (s)   self (s)
    3              0.000022   if get(b:, 'fugitive_type', '') !=# 'index' || &modified
    3              0.000004     return
                              endif
                              if !exists('b:fugitive_reltime')
                                exe s:ReloadStatusBuffer()
                                return
                              endif
                              let t = b:fugitive_reltime
                              if reltimestr(reltime(s:last_time, t)) =~# '-\|\d\{10\}\.' || reltimestr(reltime(get(s:last_times, s:cpath(s:Dir()), t), t)) =~# '-\|\d\{10\}\.'
                                exe s:ReloadStatusBuffer()
                              endif

FUNCTION  neosnippet#util#option2list()
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000010   return type(a:str) == type('') ? split(a:str, '\s*,\s*') : a:str

FUNCTION  ale#engine#MarkLinterInactive()
Called 17 times
Total time:   0.000213
 Self time:   0.000213

count  total (s)   self (s)
   17              0.000165     call filter(a:info.active_linter_list, 'v:val.name isnot# a:linter_name')

FUNCTION  <SNR>139_substitute_path_separator()
Called 90 times
Total time:   0.000630
 Self time:   0.000630

count  total (s)   self (s)
   90              0.000508   return s:is_windows ? substitute(a:path, '\\', '/', 'g') : a:path

FUNCTION  <SNR>216_NetrwBookHistSave()
Called 1 time
Total time:   0.137628
 Self time:   0.010446

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwBookHistSave() dirhistmax=".g:netrw_dirhistmax)
    1              0.000026   if !exists("g:netrw_dirhistmax") || g:netrw_dirhistmax <= 0
                            "   call Dret("s:NetrwBookHistSave : dirhistmax=".g:netrw_dirhistmax)
                               return
                              endif
                            
    1   0.001417   0.000283   let savefile= s:NetrwHome()."/.netrwhist"
    1              0.000478   1split
    1   0.129193   0.003145   call s:NetrwEnew()
    1              0.000010   if g:netrw_use_noswf
    1              0.000496    setl cino= com= cpo-=a cpo-=A fo=nroql2 tw=0 report=10000 noswf
    1              0.000004   else
                               setl cino= com= cpo-=a cpo-=A fo=nroql2 tw=0 report=10000
                              endif
    1              0.000059   setl nocin noai noci magic nospell nohid wig= noaw
    1              0.000018   setl ma noro write
    1              0.000027   if exists("+acd") | setl noacd | endif
    1              0.000023   sil! NetrwKeepj keepalt %d _
                            
                              " save .netrwhist -- no attempt to merge
    1              0.000436   sil! keepalt file .netrwhist
    1              0.000050   call setline(1,"let g:netrw_dirhistmax  =".g:netrw_dirhistmax)
    1              0.000032   call setline(2,"let g:netrw_dirhist_cnt =".g:netrw_dirhist_cnt)
    1              0.000013   let lastline = line("$")
    1              0.000005   let cnt      = 1
    3              0.000018   while cnt <= g:netrw_dirhist_cnt
    2              0.000055    call setline((cnt+lastline),'let g:netrw_dirhist_'.cnt."='".g:netrw_dirhist_{cnt}."'")
    2              0.000011    let cnt= cnt + 1
    2              0.000006   endwhile
    1              0.003807   exe "sil! w! ".savefile
                            
    1              0.000048   sil NetrwKeepj %d _
    1              0.000017   if exists("g:netrw_bookmarklist") && g:netrw_bookmarklist != []
                               " merge and write .netrwbook
                               let savefile= s:NetrwHome()."/.netrwbook"
                            
                               if filereadable(s:NetrwFile(savefile))
                                let booklist= deepcopy(g:netrw_bookmarklist)
                                exe "sil NetrwKeepj keepalt so ".savefile
                                for bdm in booklist
                                 if index(g:netrw_bookmarklist,bdm) == -1
                                  call add(g:netrw_bookmarklist,bdm)
                                 endif
                                endfor
                                call sort(g:netrw_bookmarklist)
                               endif
                            
                               " construct and save .netrwbook
                               call setline(1,"let g:netrw_bookmarklist= ".string(g:netrw_bookmarklist))
                               exe "sil! w! ".savefile
                              endif
    1              0.000009   let bgone= bufnr("%")
    1              0.000465   q!
    1              0.000742   exe "keepalt ".bgone."bwipe!"
                            
                            "  call Dret("s:NetrwBookHistSave")

FUNCTION  xray#list#ConfigureListOptionsForVisualMode()
Called 1 time
Total time:   0.001101
 Self time:   0.001020

count  total (s)   self (s)
    1              0.000020   execute 'silent! setlocal list'
                            
                              " this setting is, tragically, only global, so setting this here will
                              " affect all windows, but hopefully if we do the highlighting first,
                              " we won't reveal the listchars in those windows; using 'setlocal'
                              " anyways because it degrades to 'set' and because someday maybe it
                              " will acquire a local ability
    1              0.000011   execute 'silent! setlocal listchars='
                            
    1   0.000062   0.000052   if !empty(xray#settings#GetSpaceChar())
    1   0.000043   0.000037     execute 'silent! setlocal listchars+=space:' . escape((xray#settings#GetSpaceChar()), ' ')
    1              0.000001   endif
                            
    1   0.000062   0.000054   if !empty(xray#settings#GetTabChars())
    1   0.000025   0.000021     execute 'silent! setlocal listchars+=tab:' . escape((xray#settings#GetTabChars()), ' ')
    1              0.000001   endif
                            
    1   0.000088   0.000070   if !empty(xray#settings#GetEolChar())
    1   0.000520   0.000516     execute 'silent! setlocal listchars+=eol:' . escape((xray#settings#GetEolChar()), ' ')
    1              0.000008   endif
                            
    1   0.000195   0.000174   if !empty(xray#settings#GetTrailChar())
    1   0.000049   0.000039     execute 'silent! setlocal listchars+=trail:' . escape((xray#settings#GetTrailChar()), ' ')
    1              0.000001   endif

FUNCTION  <SNR>137_can_diffoff()
Called 16 times
Total time:   0.000310
 Self time:   0.000310

count  total (s)   self (s)
   16              0.000283   return getwinvar(bufwinnr(a:buf), '&diff') && !empty(getwinvar(bufwinnr(a:buf), 'fugitive_diff_restore'))

FUNCTION  <SNR>4_loaded_names()
Called 1 time
Total time:   0.000325
 Self time:   0.000325

count  total (s)   self (s)
    1              0.000324   return filter(copy(g:plugs_order), 'get(s:loaded, v:val, 0)')

FUNCTION  defx#redraw()
Called 3 times
Total time:   0.009587
 Self time:   0.000395

count  total (s)   self (s)
    3   0.009560   0.000367   call defx#util#rpcrequest('_defx_redraw', [], v:false)

FUNCTION  GetVimIndent()
Called 52 times
Total time:   0.028841
 Self time:   0.001950

count  total (s)   self (s)
   52              0.000219   let ignorecase_save = &ignorecase
   52              0.000063   try
   52              0.000225     let &ignorecase = 0
   52   0.027554   0.000662     return GetVimIndentIntern()
                              finally
   52              0.000506     let &ignorecase = ignorecase_save
   52              0.000068   endtry

FUNCTION  deoplete#custom#_get_filetype_option()
Called 50 times
Total time:   0.002388
 Self time:   0.002388

count  total (s)   self (s)
   50              0.000417   let buffer_option = s:cached.buffer_option
   50              0.000258   if has_key(buffer_option, a:name)
                                " Use buffer_option instead
                                return buffer_option[a:name]
                              endif
                            
   50              0.000183   let option = s:cached.option[a:name]
   50              0.000596   let filetype = has_key(option, a:filetype) ? a:filetype : '_'
   50              0.000223   return get(option, filetype, a:default)

FUNCTION  sy#verbose()
Called 60 times
Total time:   0.001764
 Self time:   0.001764

count  total (s)   self (s)
   60              0.000232   if &verbose
                                if type(a:msg) == type([])
                                  for msg in a:msg
                                    echomsg printf('[sy%s] %s', (a:0 ? ':'.a:1 : ''), msg)
                                  endfor
                                else
                                  echomsg printf('[sy%s] %s', (a:0 ? ':'.a:1 : ''), a:msg)
                                endif
                              endif

FUNCTION  defx#util#rpcrequest()
Called 3 times
Total time:   0.009193
 Self time:   0.007189

count  total (s)   self (s)
    3   0.000860   0.000807   if !defx#init#_check_channel()
                                return -1
                              endif
                            
    3   0.000608   0.000538   if defx#util#has_yarp()
                                if g:defx#_yarp.job_is_dead
                                  return -1
                                endif
                                if a:is_async
                                  return g:defx#_yarp.notify(a:method, a:args)
                                else
                                  return g:defx#_yarp.request(a:method, a:args)
                                endif
                              else
    3              0.000007     if a:is_async
                                  return rpcnotify(g:defx#_channel_id, a:method, a:args)
                                else
    3   0.007603   0.005723       return rpcrequest(g:defx#_channel_id, a:method, a:args)
                                endif
                              endif

FUNCTION  xray#settings#GetTrailChar()
Called 2 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    2              0.000029   return get(g:, 'xray_trail_char', 'Â·')

FUNCTION  <SNR>100_nscall()
Called 49 times
Total time:   0.002576
 Self time:   0.002576

count  total (s)   self (s)
   49              0.000211   if len(a:ns) && !get(g:, 'projectionist_ignore_' . a:ns) && exists('*' . a:ns . '#' . a:fn)
                                return call(a:ns . '#' . a:fn, [a:path] + a:000)
                              else
   49              0.002172     return call(a:fn, [a:path] + a:000)
                              endif

FUNCTION  <SNR>171_is_skip()
Called 79 times
Total time:   0.030794
 Self time:   0.002567

count  total (s)   self (s)
   79              0.000361   if a:event ==# 'TextChangedP' && !empty(v:completed_item)
    3              0.000006     return 1
                              endif
                            
   76   0.028706   0.000680   if s:is_skip_text(a:event)
    2              0.000002     return 1
                              endif
                            
   74   0.000709   0.000508   let auto_complete = deoplete#custom#_get_option('auto_complete')
                            
   74              0.000365   if &paste || (a:event !=# 'Manual' && a:event !=# 'Update' && !auto_complete) || (&l:completefunc !=# '' && &l:buftype =~# 'nofile') || (a:event !=# 'InsertEnter' && mode() !=# 'i')
   73              0.000067     return 1
                              endif
                            
    1              0.000001   return 0

FUNCTION  xray#settings#GetEolChar()
Called 2 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    2              0.000020   return get(g:, 'xray_eol_char', 'Â¶')

FUNCTION  ale#events#ReadOrEnterEvent()
Called 10 times
Total time:   0.000387
 Self time:   0.000387

count  total (s)   self (s)
                                " Apply pattern options if the variable is set.
   10              0.000080     if get(g:, 'ale_pattern_options_enabled', 1)&& !empty(get(g:, 'ale_pattern_options'))
                                    call ale#pattern_options#SetOptions(a:buffer)
                                endif
                            
                                " When entering a buffer, we are no longer quitting it.
   10              0.000058     call setbufvar(a:buffer, 'ale_quitting', 0)
   10              0.000053     let l:filetype = getbufvar(a:buffer, '&filetype')
   10              0.000048     call setbufvar(a:buffer, 'ale_original_filetype', l:filetype)
                            
                                " If the file changed outside of Vim, check it on BufEnter,BufRead
   10              0.000027     if getbufvar(a:buffer, 'ale_file_changed')
                                    call ale#events#LintOnEnter(a:buffer)
                                endif

FUNCTION  <SNR>228_MapNormVis()
Called 6 times
Total time:   0.000267
 Self time:   0.000267

count  total (s)   self (s)
    6              0.000141     execute 'nn <buffer><silent> ' . a:rhs . ' :call ' . a:lhs . '()<cr>'
    6              0.000122     execute 'vn <buffer><silent> ' . a:rhs . ' <esc>:call <sid>VisMove(''' . a:lhs . ''')<cr>'

FUNCTION  lightline#buffer#bufferafter()
Called 14 times
Total time:   0.170266
 Self time:   0.000429

count  total (s)   self (s)
   14   0.170150   0.000314   call lightline#buffer#bufferline()
   14              0.000068   if exists('g:lightline_buffer_status_info.after')
   14              0.000029     return g:lightline_buffer_status_info.after
                              endif
                              return ''

FUNCTION  deoplete#util#get_next_input()
Called 12 times
Total time:   0.001484
 Self time:   0.000534

count  total (s)   self (s)
   12   0.001454   0.000504   return getline('.')[len(deoplete#util#get_input(a:event)) :]

FUNCTION  provider#python3#Call()
Called 903 times
Total time:   3.132564
 Self time:   3.132564

count  total (s)   self (s)
  903              0.003412   if s:err != ''
                                return
                              endif
  903              0.003938   if !exists('s:host')
                                let s:rpcrequest = function('rpcrequest')
                            
                                " Ensure that we can load the Python3 host before bootstrapping
                                try
                                  let s:host = remote#host#Require('legacy-python3-provider')
                                catch
                                  let s:err = v:exception
                                  echohl WarningMsg
                                  echomsg v:exception
                                  echohl None
                                  return
                                endtry
                              endif
  903              3.098236   return call(s:rpcrequest, insert(insert(a:args, 'python_'.a:method), s:host))

FUNCTION  <lambda>53()
Called 1 time
Total time:   0.000076
 Self time:   0.000046

count  total (s)   self (s)
    1   0.000074   0.000044 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  xray#highlight#RestoreOriginalHighlights()
Called 1 time
Total time:   0.000127
 Self time:   0.000127

count  total (s)   self (s)
    1              0.000050   execute 'silent highlight clear SpecialKey'
    1              0.000022   execute 'silent highlight clear NonText'
                            
    1              0.000033   execute 'silent highlight SpecialKey ' . g:xray_original_special_key_details
    1              0.000019   execute 'silent highlight NonText '    . g:xray_original_non_text_details

FUNCTION  <SNR>197_make_cache()
Called 16 times
Total time:   0.034911
 Self time:   0.000539

count  total (s)   self (s)
   16              0.000079   let ft = &filetype
   16              0.000106   if ft == '' || ft ==# 'vim' || has_key(s:syntax_list, ft)
   15              0.000021     return
                              endif
                            
                              " Make cache from syntax list.
    1   0.034600   0.000228   let s:syntax_list[ft] = s:make_cache_from_syntax(ft)

FUNCTION  LanguageClient#exit()
Called 1 time
Total time:   0.000335
 Self time:   0.000083

count  total (s)   self (s)
    1   0.000304   0.000053     return LanguageClient#Notify('exit', { 'languageId': &filetype, })

FUNCTION  11()
Called 46 times
Total time:   0.001038
 Self time:   0.001038

count  total (s)   self (s)
   46              0.000937   return self.mtime < getftime(self.mru_file)

FUNCTION  12()
Called 14 times
Total time:   0.102350
 Self time:   0.004405

count  total (s)   self (s)
   14   0.000360   0.000146   if s:is_sudo()
                                return
                              endif
                            
   14              0.000100   let opts = a:0 >= 1 && type(a:1) == type({}) ? a:1 : {}
                            
   14   0.000465   0.000144   if self.has_external_update() && filereadable(self.mru_file)
                                " only need to get the list which contains the latest MRUs
                                let lines = readfile(self.mru_file)
                                if !empty(lines)
                                  let [ver; items] = lines
                                  if self.version_check(ver)
                                    call extend(self.candidates, items)
                                  endif
                                endif
                              endif
                            
   14   0.009759   0.000359   let self.candidates = s:uniq(self.candidates)
   14              0.000068   if len(self.candidates) > self.limit
                                let self.candidates = self.candidates[: self.limit - 1]
                              endif
                            
   14              0.000054   if get(opts, 'event') ==# 'VimLeavePre'
   14   0.076677   0.001398     call self.validate()
   14              0.000016   endif
                            
   14   0.013511   0.000780   call s:writefile(self.mru_file, [self.version] + self.candidates)
                            
   14              0.000592   let self.mtime = getftime(self.mru_file)

FUNCTION  15()
Called 32 times
Total time:   0.054536
 Self time:   0.001167

count  total (s)   self (s)
   32   0.001620   0.000238   call self.load()
   32              0.000208   let index = index(self.candidates, a:path)
   32              0.000045   if index == 0
   19              0.000013     return
                              endif
                            
   13              0.000012   if index > 0
    8              0.000048     call remove(self.candidates, index)
    8              0.000005   endif
   13              0.000055   call insert(self.candidates, a:path)
                            
   13              0.000035   if len(self.candidates) > self.limit
                                let self.candidates = self.candidates[: self.limit - 1]
                              endif
                            
   13              0.000192   if localtime() > getftime(self.mru_file) + self.update_interval
   12   0.052126   0.000138     call self.save()
   12              0.000020   endif

FUNCTION  17()
Called 7 times
Total time:   0.073141
 Self time:   0.003245

count  total (s)   self (s)
    7              0.000023   if self.do_validate
    7   0.073074   0.003178     call filter(self.candidates, 's:is_file_exist(v:val)')
    7              0.000018   endif

FUNCTION  deoplete#util#convert2list()
Called 15 times
Total time:   0.000216
 Self time:   0.000216

count  total (s)   self (s)
   15              0.000162   return type(a:expr) ==# v:t_list ? a:expr : [a:expr]

FUNCTION  ale#history#RememberOutput()
Called 17 times
Total time:   0.000563
 Self time:   0.000171

count  total (s)   self (s)
   17   0.000506   0.000114     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
   17              0.000036     let l:obj.output = a:output

FUNCTION  ale#Var()
Called 754 times
Total time:   0.020221
 Self time:   0.020221

count  total (s)   self (s)
  754              0.003729     let l:full_name = 'ale_' . a:variable_name
  754              0.007588     let l:vars = getbufvar(str2nr(a:buffer), '', {})
                            
  754              0.007162     return get(l:vars, l:full_name, g:[l:full_name])

FUNCTION  ale#ShouldDoNothing()
Called 389 times
Total time:   0.108002
 Self time:   0.081021

count  total (s)   self (s)
                                " The checks are split into separate if statements to make it possible to
                                " profile each check individually with Vim's profiling tools.
                                "
                                " Do nothing if ALE is disabled.
  389              0.004910     if !getbufvar(a:buffer, 'ale_enabled', get(g:, 'ale_enabled', 0))
                                    return 1
                                endif
                            
                                " Don't perform any checks when newer NeoVim versions are exiting.
  389              0.002459     if get(v:, 'exiting', v:null) isnot v:null
                                    return 1
                                endif
                            
  389              0.004368     let l:filetype = getbufvar(a:buffer, '&filetype')
                            
                                " Do nothing when there's no filetype.
  389              0.001540     if l:filetype is# ''
    1              0.000001         return 1
                                endif
                            
                                " Do nothing for diff buffers.
  388              0.002096     if getbufvar(a:buffer, '&diff')
                                    return 1
                                endif
                            
                                " Do nothing for blacklisted files.
  388              0.003749     if index(get(g:, 'ale_filetype_blacklist', []), l:filetype) >= 0
                                    return 1
                                endif
                            
                                " Do nothing if running from command mode.
  388              0.002457     if s:getcmdwintype_exists && !empty(getcmdwintype())
                                    return 1
                                endif
                            
  388              0.004531     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
                                " Do nothing for directories.
  388              0.001269     if l:filename is# '.'
                                    return 1
                                endif
                            
                                " Don't start linting and so on when an operator is pending.
  388   0.009374   0.005861     if ale#util#Mode(1) is# 'no'
                                    return 1
                                endif
                            
                                " Do nothing if running in the sandbox.
  388   0.023437   0.011174     if ale#util#InSandbox()
                                    return 1
                                endif
                            
                                " Do nothing if the file is too large.
  388   0.017896   0.006691     if ale#FileTooLarge(a:buffer)
                                    return 1
                                endif
                            
                                " Do nothing from CtrlP buffers with CtrlP-funky.
  388              0.008190     if exists(':CtrlPFunky') is 2&& getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
                                    return 1
                                endif
                            
  388              0.000414     return 0

FUNCTION  <SNR>25_SynSet()
Called 6 times
Total time:   0.228680
 Self time:   0.020551

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    6              0.001572   syn clear
    6              0.000030   if exists("b:current_syntax")
                                unlet b:current_syntax
                              endif
                            
    6              0.000026   let s = expand("<amatch>")
    6              0.000012   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
                              elseif s == "OFF"
                                let s = ""
                              endif
                            
    6              0.000008   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.
   12              0.000079     for name in split(s, '\.')
    6   0.226778   0.018649       exe "runtime! syntax/" . name . ".vim syntax/" . name . "/*.vim"
    6              0.000019     endfor
    6              0.000007   endif

FUNCTION  lightline#buffer#buffercurrent()
Called 14 times
Total time:   0.159658
 Self time:   0.000758

count  total (s)   self (s)
   14   0.159420   0.000520   call lightline#buffer#bufferline()
   14              0.000143   if exists('g:lightline_buffer_status_info.current')
   14              0.000047     return g:lightline_buffer_status_info.current
                              endif
                              return ''

FUNCTION  deoplete#util#uniq()
Called 9 times
Total time:   0.002231
 Self time:   0.002231

count  total (s)   self (s)
    9              0.000333   let list = map(copy(a:list), '[v:val, v:val]')
    9              0.000018   let i = 0
    9              0.000017   let seen = {}
  122              0.000231   while i < len(list)
  113              0.000354     let key = string(list[i][1])
  113              0.000247     if has_key(seen, key)
    7              0.000024       call remove(list, i)
    7              0.000004     else
  106              0.000188       let seen[key] = 1
  106              0.000095       let i += 1
  106              0.000051     endif
  113              0.000097   endwhile
    9              0.000183   return map(list, 'v:val[0]')

FUNCTION  <SNR>141_ApplyPartialTimer()
Called 15 times
Total time:   0.088384
 Self time:   0.000718

count  total (s)   self (s)
   15              0.000141     if has_key(s:partial_timers, a:timer_id)
   15              0.000161         let [l:Callback, l:args] = remove(s:partial_timers, a:timer_id)
   15   0.088022   0.000355         call call(l:Callback, [a:timer_id] + l:args)
   15              0.000010     endif

FUNCTION  <SNR>188_FixList()
Called 17 times
Total time:   0.077104
 Self time:   0.020136

count  total (s)   self (s)
   17   0.000545   0.000202     let l:format = ale#Var(a:buffer, 'loclist_msg_format')
   17              0.000050     let l:new_list = []
                            
  625              0.001077     for l:item in a:list
  608              0.003299         let l:fixed_item = copy(l:item)
                            
  608   0.062495   0.005871         let l:fixed_item.text = ale#GetLocItemMessage(l:item, l:format)
                            
  608              0.001361         if l:item.bufnr == -1
                                        " If the buffer number is invalid, remove it.
                                        call remove(l:fixed_item, 'bufnr')
                                    endif
                            
  608              0.001607         call add(l:new_list, l:fixed_item)
  608              0.002642     endfor
                            
   17              0.000033     return l:new_list

FUNCTION  Mapkey()
Called 32 times
Total time:   0.350657
 Self time:   0.350657

count  total (s)   self (s)
   32              0.122472   redir => mappings | silent! map | redir END
 3728              0.014802   for map in split(mappings, '\n')
 3720              0.142043     let seq = matchstr(map, '\s\+\zs\S*')
 3720              0.048783     if maparg(seq, a:mode) == a:keys
   24              0.000043       return seq
                                endif
 3696              0.010560   endfor
    8              0.000019   return a:keys

FUNCTION  lightline#buffer#bufferbefore()
Called 14 times
Total time:   0.242403
 Self time:   0.000875

count  total (s)   self (s)
   14   0.242228   0.000701   call lightline#buffer#bufferline()
   14              0.000087   if exists('g:lightline_buffer_status_info.before')
   14              0.000031     return g:lightline_buffer_status_info.before
                              endif
                              return ''

FUNCTION  <SNR>211_add_snippet_attribute()
Called 32 times
Total time:   0.005145
 Self time:   0.005145

count  total (s)   self (s)
                              " Allow overriding/setting of the description (abbr) of the snippet.
                              " This will override what was set via the snippet line.
   32              0.000362   if a:line =~# '^abbr\s'
   16              0.000570     let a:snippet_dict.abbr = matchstr(a:line, '^abbr\s\+\zs.*$')
   16              0.000025   elseif a:line =~# '^alias\s'
                                let a:snippet_dict.alias = split(matchstr(a:line, '^alias\s\+\zs.*$'), '[,[:space:]]\+')
                              elseif a:line =~# '^prev_word\s'
                                let prev_word = matchstr(a:line, '^prev_word\s\+[''"]\zs.*\ze[''"]$')
                                if prev_word ==# '^'
                                  " For backward compatibility.
                                  let a:snippet_dict.options.head = 1
                                else
                                  call neosnippet#util#print_error( 'prev_word must be "^" character.')
                                endif
                              elseif a:line =~# '^regexp\s'
                                let a:snippet_dict.regexp = matchstr(a:line, '^regexp\s\+[''"]\zs.*\ze[''"]$')
                              elseif a:line =~# '^options\s\+'
   32              0.000784     for option in split(matchstr(a:line, '^options\s\+\zs.*$'), '[,[:space:]]\+')
   16              0.000074       if !has_key(a:snippet_dict.options, option)
                                    call neosnippet#util#print_error( printf('%s:%d', a:snippets_file, a:linenr))
                                    call neosnippet#util#print_error( printf('Invalid option name : "%s"', option))
                                  else
   16              0.000048         let a:snippet_dict.options[option] = 1
   16              0.000010       endif
   16              0.000011     endfor
   16              0.000012   else
                                call neosnippet#util#print_error( printf('%s:%d', a:snippets_file, a:linenr))
                                call neosnippet#util#print_error( printf('Invalid syntax : "%s"', a:line))
                              endif

FUNCTION  <SNR>4_lod_ft()
Called 1 time
Total time:   0.176092
 Self time:   0.000086

count  total (s)   self (s)
    1              0.000009   let syn = 'syntax/'.a:pat.'.vim'
    1   0.108003   0.000047   call s:lod(a:names, ['plugin', 'after/plugin'], syn, 'after/'.syn)
    1              0.000010   execute 'autocmd! PlugLOD FileType' a:pat
    1   0.062918   0.000006   call s:doautocmd('filetypeplugin', 'FileType')
    1   0.005150   0.000012   call s:doautocmd('filetypeindent', 'FileType')

FUNCTION  24()
Called 32 times
Total time:   0.000632
 Self time:   0.000632

count  total (s)   self (s)
   32              0.000577       return getbufvar(self.bufnr, '&filetype')

FUNCTION  28()
Called 10 times
Total time:   0.000168
 Self time:   0.000168

count  total (s)   self (s)
                                  " Try the extension first, and then the filetype, for ctags relys on the extension name.
   10              0.000084       let e = fnamemodify(self.fpath, ':e')
   10              0.000061       return empty(e) ? getbufvar(self.bufnr, '&ft') : e

FUNCTION  <SNR>219_re_unquoted_match()
Called 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
                              " Don't match a:match if it is located in-between unescaped single or double
                              " quotes
    1              0.000016   return a:match . '\v\ze([^"' . "'" . '\\]*(\\.|"([^"\\]*\\.)*[^"\\]*"|' . "'" . '([^' . "'" . '\\]*\\.)*[^' . "'" . '\\]*' . "'" . '))*[^"' . "'" . ']*$'

FUNCTION  <SNR>145_RunJob()
Called 23 times
Total time:   0.146590
 Self time:   0.008202

count  total (s)   self (s)
   23   0.000354   0.000186     if ale#command#IsDeferred(a:command)
                                    let a:command.result_callback = {   command -> s:RunJob(command, a:options)}
                            
                                    return 1
                                endif
                            
   23              0.000058     let l:command = a:command
                            
   23              0.000082     if empty(l:command)
                                    return 0
                                endif
                            
   23              0.000083     let l:executable = a:options.executable
   23              0.000054     let l:buffer = a:options.buffer
   23              0.000049     let l:linter = a:options.linter
   23              0.000059     let l:output_stream = a:options.output_stream
   23              0.000060     let l:next_chain_index = a:options.next_chain_index
   23              0.000054     let l:read_buffer = a:options.read_buffer
   23              0.000091     let l:info = g:ale_buffer_info[l:buffer]
                            
   23              0.000398     let l:Callback = function('s:HandleExit', [{   'linter': l:linter,   'executable': l:executable,   'next_chain_index': l:next_chain_index,}])
   23   0.137415   0.001302     let l:result = ale#command#Run(l:buffer, l:command, l:Callback, {   'output_stream': l:output_stream,   'executable': l:executable,   'read_buffer': l:read_buffer,   'log_output': l:next_chain_index >= len(get(l:linter, 'command_chain', [])),})
                            
                                " Only proceed if the job is being run.
   23              0.000094     if empty(l:result)
                                    return 0
                                endif
                            
   23   0.001508   0.000748     call ale#engine#MarkLinterActive(l:info, l:linter)
                            
   23   0.005241   0.003895     silent doautocmd <nomodeline> User ALEJobStarted
                            
   23              0.000179     return 1

FUNCTION  LanguageClient#Notify()
Called 512 times
Total time:   0.074358
 Self time:   0.034173

count  total (s)   self (s)
  512   0.022108   0.006385     if s:SkipSendingMessage()
                                    " call s:Debug('Skip sending message')
  189              0.000219         return
                                endif
                            
  323              0.001136     let l:params = a:params
  323              0.002570     if type(params) == s:TYPE.dict
  323              0.006229         let l:params = extend({ 'bufnr': bufnr(''), 'languageId': &filetype, }, l:params)
  323              0.000569     endif
  323   0.039068   0.014606     return LanguageClient#Write(json_encode({ 'jsonrpc': '2.0', 'method': a:method, 'params': l:params, }))

FUNCTION  <SNR>150_line()
Called 28 times
Total time:   0.634773
 Self time:   0.023671

count  total (s)   self (s)
   28              0.000114   let _ = a:tabline ? '' : '%{lightline#link()}'
   28              0.000103   if s:lightline.palette == {}
                                call lightline#colorscheme()
                              endif
   28              0.000221   let [l, r] = a:tabline ? [s:lightline.tab_llen, s:lightline.tab_rlen] : [s:lightline.llen, s:lightline.rlen]
   28              0.000225   let [p, s] = a:tabline ? [s:lightline.tabline_separator, s:lightline.tabline_subseparator] : [s:lightline.separator, s:lightline.subseparator]
   28              0.000214   let [c, f, t, w] = [s:lightline.component, s:lightline.component_function, s:lightline.component_type, s:lightline.component_raw]
   28              0.000086   let mode = a:tabline ? 'tabline' : a:inactive ? 'inactive' : 'active'
   28              0.000225   let l_ = has_key(s:lightline, mode) ? s:lightline[mode].left : s:lightline.active.left
   28   0.597293   0.000827   let [lt, lc, ll] = s:expand(copy(l_))
   28              0.000238   let r_ = has_key(s:lightline, mode) ? s:lightline[mode].right : s:lightline.active.right
   28   0.011799   0.000654   let [rt, rc, rl] = s:expand(copy(r_))
  114              0.000350   for i in range(len(lt))
   86              0.000531     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '#'
  205              0.000713     for j in range(len(lt[i]))
  119              0.001636       let x = lc[i][j] ? lt[i][j] : has_key(f, lt[i][j]) ? (exists('*' . f[lt[i][j]]) ? '%{' . f[lt[i][j]] . '()}' : '%{exists("*' . f[lt[i][j]] . '")?' . f[lt[i][j]] . '():""}') : get(c, lt[i][j], '')
  119              0.001485       let _ .= has_key(t, lt[i][j]) && t[lt[i][j]] ==# 'raw' || get(w, lt[i][j]) || lc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
  119              0.001101       if j < len(lt[i]) - 1 && s.left !=# ''
   33   0.003303   0.001255         let _ .= s:subseparator(lt[i][(j):], s.left, lc[i][(j):])
   33              0.000031       endif
  119              0.000225     endfor
   86              0.000765     let _ .= '%#LightlineLeft_' . mode . '_' . ll[i] . '_' . ll[i + 1] . '#'
   86              0.001035     let _ .= i < l + len(lt) - len(l_) && ll[i] < l || ll[i] != ll[i + 1] ? p.left : len(lt[i]) ? s.left : ''
   86              0.000136   endfor
   28              0.000115   let _ .= '%#LightlineMiddle_' . mode . '#%='
   81              0.000277   for i in reverse(range(len(rt)))
   53              0.000362     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '_' . rl[i + 1] . '#'
   53              0.000427     let _ .= i < r + len(rt) - len(r_) && rl[i] < r || rl[i] != rl[i + 1] ? p.right : len(rt[i]) ? s.right : ''
   53              0.000236     let _ .= '%#LightlineRight_' . mode . '_' . rl[i] . '#'
  128              0.000303     for j in range(len(rt[i]))
   75              0.000931       let x = rc[i][j] ? rt[i][j] : has_key(f, rt[i][j]) ? (exists('*' . f[rt[i][j]]) ? '%{' . f[rt[i][j]] . '()}' : '%{exists("*' . f[rt[i][j]] . '")?' . f[rt[i][j]] . '():""}') : get(c, rt[i][j], '')
   75              0.000710       let _ .= has_key(t, rt[i][j]) && t[rt[i][j]] ==# 'raw' || get(w, rt[i][j]) || rc[i][j] ==# 2 || x ==# '' ? x : '%( ' . x . ' %)'
   75              0.000223       if j < len(rt[i]) - 1 && s.right !=# ''
   22   0.001833   0.000389         let _ .= s:subseparator(rt[i][(j):], s.right, rc[i][(j):])
   22              0.000022       endif
   75              0.000243     endfor
   53              0.000030   endfor
   28              0.000055   return _

FUNCTION  <SNR>106_ProjectionistDetect()
Called 5 times
Total time:   0.008981
 Self time:   0.000698

count  total (s)   self (s)
    5   0.000221   0.000095   let file = s:Slash(get(g:, 'projectionist_file', ''))
    5   0.006950   0.000131   let dir = FugitiveExtractGitDir(file)
    5              0.000064   let base = matchstr(file, '^fugitive://.\{-\}//\x\+')
    5              0.000011   if empty(base)
    5   0.000298   0.000046     let base = s:Tree(dir)
    5              0.000005   endif
    5              0.000009   if len(base)
    5              0.000018     if exists('+shellslash') && !&shellslash
                                  let base = tr(base, '/', '\')
                                endif
    5   0.001171   0.000084     let file = FugitiveCommonDir(dir) . '/info/projections.json'
    5              0.000174     if filereadable(file)
                                  call projectionist#append(base, file)
                                endif
    5              0.000002   endif

FUNCTION  provider#clipboard#Call()
Called 6 times
Total time:   0.333712
 Self time:   0.000634

count  total (s)   self (s)
    6              0.000084   if get(s:, 'here', v:false)  " Clipboard provider must not recurse. #7184
                                return 0
                              endif
    6              0.000039   let s:here = v:true
    6              0.000010   try
    6   0.333402   0.000324     return call(s:clipboard[a:method],a:args,s:clipboard)
                              finally
    6              0.000037     let s:here = v:false
    6              0.000012   endtry

FUNCTION  <SNR>188_SetListsImpl()
Called 17 times
Total time:   0.088844
 Self time:   0.009137

count  total (s)   self (s)
   17              0.001649     let l:title = expand('#' . a:buffer . ':p')
                            
   17              0.000049     if g:ale_set_quickfix
                                    let l:quickfix_list = ale#list#GetCombinedList()
                            
                                    if has('nvim')
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list), ' ', l:title)
                                    else
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list))
                                        call setqflist([], 'r', {'title': l:title})
                                    endif
                                elseif g:ale_set_loclist
                                    " If windows support is off, win_findbuf() may not exist.
                                    " We'll set result in the current window, which might not be correct,
                                    " but it's better than nothing.
   17   0.000490   0.000234         let l:ids = s:WinFindBuf(a:buffer)
                            
   34              0.000082         for l:id in l:ids
   17              0.000291             if has('nvim')
   17   0.080439   0.003335                 call setloclist(l:id, s:FixList(a:buffer, a:loclist), ' ', l:title)
   17              0.000025             else
                                            call setloclist(l:id, s:FixList(a:buffer, a:loclist))
                                            call setloclist(l:id, [], 'r', {'title': l:title})
                                        endif
   17              0.000017         endfor
   17              0.000013     endif
                            
                                " Save the current view before opening/closing any window
   17              0.000542     call setbufvar(a:buffer, 'ale_winview', winsaveview())
                            
                                " Open a window to show the problems if we need to.
                                "
                                " We'll check if the current buffer's List is not empty here, so the
                                " window will only be opened if the current buffer has problems.
   17   0.000906   0.000222     if s:ShouldOpen(a:buffer) && !empty(a:loclist)
                                    let l:winnr = winnr()
                                    let l:mode = mode()
                            
                                    " open windows vertically instead of default horizontally
                                    let l:open_type = ''
                            
                                    if ale#Var(a:buffer, 'list_vertical') == 1
                                        let l:open_type = 'vert rightbelow '
                                    endif
                            
                                    if g:ale_set_quickfix
                                        if !ale#list#IsQuickfixOpen()
                                            silent! execute l:open_type . 'copen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                        endif
                                    elseif g:ale_set_loclist
                                        silent! execute l:open_type . 'lopen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                    endif
                            
                                    " If focus changed, restore it (jump to the last window).
                                    if l:winnr isnot# winnr()
                                        wincmd p
                                    endif
                            
                                    " Return to original mode when applicable
                                    if mode() != l:mode
                                        if l:mode is? 'v' || l:mode is# "\<c-v>"
                                            " Reset our last visual selection
                                            normal! gv
                                        elseif l:mode is? 's' || l:mode is# "\<c-s>"
                                            " Reset our last character selection
                                            normal! "\<c-g>"
                                        endif
                                    endif
                            
                                    call s:RestoreViewIfNeeded(a:buffer)
                                endif
                            
                                " If ALE isn't currently checking for more problems, close the window if
                                " needed now. This check happens inside of this timer function, so
                                " the window can be closed reliably.
   17   0.000616   0.000325     if !ale#engine#IsCheckingBuffer(a:buffer)
   17   0.001583   0.000212         call s:CloseWindowIfNeeded(a:buffer)
   17              0.000013     endif

FUNCTION  <SNR>137_DoAutocmd()
Called 4 times
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    4              0.000013   if v:version >= 704 || (v:version == 703 && has('patch442'))
    4              0.000009     return 'doautocmd <nomodeline>' . a:cmd
                              elseif &modelines > 0
                                return 'try|set modelines=0|doautocmd ' . a:cmd . '|finally|set modelines=' . &modelines . '|endtry'
                              else
                                return 'doautocmd ' . a:cmd
                              endif

FUNCTION  deoplete#util#rpcnotify()
Called 14 times
Total time:   0.002329
 Self time:   0.001584

count  total (s)   self (s)
   14   0.000482   0.000305   if !deoplete#init#_channel_initialized()
                                return ''
                              endif
                            
   14              0.000078   let a:context['rpc'] = a:method
                            
   14   0.000744   0.000176   if deoplete#util#has_yarp()
                                if g:deoplete#_yarp.job_is_dead
                                  return ''
                                endif
                                call g:deoplete#_yarp.notify(a:method, a:context)
                              else
   14              0.000622     call rpcnotify(g:deoplete#_channel_id, a:method, a:context)
   14              0.000067   endif
                            
   14              0.000045   return ''

FUNCTION  <SNR>138_get_script_candidates()
Called 2 times
Total time:   0.012631
 Self time:   0.003936

count  total (s)   self (s)
                              " Get script candidate list.
                            
    2              0.000009   let function_dict = {}
    2              0.000004   let variable_dict = {}
    2              0.000004   let dictionary_variable_dict = {}
    2              0.000004   let function_prototypes = {}
    2              0.000004   let var_pattern = '\a:[[:alnum:]_:]*\.\h\w*\%(()\?\)\?'
                            
   44              0.000153   for line in getbufline(a:bufnumber, 1, '$')
   42              0.000343     if line =~ '\<fu\%[nction]!\?\s\+'
                                  call s:analyze_function_line( line, function_dict, function_prototypes)
                                elseif line =~ '\<let\s\+'
                                  " Get script variable.
   33   0.009352   0.000657       call s:analyze_variable_line(line, variable_dict)
   33              0.000059     elseif line =~ var_pattern
                                  while line =~ var_pattern
                                    let var_name = matchstr(line, '\a:[[:alnum:]_:]*\ze\.\h\w*')
                                    let candidates_dict = dictionary_variable_dict
                                    if !has_key(candidates_dict, var_name)
                                      let candidates_dict[var_name] = {}
                                    endif
                            
                                    call s:analyze_dictionary_variable_line( line, candidates_dict[var_name], var_name)
                            
                                    let line = line[matchend(line, var_pattern) :]
                                  endwhile
                                endif
   42              0.000116   endfor
                            
    2              0.000014   return { 'functions' : function_dict, 'variables' : variable_dict, 'function_prototypes' : function_prototypes, 'dictionary_variables' : dictionary_variable_dict }

FUNCTION  sy#sign#get_current_signs()
Called 9 times
Total time:   0.202868
 Self time:   0.199700

count  total (s)   self (s)
    9              0.000156   let a:sy.internal = {}
    9              0.000129   let a:sy.external = {}
                            
    9   0.003962   0.000795   let signlist = sy#util#execute('sign place buffer='. a:sy.buffer)
                            
  207              0.004527   for signline in split(signlist, '\n')[2:]
  198              0.178784     let tokens = matchlist(signline, '\v^\s+\S+\=(\d+)\s+\S+\=(\d+)\s+\S+\=(.*)$')
  198              0.002031     let line   = str2nr(tokens[1])
  198              0.000786     let id     = str2nr(tokens[2])
  198              0.000644     let type   = tokens[3]
                            
  198              0.003704     if type =~# '^Signify'
                                  " Handle ambiguous signs. Assume you have signs on line 3 and 4.
                                  " Removing line 3 would lead to the second sign to be shifted up
                                  " to line 3. Now there are still 2 signs, both one line 3.
   15              0.000486       if has_key(a:sy.internal, line)
                                    execute 'sign unplace' a:sy.internal[line].id 'buffer='.a:sy.buffer
                                  endif
   15              0.000160       let a:sy.internal[line] = { 'type': type, 'id': id }
   15              0.000017     else
  183              0.001681       let a:sy.external[line] = id
  183              0.000786     endif
  198              0.001107   endfor

FUNCTION  deoplete#init#_prev_completion()
Called 17 times
Total time:   0.000477
 Self time:   0.000477

count  total (s)   self (s)
   17              0.000455   let g:deoplete#_prev_completion = { 'event': '', 'input': '', 'linenr': -1, 'candidates': [], 'complete_position': -1, }

FUNCTION  ale#sign#ParseSigns()
Called 17 times
Total time:   0.060240
 Self time:   0.059498

count  total (s)   self (s)
   17   0.000962   0.000220     let l:pattern =ale#sign#ParsePattern()
   17              0.000051     let l:result = []
   17              0.000179     let l:is_dummy_sign_set = 0
                            
  272              0.000417     for l:line in a:line_list
  255              0.053893         let l:match = matchlist(l:line, l:pattern)
                            
  255              0.000831         if len(l:match) > 0
  185              0.000406             if l:match[3] is# 'ALEDummySign'
                                            let l:is_dummy_sign_set = 1
                                        else
  185              0.001140                 call add(l:result, [   str2nr(l:match[1]),   str2nr(l:match[2]),   l:match[3],])
  185              0.000106             endif
  185              0.000086         endif
  255              0.000315     endfor
                            
   17              0.000059     return [l:is_dummy_sign_set, l:result]

FUNCTION  <SNR>228_MarkdownClearSyntaxVariables()
Called 1 time
Total time:   0.000063
 Self time:   0.000063

count  total (s)   self (s)
    1              0.000040     if &filetype =~ 'markdown'
                                    unlet! b:mkd_included_filetypes
                                endif

FUNCTION  sy#util#execute()
Called 9 times
Total time:   0.003167
 Self time:   0.003167

count  total (s)   self (s)
    9              0.000043   let lang = v:lang
    9              0.000050   redir => output
    9              0.002264     silent! execute a:cmd
    9              0.000103   redir END
    9              0.000630   silent! execute 'language message' lang
    9              0.000046   return output

FUNCTION  xray#settings#GetIgnoredFiletypes()
Called 5735 times
Total time:   0.074056
 Self time:   0.074056

count  total (s)   self (s)
 5735              0.065435   return get(g:, 'xray_ignored_filetypes', ['qf', 'nerdtree', 'tagbar'])

FUNCTION  31()
Called 3 times
Total time:   0.213172
 Self time:   0.000772

count  total (s)   self (s)
    3              0.000041   if type(s:paste[a:reg]) == v:t_func
                                return s:paste[a:reg]()
                              elseif s:selections[a:reg].owner > 0
                                return s:selections[a:reg].data
                              end
    3   0.212582   0.000182   return s:try_cmd(s:paste[a:reg])

FUNCTION  <SNR>158_replace()
Called 39 times
Total time:   0.000724
 Self time:   0.000724

count  total (s)   self (s)
   39              0.000448   let parts = split(a:cmd, a:pat, 1)
   39              0.000220   return join(parts, a:sub)

FUNCTION  test#determine_runner()
Called 6 times
Total time:   0.055836
 Self time:   0.026554

count  total (s)   self (s)
  132   0.003244   0.001072   for [language, runners] in items(test#get_runners())
  474              0.001003     for runner in runners
  348              0.003874       let runner = tolower(language).'#'.tolower(runner)
  348              0.002309       if exists("g:test#enabled_runners")
  348              0.001891         if index(g:test#enabled_runners, runner) < 0
  294              0.000662           continue
                                    endif
   54              0.000037       endif
   54   0.038742   0.011632       if test#base#test_file(runner, fnamemodify(a:file, ':.'))
                                    return runner
                                  endif
   54              0.000153     endfor
  126              0.000144   endfor

FUNCTION  <SNR>219_remove_quote_pairs()
Called 1 time
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
                              " remove leading/ending quote pairs
    1              0.000003   let s = a:s
    1              0.000004   if s[0] ==# '"' && s[len(s) - 1] ==# '"'
                                let s = s[1: len(s) - 2]
                              elseif s[0] ==# "'" && s[len(s) - 1] ==# "'"
                                let s = s[1: len(s) - 2]
                              else
    1              0.000006     let s = substitute(a:s, '\\\(.\)', "\\1", 'g')
    1              0.000001   endif
    1              0.000001   return s

FUNCTION  <SNR>188_ShouldOpen()
Called 34 times
Total time:   0.001302
 Self time:   0.000704

count  total (s)   self (s)
   34   0.000915   0.000317     let l:val = ale#Var(a:buffer, 'open_list')
   34              0.000188     let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
   34              0.000102     return l:val is 1 || (l:val is# 'on_save' && l:saved)

FUNCTION  ale#history#SetExitCode()
Called 17 times
Total time:   0.001314
 Self time:   0.000454

count  total (s)   self (s)
   17   0.001045   0.000185     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
                                " If we find a match, then set the code and status.
   17              0.000053     let l:obj.exit_code = a:exit_code
   17              0.000037     let l:obj.status = 'finished'

FUNCTION  <SNR>172_OnFileReadyToParse()
Called 31 times
Total time:   0.391994
 Self time:   0.360939

count  total (s)   self (s)
                              " Accepts an optional parameter that is either 0 or 1. If 1, send a
                              " FileReadyToParse event notification, whether the buffer has changed or not;
                              " effectively forcing a parse of the buffer. Default is 0.
   31              0.000233   let force_parsing = a:0 > 0 && a:1
                            
                              " We only want to send a new FileReadyToParse event notification if the buffer
                              " has changed since the last time we sent one, or if forced.
   31   0.031469   0.000415   if force_parsing || s:Pyeval( "ycm_state.NeedsReparse()" )
   29              0.358414     exec s:python_command "ycm_state.OnFileReadyToParse()"
                            
   29              0.000505     call timer_stop( s:pollers.file_parse_response.id )
   29              0.000887     let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
   29              0.000068   endif

FUNCTION  <lambda>57()
Called 1 time
Total time:   0.011463
 Self time:   0.000044

count  total (s)   self (s)
    1   0.011461   0.000042 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  FugitiveIsGitDir()
Called 25 times
Total time:   0.003030
 Self time:   0.003030

count  total (s)   self (s)
   25              0.002060   let path = substitute(a:path, '[\/]$', '', '') . '/'
   25              0.000935   return len(a:path) && getfsize(path.'HEAD') > 10 && ( isdirectory(path.'objects') && isdirectory(path.'refs') || getftype(path.'commondir') ==# 'file')

FUNCTION  <SNR>172_SetCompleteFunc()
Called 14 times
Total time:   0.000189
 Self time:   0.000189

count  total (s)   self (s)
   14              0.000162   let &completefunc = 'youcompleteme#CompleteFunc'

FUNCTION  vista#cursor#FindNearestMethodOrFunction()
Called 488 times
Total time:   0.036521
 Self time:   0.023013

count  total (s)   self (s)
  488              0.008799   if !exists('t:vista') || !has_key(t:vista, 'functions') || bufnr('') != t:vista.source.bufnr
  185              0.000326     return
                              endif
                            
  303   0.018362   0.004855   call s:StopFindTimer()
                            
  303              0.001421   if empty(t:vista.functions)
  303              0.004410     call setbufvar(t:vista.source.bufnr, 'vista_nearest_method_or_function', '')
  303              0.000441     return
                              endif
                            
                              let s:find_timer = timer_start( s:find_delay, function('s:FindNearestMethodOrFunction'), )

FUNCTION  <SNR>177_StopFindTimer()
Called 303 times
Total time:   0.013508
 Self time:   0.004417

count  total (s)   self (s)
  303   0.012990   0.003899   call s:GenericStopTimer('s:find_timer')

FUNCTION  <SNR>139_resolve()
Called 36 times
Total time:   0.000296
 Self time:   0.000296

count  total (s)   self (s)
   36              0.000231   return g:neomru#follow_links ? resolve(a:fpath) : a:fpath

FUNCTION  ale#util#Writefile()
Called 23 times
Total time:   0.009734
 Self time:   0.009734

count  total (s)   self (s)
   23              0.000763     let l:corrected_lines = getbufvar(a:buffer, '&fileformat') is# 'dos'   ? map(copy(a:lines), 'substitute(v:val, ''\r*$'', ''\r'', '''')')   : a:lines
                            
   23              0.008897     call writefile(l:corrected_lines, a:filename, 'S') " no-custom-checks

FUNCTION  deoplete#custom#_get_source_vars()
Called 3 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    3              0.000021   return get(s:cached.source_vars, a:name, {})

FUNCTION  neosnippet#handlers#_cursor_moved()
Called 565 times
Total time:   0.031840
 Self time:   0.020038

count  total (s)   self (s)
  565   0.023502   0.011700   let expand_stack = neosnippet#variables#expand_stack()
                            
                              " Get patterns and count.
  565              0.004571   if !&l:modifiable || !&l:modified || empty(expand_stack)
  565              0.000775     return
                              endif
                            
                              let expand_info = expand_stack[-1]
                              if expand_info.begin_line == expand_info.end_line && line('.') != expand_info.begin_line
                                call neosnippet#view#_clear_markers(expand_info)
                              endif

FUNCTION  denite#initialize()
Called 1 time
Total time:   0.000124
 Self time:   0.000038

count  total (s)   self (s)
    1   0.000123   0.000037   return denite#init#_initialize()

FUNCTION  <SNR>151_shorten_left()
Called 48 times
Total time:   0.002278
 Self time:   0.001616

count  total (s)   self (s)
   48              0.000328   if a:oldlen + g:lightline_buffer_expand_left_icon_len <= a:newlen
                                return a:str
                              endif
                            
   48              0.000097   if a:my_minwid < 0 || a:left_minwid < 0
   24   0.000336   0.000239     return g:lightline_buffer_expand_left_icon . s:mb_str_part(a:str, a:oldlen - a:newlen + g:lightline_buffer_expand_left_icon_len, a:newlen - g:lightline_buffer_expand_left_icon_len)
                              endif
                            
   24   0.001109   0.000543   return s:clickable_text(g:lightline_buffer_expand_left_icon, a:left_minwid) . s:clickable_text(s:mb_str_part(a:str, a:oldlen - a:newlen + g:lightline_buffer_expand_left_icon_len, a:newlen - g:lightline_buffer_expand_left_icon_len), a:my_minwid)

FUNCTION  denite#_call_map()
Called 1 time
Total time:   0.389109
 Self time:   0.000160

count  total (s)   self (s)
    1              0.000007   let is_filter = &l:filetype ==# 'denite-filter'
                            
    1              0.000002   if is_filter
                                call denite#filter#_move_to_parent(v:true)
                              endif
                            
    1              0.000001   if &l:filetype !=# 'denite'
                                return
                              endif
                            
    1   0.000014   0.000008   let args = denite#util#convert2list(a:args)
                            
    1   0.388967   0.000023   call denite#util#rpcrequest( (a:is_async ? '_denite_do_async_map' : '_denite_do_map'), [bufnr('%'), a:name, args], a:is_async)
                            
    1              0.000026   if is_filter
                                let denite_statusline = get(b:, 'denite_statusline', {})
                            
                                noautocmd call win_gotoid(g:denite#_filter_winid)
                            
                                if &l:filetype ==# 'denite-filter'
                                  resize 1
                                  let b:denite_statusline = denite_statusline
                                else
                                  stopinsert
                                endif
                              endif

FUNCTION  denite#helper#_start_update_buffer_timer()
Called 1 time
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    1              0.000021   return timer_start(50, {-> denite#call_map('update_buffer')}, {'repeat': -1})

FUNCTION  ale#cursor#EchoCursorWarning()
Called 348 times
Total time:   0.195063
 Self time:   0.056034

count  total (s)   self (s)
  348              0.011424     let l:buffer = bufnr('')
                            
  348              0.002126     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
                                endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
  348              0.003486     if mode(1) isnot# 'n'
    4              0.000003         return
                                endif
                            
  344   0.108109   0.007978     if ale#ShouldDoNothing(l:buffer)
                                    return
                                endif
                            
  344   0.036233   0.006086     let [l:info, l:loc] = ale#util#FindItemAtCursor(l:buffer)
                            
  344              0.000695     if g:ale_echo_cursor
  344              0.001111         if !empty(l:loc)
    3   0.000107   0.000040             let l:format = ale#Var(l:buffer, 'echo_msg_format')
    3   0.002630   0.000147             let l:msg = ale#GetLocItemMessage(l:loc, l:format)
    3   0.006506   0.000304             call ale#cursor#TruncatedEcho(l:msg)
    3              0.000020             let l:info.echoed = 1
    3              0.000010         elseif get(l:info, 'echoed')
                                        " We'll only clear the echoed message when moving off errors once,
                                        " so we don't continually clear the echo line.
    1              0.000013             execute 'echo'
    1              0.000002             let l:info.echoed = 0
    1              0.000001         endif
  344              0.000362     endif
                            
  344              0.000691     if g:ale_cursor_detail
                                    if !empty(l:loc)
                                        call s:ShowCursorDetailForItem(l:loc, {'stay_here': 1})
                                    else
                                        call ale#preview#CloseIfTypeMatches('ale-preview')
                                    endif
                                endif

FUNCTION  <SNR>164_GenericAutoUpdate()
Called 13 times
Total time:   0.070492
 Self time:   0.001892

count  total (s)   self (s)
   13   0.000557   0.000245   if vista#ShouldSkip()
    1              0.000001     return
                              endif
                            
   12              0.000163   let [bufnr, winnr, fname] = [a:bufnr, winnr(), expand('%')]
                            
   12   0.001031   0.000526   call vista#source#Update(bufnr, winnr, fname, a:fpath)
                            
   12   0.068655   0.000872   call s:ApplyAutoUpdate(a:fpath)

FUNCTION  <SNR>177_GenericStopTimer()
Called 303 times
Total time:   0.009090
 Self time:   0.009090

count  total (s)   self (s)
  303              0.008678   execute 'if '.a:timer.' != -1 |'. '  call timer_stop('.a:timer.') |'. '  let 'a:timer.' = -1 |'. 'endif'

FUNCTION  <SNR>235_imap()
Called 16 times
Total time:   0.000700
 Self time:   0.000700

count  total (s)   self (s)
   16              0.000039   if a:preserve_completion
   16              0.000574     exe ':ino <buffer> <silent> <expr> ' . a:key . " pumvisible() ? '" . a:key . "' : '" . a:icmd . "'"
   16              0.000018   el
                                exe ':ino <buffer> <silent> ' . a:key . ' ' . a:icmd
                              en

FUNCTION  ale#highlight#nvim_buf_clear_namespace()
Called 30 times
Total time:   0.000400
 Self time:   0.000400

count  total (s)   self (s)
   30              0.000378     call nvim_buf_clear_namespace(a:buffer, a:ns_id, a:line_start, a:line_end)

FUNCTION  lightline#link()
Called 2313 times
Total time:   0.151255
 Self time:   0.149145

count  total (s)   self (s)
 2313              0.061838   let mode = get(s:lightline._mode_, a:0 ? a:1 : mode(), 'normal')
 2313              0.011037   if s:mode == mode
 2267              0.004929     return ''
                              endif
   46              0.000253   let s:mode = mode
   46              0.000448   if !has_key(s:highlight, mode)
    1   0.002167   0.000057     call lightline#highlight(mode)
    1              0.000001   endif
   46              0.002395   let types = map(s:uniq(sort(filter(values(s:lightline.component_type), 'v:val !=# "raw"'))), '[v:val, 1]')
  138              0.001203   for [p, l] in [['Left', len(s:lightline.active.left)], ['Right', len(s:lightline.active.right)]]
  506              0.002518     for [i, t] in map(range(0, l), '[v:val, 0]') + types
  414              0.000616       if i != l
  322              0.008128         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
  322              0.000398       endif
 2300              0.009583       for [j, s] in map(range(0, l), '[v:val, 0]') + types
 1886              0.004470         if i + 1 == j || t || s && i != l
  874              0.017164           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
  874              0.000713         endif
 1886              0.003188       endfor
  414              0.001098     endfor
   92              0.000093   endfor
   46              0.000569   exec printf('hi link LightlineMiddle_active LightlineMiddle_%s', mode)
   46              0.000084   return ''

FUNCTION  neosnippet#parser#_parse_snippets()
Called 1 time
Total time:   0.024915
 Self time:   0.000556

count  total (s)   self (s)
    1              0.000073   if !filereadable(a:filename)
                                call neosnippet#util#print_error( printf('snippet file "%s" is not found.', a:filename))
                                return {}
                              endif
                            
    1   0.000054   0.000042   if neosnippet#util#is_sudo()
                                return s:parse(a:filename)[0]
                              endif
                            
    1   0.000067   0.000006   let cache_dir = neosnippet#variables#data_dir()
    1              0.000002   let snippets = {}
    1   0.000326   0.000115   if !s:Cache.check_old_cache(cache_dir, a:filename)
                                try
                                  let snippets = neosnippet#helpers#json2vim( s:Cache.readfile(cache_dir, a:filename)[0])
                                catch
                                endtry
                              endif
    1              0.000003   if empty(snippets) || s:Cache.check_old_cache(cache_dir, a:filename)
    1   0.022890   0.000043     let [snippets, sourced] = s:parse(a:filename)
    1              0.000022     if len(snippets) > 5 && !sourced
    1   0.001432   0.000203       call s:Cache.writefile( cache_dir, a:filename, [neosnippet#helpers#vim2json(snippets)])
    1              0.000007     endif
    1              0.000002   endif
                            
    1              0.000006   return snippets

FUNCTION  ale#linter#Define()
Called 10 times
Total time:   0.009088
 Self time:   0.000790

count  total (s)   self (s)
                                " This command will throw from the sandbox.
   10              0.000114     let &l:equalprg=&l:equalprg
                            
   10   0.008504   0.000206     let l:new_linter = ale#linter#PreProcess(a:filetype, a:linter)
                            
   10              0.000038     if !has_key(s:linters, a:filetype)
    1              0.000004         let s:linters[a:filetype] = []
    1              0.000001     endif
                            
                                " Remove previously defined linters with the same name.
   10              0.000119     call filter(s:linters[a:filetype], 'v:val.name isnot# a:linter.name')
   10              0.000223     call add(s:linters[a:filetype], l:new_linter)

FUNCTION  deoplete#custom#_get_option()
Called 356 times
Total time:   0.001894
 Self time:   0.001894

count  total (s)   self (s)
  356              0.001576   return s:cached.option[a:name]

FUNCTION  <SNR>261_roots()
Called 3 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
    3              0.000051   return reverse(sort(keys(get(b:, 'projectionist', {})), function('projectionist#lencmp')))

FUNCTION  <SNR>197_redir()
Called 1 time
Total time:   0.033975
 Self time:   0.033975

count  total (s)   self (s)
    1              0.000007   if exists('*execute')
    1              0.033967     return execute(a:command)
                              endif
                            
                              redir => r
                              execute 'silent!' a:command
                              redir END
                            
                              return r

FUNCTION  <SNR>137_cpath()
Called 7 times
Total time:   0.000569
 Self time:   0.000295

count  total (s)   self (s)
    7              0.000052   if exists('+fileignorecase') && &fileignorecase
                                let path = FugitiveVimPath(tolower(a:path))
                              else
    7   0.000414   0.000141     let path = FugitiveVimPath(a:path)
    7              0.000006   endif
    7              0.000031   return a:0 ? path ==# s:cpath(a:1) : path

FUNCTION  <SNR>145_RemoveProblemsForDisabledLinters()
Called 23 times
Total time:   0.005633
 Self time:   0.005633

count  total (s)   self (s)
                                " Figure out which linters are still enabled, and remove
                                " problems for linters which are no longer enabled.
                                " Problems from other sources will be kept.
   23              0.000129     let l:name_map = {}
                            
   46              0.000119     for l:linter in a:linters
   23              0.000122         let l:name_map[l:linter.name] = 1
   23              0.000029     endfor
                            
   23              0.004925     call filter(   get(g:ale_buffer_info[a:buffer], 'loclist', []),   'get(v:val, ''from_other_source'') || get(l:name_map, get(v:val, ''linter_name''))',)

FUNCTION  ale#GetLocItemMessage()
Called 611 times
Total time:   0.059107
 Self time:   0.059107

count  total (s)   self (s)
  611              0.001148     let l:msg = a:format_string
  611              0.001100     let l:severity = g:ale_echo_msg_warning_str
  611              0.001630     let l:code = get(a:item, 'code', '')
  611              0.001513     let l:type = get(a:item, 'type', 'E')
  611              0.001688     let l:linter_name = get(a:item, 'linter_name', '')
  611              0.001707     let l:code_repl = !empty(l:code) ? '\=submatch(1) . l:code . submatch(2)' : ''
                            
  611              0.000891     if l:type is# 'E'
                                    let l:severity = g:ale_echo_msg_error_str
                                elseif l:type is# 'I'
                                    let l:severity = g:ale_echo_msg_info_str
                                endif
                            
                                " Replace special markers with certain information.
                                " \=l:variable is used to avoid escaping issues.
  611              0.004043     let l:msg = substitute(l:msg, '\V%severity%', '\=l:severity', 'g')
  611              0.003205     let l:msg = substitute(l:msg, '\V%linter%', '\=l:linter_name', 'g')
  611              0.028469     let l:msg = substitute(l:msg, '\v\%([^\%]*)code([^\%]*)\%', l:code_repl, 'g')
                                " Replace %s with the text.
  611              0.006344     let l:msg = substitute(l:msg, '\V%s', '\=a:item.text', 'g')
                            
  611              0.000869     return l:msg

FUNCTION  <SNR>182_external_sign_present()
Called 39 times
Total time:   0.001483
 Self time:   0.001483

count  total (s)   self (s)
   39              0.000178   if has_key(a:sy.external, a:line)
                                if has_key(a:sy.internal, a:line)
                                  " Remove Sy signs from lines with other signs.
                                  execute 'sign unplace' a:sy.internal[a:line].id 'buffer='.a:sy.buffer
                                endif
                                return 1
                              endif

FUNCTION  <SNR>172_SetUpCompleteopt()
Called 14 times
Total time:   0.000458
 Self time:   0.000458

count  total (s)   self (s)
                              " Some plugins (I'm looking at you, vim-notes) change completeopt by for
                              " instance adding 'longest'. This breaks YCM. So we force our settings.
                              " There's no two ways about this: if you want to use YCM then you have to
                              " have these completeopt settings, otherwise YCM won't work at all.
                            
                              " We need menuone in completeopt, otherwise when there's only one candidate
                              " for completion, the menu doesn't show up.
   14              0.000194   set completeopt-=menu
   14              0.000061   set completeopt+=menuone
                            
                              " This is unnecessary with our features. People use this option to insert
                              " the common prefix of all the matches and then add more differentiating chars
                              " so that they can select a more specific match. With our features, they
                              " don't need to insert the prefix; they just type the differentiating chars.
                              " Also, having this option set breaks the plugin.
   14              0.000043   set completeopt-=longest
                            
   14              0.000029   if g:ycm_add_preview_to_completeopt
                                set completeopt+=preview
                              endif

FUNCTION  <SNR>161_ApplyRunAsync()
Called 9 times
Total time:   0.028280
 Self time:   0.028280

count  total (s)   self (s)
                                  " job is job id in neovim
    9              0.028026       let jobid = jobstart(a:cmd, { 'stdout_buffered': 1, 'stderr_buffered': 1, 'on_exit': function('s:on_exit') })
    9              0.000123     return jobid > 0 ? jobid : 0

FUNCTION  13()
Called 32 times
Total time:   0.001382
 Self time:   0.000665

count  total (s)   self (s)
   32              0.000171   let is_force = get(a:000, 0, 0)
                            
                              " everything is loaded, done!
   32   0.001075   0.000359   if !is_force && self.is_loaded && !self.has_external_update()
   32              0.000054     return
                              endif
                            
                              let mru_file = self.mru_file
                            
                              if !filereadable(mru_file)
                                return
                              endif
                            
                              let file = readfile(mru_file)
                              if empty(file)
                                return
                              endif
                            
                              let [ver; items] = file
                              if !self.version_check(ver)
                                return
                              endif
                            
                              if self.type ==# 'file'
                              endif
                            
                              " Assume properly saved and sorted. unique sort is not necessary here
                              call extend(self.candidates, items)
                            
                              if self.is_loaded
                                let self.candidates = s:uniq(self.candidates)
                              endif
                            
                              let self.mtime = getftime(mru_file)
                              let self.is_loaded = 1

FUNCTION  ale#events#QuitEvent()
Called 2 times
Total time:   0.000227
 Self time:   0.000176

count  total (s)   self (s)
                                " Remember when ALE is quitting for BufWrite, etc.
    2   0.000216   0.000165     call setbufvar(a:buffer, 'ale_quitting', ale#events#ClockMilliseconds())

FUNCTION  <SNR>161_DeleteTemp()
Called 10 times
Total time:   0.001535
 Self time:   0.001535

count  total (s)   self (s)
   10              0.000061   if exists('s:tmp_file')
    6              0.001372     call delete(s:tmp_file)
    6              0.000036     unlet s:tmp_file
    6              0.000007   endif

FUNCTION  ale#util#JoinNeovimOutput()
Called 33 times
Total time:   0.012785
 Self time:   0.010150

count  total (s)   self (s)
   33              0.000152     if a:mode is# 'raw'
                                    call a:callback(a:job, join(a:data, "\n"))
                            
                                    return ''
                                endif
                            
   33              0.000574     let l:lines = a:data[:-2]
                            
   33              0.000109     if len(a:data) > 1
   10              0.000058         let l:lines[0] = a:last_line . l:lines[0]
   10              0.000028         let l:new_last_line = a:data[-1]
   10              0.000009     else
   23              0.000142         let l:new_last_line = a:last_line . get(a:data, 0, '')
   23              0.000018     endif
                            
  642              0.001593     for l:line in l:lines
  609   0.008015   0.005380         call a:callback(a:job, l:line)
  609              0.001003     endfor
                            
   33              0.000062     return l:new_last_line

FUNCTION  ale#sign#SetSigns()
Called 17 times
Total time:   0.119366
 Self time:   0.004684

count  total (s)   self (s)
   17              0.000081     if !bufexists(str2nr(a:buffer))
                                    " Stop immediately when attempting to set signs for a buffer which
                                    " does not exist.
                                    return
                                endif
                            
                                " Find the current markers
   17   0.065661   0.002306     let [l:is_dummy_sign_set, l:current_sign_list] =   ale#sign#FindCurrentSigns(a:buffer)
                            
                                " Update the line numbers for items from before which may have moved.
   17   0.008317   0.000758     call s:UpdateLineNumbers(a:buffer, l:current_sign_list, a:loclist)
                            
                                " Group items after updating the line numbers.
   17   0.007130   0.000285     let l:grouped_items = s:GroupLoclistItems(a:buffer, a:loclist)
                            
                                " Build a map of current and new signs, with the lines as the keys.
   17   0.027961   0.000298     let l:sign_map = s:BuildSignMap(   a:buffer,   l:current_sign_list,   l:grouped_items,)
                            
   17   0.009471   0.000210     let l:command_list = ale#sign#GetSignCommands(   a:buffer,   l:is_dummy_sign_set,   l:sign_map,)
                            
                                " Change the sign column color if the option is on.
   17              0.000052     if g:ale_change_sign_column_color && !empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithErrors
                                endif
                            
   33              0.000060     for l:command in l:command_list
   16              0.000124         silent! execute l:command
   16              0.000013     endfor
                            
                                " Reset the sign column color when there are no more errors.
   17              0.000043     if g:ale_change_sign_column_color && empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithoutErrors
                                endif

FUNCTION  18()
Called 7 times
Total time:   0.002137
 Self time:   0.002137

count  total (s)   self (s)
    7              0.000048   if self.do_validate
    7              0.002034     call filter(self.candidates, 'getftype(v:val) ==# "dir"')
    7              0.000020   endif

FUNCTION  <SNR>158_handle_diff()
Called 12 times
Total time:   0.235787
 Self time:   0.012404

count  total (s)   self (s)
   12   0.000554   0.000203   call sy#verbose('s:handle_diff()', a:options.vcs)
                            
   12              0.000061   if has_key(a:options, 'tempfiles')
   12              0.000048     for f in a:options.tempfiles
    8              0.004966       call delete(f)
    8              0.000055     endfor
    4              0.000005   endif
                            
   12              0.000113   let sy = getbufvar(a:options.bufnr, 'sy')
   12              0.000035   if empty(sy)
                                call sy#verbose(printf('No b:sy found for %s', bufname(a:options.bufnr)), a:options.vcs)
                                return
                              elseif !empty(sy.updated_by) && sy.updated_by != a:options.vcs
                                call sy#verbose(printf('Signs already got updated by %s.', sy.updated_by), a:options.vcs)
                                return
                              elseif empty(sy.vcs) && sy.active
    3              0.000009     let sy.detecting -= 1
    3              0.000002   endif
                            
   12              0.000147   let fenc = getbufvar(a:options.bufnr, '&fenc')
   12              0.000106   let enc  = getbufvar(a:options.bufnr, '&enc')
   12              0.000718   if (fenc != enc) && has('iconv')
   12              0.000815     call map(a:options.stdoutbuf, printf('iconv(v:val, "%s", "%s")', fenc, enc))
   12              0.000021   endif
                            
   12   0.003972   0.003759   let [found_diff, diff] = s:check_diff_{a:options.difftool}(a:exitval, a:options.stdoutbuf)
   12              0.000040   if found_diff
    9              0.000053     if index(sy.vcs, a:options.vcs) == -1
    3              0.000012       let sy.vcs += [a:options.vcs]
    3              0.000002     endif
    9   0.222893   0.000188     call a:options.func(sy, a:options.vcs, diff)
    9              0.000011   else
    3   0.000214   0.000100     call sy#verbose('No valid diff found. Disabling this VCS.', a:options.vcs)
    3              0.000005   endif
                            
   12              0.000144   call setbufvar(a:options.bufnr, 'sy_job_id_'.a:options.vcs, 0)

FUNCTION  xray#highlight#SaveOriginalHighlights()
Called 1 time
Total time:   0.000474
 Self time:   0.000067

count  total (s)   self (s)
    1              0.000016   if !exists('g:xray_original_special_key_details')
    1   0.000253   0.000023     let g:xray_original_special_key_details = xray#highlight#GetHighlightGroupDetails('SpecialKey')
    1              0.000003   endif
                            
    1              0.000006   if !exists('g:xray_original_non_text_details')
    1   0.000191   0.000014     let g:xray_original_non_text_details = xray#highlight#GetHighlightGroupDetails('NonText')
    1              0.000002   endif

FUNCTION  ale#engine#InitBufferInfo()
Called 23 times
Total time:   0.000504
 Self time:   0.000504

count  total (s)   self (s)
   23              0.000119     if !has_key(g:ale_buffer_info, a:buffer)
                                    " active_linter_list will hold the list of active linter names
                                    " loclist holds the loclist items after all jobs have completed.
    2              0.000012         let g:ale_buffer_info[a:buffer] = {   'active_linter_list': [],   'active_other_sources_list': [],   'loclist': [],}
                            
    2              0.000002         return 1
                                endif
                            
   21              0.000027     return 0

FUNCTION  <SNR>187_GroupLoclistItems()
Called 17 times
Total time:   0.006845
 Self time:   0.006845

count  total (s)   self (s)
   17              0.000047     let l:grouped_items = []
   17              0.000033     let l:last_lnum = -1
                            
  625              0.000591     for l:obj in a:loclist
  608              0.000625         if l:obj.bufnr != a:buffer
                                        continue
                                    endif
                            
                                    " Create a new sub-List when we hit a new line.
  608              0.000593         if l:obj.lnum != l:last_lnum
  185              0.000379             call add(l:grouped_items, [])
  185              0.000095         endif
                            
  608              0.001067         call add(l:grouped_items[-1], l:obj)
  608              0.000632         let l:last_lnum = l:obj.lnum
  608              0.000642     endfor
                            
   17              0.000028     return l:grouped_items

FUNCTION  <SNR>197_get_context_filetypes()
Called 11 times
Total time:   0.000294
 Self time:   0.000294

count  total (s)   self (s)
   11              0.000062   if !exists('s:exists_context_filetype')
                                try
                                  call context_filetype#version()
                                  let s:exists_context_filetype = 1
                                catch
                                  let s:exists_context_filetype = 0
                                endtry
                              endif
                            
   11              0.000072   return s:exists_context_filetype && exists('*context_filetype#get_filetypes') ? context_filetype#get_filetypes(a:filetype) : [a:filetype]

FUNCTION  xray#highlight#CanSetHighlight()
Called 5735 times
Total time:   0.060843
 Self time:   0.060843

count  total (s)   self (s)
 5735              0.036862   if exists('g:xray_can_set_highlight')
 5735              0.012523     return g:xray_can_set_highlight
                              endif
                            
                              let g:xray_can_set_highlight = v:false
                              let l:normal_backgrounds = xray#highlight#GetBackgroundsForHighlightGroup('Normal')
                            
                              if xray#highlight#IsGuiOrTrueColorTerm() && l:normal_backgrounds.guibg != ''
                                let g:xray_can_set_highlight = v:true
                              elseif xray#highlight#IsSupportedColorTerm() && l:normal_backgrounds.ctermbg != ''
                                let g:xray_can_set_highlight = v:true
                              endif
                            
                              return g:xray_can_set_highlight

FUNCTION  deoplete#handler#_skip_next_completion()
Called 9 times
Total time:   0.008275
 Self time:   0.006309

count  total (s)   self (s)
    9              0.000058   if !exists('g:deoplete#_context')
                                return
                              endif
                            
    9   0.001852   0.000127   let input = deoplete#util#get_input('CompleteDone')
    9              0.005717   if input !~# '[/.]$'
    9              0.000132     let g:deoplete#_context.input = input
    9              0.000011   endif
    9   0.000210   0.000102   call deoplete#mapping#_restore_completeopt()
    9   0.000232   0.000099   call deoplete#init#_prev_completion()

FUNCTION  neosnippet#helpers#get_completion_snippets()
Called 11 times
Total time:   0.019916
 Self time:   0.001628

count  total (s)   self (s)
   11   0.019858   0.001570   return filter(neosnippet#helpers#get_snippets(), "!get(v:val.options, 'oneshot', 0)")

FUNCTION  <SNR>113_dopopd()
Called 3 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    3              0.000017   if !exists('w:fzf_pushd')
    3              0.000005     return
                              endif
                            
                              " FIXME: We temporarily change the working directory to 'dir' entry
                              " of options dictionary (set to the current working directory if not given)
                              " before running fzf.
                              "
                              " e.g. call fzf#run({'dir': '/tmp', 'source': 'ls', 'sink': 'e'})
                              "
                              " After processing the sink function, we have to restore the current working
                              " directory. But doing so may not be desirable if the function changed the
                              " working directory on purpose.
                              "
                              " So how can we tell if we should do it or not? A simple heuristic we use
                              " here is that we change directory only if the current working directory
                              " matches 'dir' entry. However, it is possible that the sink function did
                              " change the directory to 'dir'. In that case, the user will have an
                              " unexpected result.
                              if s:fzf_getcwd() ==# w:fzf_pushd.dir && (!&autochdir || w:fzf_pushd.bufname ==# bufname(''))
                                execute w:fzf_pushd.command s:escape(w:fzf_pushd.origin)
                              endif
                              unlet w:fzf_pushd

FUNCTION  <SNR>150_flatten_twice()
Called 56 times
Total time:   0.004135
 Self time:   0.004135

count  total (s)   self (s)
   56              0.000125   let ys = []
  176              0.000315   for xs in a:xss
  323              0.000355     for x in xs
  203              0.000312       let ys += x
  203              0.001221     endfor
  120              0.001172   endfor
   56              0.000076   return ys

FUNCTION  neosnippet#util#is_sudo()
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000012   return $SUDO_USER !=# '' && $USER !=# $SUDO_USER && $HOME !=# expand('~'.$USER) && $HOME ==# expand('~'.$SUDO_USER)

FUNCTION  xray#highlight#AreXrayHighlightsConfigured()
Called 2 times
Total time:   0.003875
 Self time:   0.000329

count  total (s)   self (s)
    2   0.002471   0.000169   let l:original_special_key_details = get(   g:,   'xray_original_special_key_details',   xray#highlight#GetHighlightGroupDetails('SpecialKey') )
    2   0.000495   0.000041   let l:current_special_key_details = xray#highlight#GetHighlightGroupDetails('SpecialKey')
    2              0.000014   if l:original_special_key_details != l:current_special_key_details
    1              0.000003     return v:true
                              endif
                            
    1   0.000203   0.000039   let l:original_non_text_details = get(   g:,   'xray_original_non_text_details',   xray#highlight#GetHighlightGroupDetails('NonText') )
    1   0.000643   0.000017   let l:current_non_text_details = xray#highlight#GetHighlightGroupDetails('NonText')
    1              0.000007   if l:original_non_text_details != l:current_non_text_details
                                return v:true
                              endif
                            
    1              0.000002   return v:false

FUNCTION  <SNR>164_OnBufEnter()
Called 8 times
Total time:   0.041492
 Self time:   0.000364

count  total (s)   self (s)
    8              0.000071   if !exists('t:vista')
                                return
                              endif
                            
    8   0.041369   0.000241   call s:GenericAutoUpdate(a:bufnr, a:fpath)

FUNCTION  <SNR>4_dirpath()
Called 71 times
Total time:   0.005782
 Self time:   0.005782

count  total (s)   self (s)
   71              0.005754     return substitute(a:path, '[/\\]*$', '/', '')

FUNCTION  GetVimIndentIntern()
Called 52 times
Total time:   0.026891
 Self time:   0.026891

count  total (s)   self (s)
                              " Find a non-blank line above the current line.
   52              0.000230   let lnum = prevnonblank(v:lnum - 1)
                            
                              " If the current line doesn't start with '\' or '"\ ' and below a line that
                              " starts with '\' or '"\ ', use the indent of the line above it.
   52              0.000171   let cur_text = getline(v:lnum)
   52              0.001417   if cur_text !~ s:lineContPat
   51              0.001558     while lnum > 0 && getline(lnum) =~ s:lineContPat
   24              0.000095       let lnum = lnum - 1
   24              0.000088     endwhile
   27              0.000018   endif
                            
                              " At the start of the file use zero indent.
   52              0.000071   if lnum == 0
                                return 0
                              endif
   52              0.000168   let prev_text = getline(lnum)
                            
                              " Add a 'shiftwidth' after :if, :while, :try, :catch, :finally, :function
                              " and :else.  Add it three times for a line that starts with '\' or '"\ '
                              " after a line that doesn't (or g:vim_indent_cont if it exists).
   52              0.000126   let ind = indent(lnum)
   52              0.002490   if cur_text =~ s:lineContPat && v:lnum > 1 && prev_text !~ s:lineContPat
    2              0.000019     if exists("g:vim_indent_cont")
                                  let ind = ind + g:vim_indent_cont
                                else
    2              0.000013       let ind = ind + shiftwidth() * 3
    2              0.000003     endif
    2              0.000007   elseif prev_text =~ '^\s*aug\%[roup]\s\+' && prev_text !~ '^\s*aug\%[roup]\s\+[eE][nN][dD]\>'
                                let ind = ind + shiftwidth()
                              else
                                " A line starting with :au does not increment/decrement indent.
   50              0.000850     if prev_text !~ '^\s*au\%[tocmd]'
   50              0.005025       let i = match(prev_text, '\(^\||\)\s*\(if\|wh\%[ile]\|for\|try\|cat\%[ch]\|fina\%[lly]\|fu\%[nction]\|el\%[seif]\)\>')
   50              0.000110       if i >= 0
                            	let ind += shiftwidth()
                            	if strpart(prev_text, i, 1) == '|' && has('syntax_items') && synIDattr(synID(lnum, i, 1), "name") =~ '\(Comment\|String\)$'
                            	  let ind -= shiftwidth()
                            	endif
                                  endif
   50              0.000024     endif
   50              0.000021   endif
                            
                              " If the previous line contains an "end" after a pipe, but not in an ":au"
                              " command.  And not when there is a backslash before the pipe.
                              " And when syntax HL is enabled avoid a match inside a string.
   52              0.004761   let i = match(prev_text, '[^\\]|\s*\(ene\@!\)')
   52              0.000144   if i > 0 && prev_text !~ '^\s*au\%[tocmd]'
                                if !has('syntax_items') || synIDattr(synID(lnum, i + 2, 1), "name") !~ '\(Comment\|String\)$'
                                  let ind = ind - shiftwidth()
                                endif
                              endif
                            
                            
                              " Subtract a 'shiftwidth' on a :endif, :endwhile, :catch, :finally, :endtry,
                              " :endfun, :else and :augroup END.
   52              0.002282   if cur_text =~ '^\s*\(ene\@!\|cat\|fina\|el\|aug\%[roup]\s\+[eE][nN][dD]\)'
                                let ind = ind - shiftwidth()
                              endif
                            
   52              0.000091   return ind

FUNCTION  ale#handlers#alex#CreateCommandCallback()
Called 1 time
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000011     return {b -> ale#node#Executable(b, ale#handlers#alex#GetExecutable(b))            . ' %s '            . a:flags}

FUNCTION  neosnippet#helpers#get_snippets()
Called 11 times
Total time:   0.018288
 Self time:   0.010935

count  total (s)   self (s)
   11              0.000104   let mode = get(a:000, 0, mode())
                            
   11   0.000301   0.000147   call neosnippet#init#check()
                            
   11   0.000325   0.000147   let neosnippet = neosnippet#variables#current_neosnippet()
   11              0.000048   let snippets = copy(neosnippet.snippets)
   33   0.003003   0.000392   for filetype in s:get_sources_filetypes(neosnippet#helpers#get_filetype())
   22   0.001606   0.000266     call neosnippet#commands#_make_cache(filetype)
   22   0.001742   0.001584     call extend(snippets, neosnippet#variables#snippets()[filetype])
   22              0.000041   endfor
                            
   11   0.001904   0.000420   let cur_text = neosnippet#util#get_cur_text()
                            
   11              0.000060   if mode ==# 'i' || mode ==# 's'
                                " Special filters.
    8   0.001591   0.000163     if !s:is_beginning_of_line(cur_text)
    6              0.000965       call filter(snippets, '!v:val.options.head')
    6              0.000013     endif
    8              0.000004   endif
                            
   11              0.006114   call filter(snippets, "cur_text =~# get(v:val, 'regexp', '')")
                            
   11              0.000063   if exists('b:neosnippet_disable_snippet_triggers')
                                call filter(snippets, 'index(b:neosnippet_disable_snippet_triggers, v:val.word) < 0')
                              endif
                            
   11              0.000024   return snippets

FUNCTION  neosnippet#mappings#_clear_select_mode_mappings()
Called 8 times
Total time:   0.030542
 Self time:   0.030542

count  total (s)   self (s)
    8              0.000056   if !g:neosnippet#disable_select_mode_mappings || !exists('*execute')
                                return
                              endif
                            
    8              0.018384   let mappings = execute('smap', 'silent!')
                            
   36              0.009862   for map in map(filter(split(mappings, '\n'), "v:val !~# '^s' && v:val !~# '^\\a*\\s*<\\S\\+>'"), "matchstr(v:val, '^\\a*\\s*\\zs\\S\\+')")
   28              0.000843     silent! execute 'sunmap' map
   28              0.000496     silent! execute 'sunmap <buffer>' map
   28              0.000027   endfor
                            
                              " Define default select mode mappings.
    8              0.000290   snoremap <CR>     a<BS>
    8              0.000162   snoremap <BS>     a<BS>
    8              0.000148   snoremap <Del>    a<BS>
    8              0.000121   snoremap <C-h>    a<BS>

FUNCTION  <SNR>142_IsCallback()
Called 10 times
Total time:   0.000080
 Self time:   0.000080

count  total (s)   self (s)
   10              0.000070     return type(a:value) is v:t_string || type(a:value) is v:t_func

FUNCTION  Foldexpr_markdown()
Called 226 times
Total time:   0.334184
 Self time:   0.023887

count  total (s)   self (s)
  226              0.001440         if (a:lnum == 1)
    2              0.000004             let l0 = ''
    2              0.000002         else
  224              0.000824             let l0 = getline(a:lnum-1)
  224              0.000142         endif
                            
                                    " keep track of fenced code blocks
  226              0.001444         if l0 =~ '````*' || l0 =~ '\~\~\~\~*'
                                        if b:fenced_block == 0
                                            let b:fenced_block = 1
                                        elseif b:fenced_block == 1
                                            let b:fenced_block = 0
                                        endif
                                    elseif g:vim_markdown_frontmatter == 1
                                        if b:front_matter == 1
                                            if l0 == '---'
                                                let b:front_matter = 0
                                            endif
                                        elseif a:lnum == 2
                                            if l0 == '---'
                                                let b:front_matter = 1
                                            endif
                                        endif
                                    endif
                            
  226              0.000467         if b:fenced_block == 1 || b:front_matter == 1
                                        " keep previous foldlevel
                                        return '='
                                    endif
                            
  226              0.000627         let l2 = getline(a:lnum+1)
  226              0.001332         if  l2 =~ '^==\+\s*' && !s:is_mkdCode(a:lnum+1)
                                        " next line is underlined (level 1)
                                        return '>1'
                                    elseif l2 =~ '^--\+\s*' && !s:is_mkdCode(a:lnum+1)
                                        " next line is underlined (level 2)
                                        if s:vim_markdown_folding_level >= 2
                                            return '>1'
                                        else
                                            return '>2'
                                        endif
                                    endif
                            
  226              0.000502         let l1 = getline(a:lnum)
  226   0.256255   0.001884         if l1 =~ '^#' && !s:is_mkdCode(a:lnum)
                                        " fold level according to option
   58              0.000334             if s:vim_markdown_folding_level == 1 || matchend(l1, '^#\+') > s:vim_markdown_folding_level
   58              0.000493                 if a:lnum == line('$')
                                                return matchend(l1, '^#\+') - 1
                                            else
   58              0.000064                     return -1
                                            endif
                                        else
                                            " headers are not folded
                                            return 0
                                        endif
                                    endif
                            
  168   0.057499   0.001572         if l0 =~ '^#' && !s:is_mkdCode(a:lnum-1)
                                        " previous line starts with hashes
   58              0.001106             return '>'.matchend(l0, '^#\+')
                                    else
                                        " keep previous foldlevel
  110              0.000096             return '='
                                    endif

FUNCTION  neosnippet#variables#data_dir()
Called 2 times
Total time:   0.000136
 Self time:   0.000136

count  total (s)   self (s)
    2              0.000103   let g:neosnippet#data_directory = substitute(fnamemodify(get(   g:, 'neosnippet#data_directory',  ($XDG_CACHE_HOME !=# '' ?   $XDG_CACHE_HOME . '/neosnippet' : expand('~/.cache/neosnippet'))),  ':p'), '\\', '/', 'g')
    2              0.000020   if !isdirectory(g:neosnippet#data_directory)
                                call mkdir(g:neosnippet#data_directory, 'p')
                              endif
                            
    2              0.000003   return g:neosnippet#data_directory

FUNCTION  FugitiveVimPath()
Called 7 times
Total time:   0.000273
 Self time:   0.000273

count  total (s)   self (s)
    7              0.000037   if exists('+shellslash') && !&shellslash
                                return tr(a:path, '/', '\')
                              else
    7              0.000015     return a:path
                              endif

FUNCTION  ale#engine#IsCheckingBuffer()
Called 57 times
Total time:   0.001136
 Self time:   0.001136

count  total (s)   self (s)
   57              0.000408     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
   57              0.000551     return !empty(get(l:info, 'active_linter_list', []))   || !empty(get(l:info, 'active_other_sources_list', []))

FUNCTION  <SNR>137_TempReadPre()
Called 2 times
Total time:   0.000298
 Self time:   0.000124

count  total (s)   self (s)
    2   0.000257   0.000083   if has_key(s:temp_files, s:cpath(a:file))
                                let dict = s:temp_files[s:cpath(a:file)]
                                setlocal nomodeline
                                setlocal bufhidden=delete nobuflisted
                                setlocal buftype=nowrite
                                if has_key(dict, 'modifiable')
                                  let &l:modifiable = dict.modifiable
                                endif
                                if len(dict.dir)
                                  let b:git_dir = dict.dir
                                  call extend(b:, {'fugitive_type': 'temp'}, 'keep')
                                endif
                              endif

FUNCTION  <SNR>172_StartMessagePoll()
Called 14 times
Total time:   0.000234
 Self time:   0.000234

count  total (s)   self (s)
   14              0.000064   if s:pollers.receive_messages.id < 0
    7              0.000114     let s:pollers.receive_messages.id = timer_start( s:pollers.receive_messages.wait_milliseconds, function( 's:ReceiveMessages' ) )
    7              0.000006   endif

FUNCTION  ale#job#ValidateArguments()
Called 23 times
Total time:   0.000281
 Self time:   0.000281

count  total (s)   self (s)
   23              0.000122     if a:options.mode isnot# 'nl' && a:options.mode isnot# 'raw'
                                    throw 'Invalid mode: ' . a:options.mode
                                endif

FUNCTION  ale#engine#MarkLinterActive()
Called 23 times
Total time:   0.000761
 Self time:   0.000761

count  total (s)   self (s)
   23              0.000081     let l:found = 0
                            
   23              0.000144     for l:other_linter in a:info.active_linter_list
                                    if l:other_linter.name is# a:linter.name
                                        let l:found = 1
                                        break
                                    endif
                                endfor
                            
   23              0.000037     if !l:found
   23              0.000100         call add(a:info.active_linter_list, a:linter)
   23              0.000020     endif

FUNCTION  Prose()
Called 2 times
Total time:   0.471826
 Self time:   0.003636

count  total (s)   self (s)
    2   0.100198   0.000023   call pencil#init()
                              " replace common punctuation
    2              0.000024   iabbrev <buffer> -- â€“
    2              0.000008   iabbrev <buffer> --- â€”
    2              0.000006   iabbrev <buffer> << Â«
    2              0.000006   iabbrev <buffer> >> Â»
                            
                              " open most folds
    2   0.371577   0.003562   setlocal foldlevel=6

FUNCTION  ale#command#RemoveManagedFiles()
Called 17 times
Total time:   0.015780
 Self time:   0.015540

count  total (s)   self (s)
   17              0.000100     let l:info = get(s:buffer_data, a:buffer, {})
                            
   17              0.000071     if !empty(l:info) && empty(l:info.jobs)
                                    " We can't delete anything in a sandbox, so wait until we escape from
                                    " it to delete temporary files and directories.
   17   0.000417   0.000177         if ale#util#InSandbox()
                                        return
                                    endif
                            
                                    " Delete files with a call akin to a plan `rm` command.
   17              0.000057         for l:filename in l:info.file_list
                                        call delete(l:filename)
                                    endfor
                            
                                    " Delete directories like `rm -rf`.
                                    " Directories are handled differently from files, so paths that are
                                    " intended to be single files can be set up for automatic deletion
                                    " without accidentally deleting entire directories.
   40              0.000180         for l:directory in l:info.directory_list
   23              0.014142             call delete(l:directory, 'rf')
   23              0.000126         endfor
                            
   17              0.000171         call remove(s:buffer_data, a:buffer)
   17              0.000021     endif

FUNCTION  <SNR>139_uniq_by()
Called 14 times
Total time:   0.009128
 Self time:   0.009128

count  total (s)   self (s)
   14              0.001656   let list = map(copy(a:list), printf('[v:val, %s]', a:f))
   14              0.000056   let i = 0
   14              0.000068   let seen = {}
  180              0.000569   while i < len(list)
  166              0.002258     let key = string(list[i][1])
  166              0.000622     if has_key(seen, key)
                                  call remove(list, i)
                                else
  166              0.000570       let seen[key] = 1
  166              0.000252       let i += 1
  166              0.000140     endif
  166              0.001662   endwhile
   14              0.000386   return map(list, 'v:val[0]')

FUNCTION  xray#settings#GetForceRedraw()
Called 2 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    2              0.000014   return get(g:, 'xray_force_redraw', v:true)

FUNCTION  <lambda>58()
Called 1 time
Total time:   0.005159
 Self time:   0.000023

count  total (s)   self (s)
    1   0.005158   0.000022 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <SNR>4_remove_triggers()
Called 2 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    2              0.000020   if !has_key(s:triggers, a:name)
    2              0.000002     return
                              endif
                              for cmd in s:triggers[a:name].cmd
                                execute 'silent! delc' cmd
                              endfor
                              for map in s:triggers[a:name].map
                                execute 'silent! unmap' map
                                execute 'silent! iunmap' map
                              endfor
                              call remove(s:triggers, a:name)

FUNCTION  ale#command#FormatCommand()
Called 23 times
Total time:   0.028714
 Self time:   0.005342

count  total (s)   self (s)
   23              0.000070     let l:temporary_file = ''
   23              0.000055     let l:command = a:command
                            
                                " First replace all uses of %%, used for literal percent characters,
                                " with an ugly string.
   23              0.000745     let l:command = substitute(l:command, '%%', '<<PERCENTS>>', 'g')
                            
                                " Replace %e with the escaped executable, if available.
   23              0.000227     if !empty(a:executable) && l:command =~# '%e'
   23   0.001581   0.000555         let l:command = substitute(l:command, '%e', '\=ale#Escape(a:executable)', 'g')
   23              0.000026     endif
                            
                                " Replace all %s occurrences in the string with the name of the current
                                " file.
   23              0.000134     if l:command =~# '%s'
                                    let l:filename = fnamemodify(bufname(a:buffer), ':p')
                                    let l:command = substitute(l:command, '%s', '\=ale#Escape(l:filename)', 'g')
                                endif
                            
   23              0.000153     if a:input isnot v:false && l:command =~# '%t'
                                    " Create a temporary filename, <temp_dir>/<original_basename>
                                    " The file itself will not be created by this function.
   23   0.002262   0.000365         let l:temporary_file = s:TemporaryFilename(a:buffer)
   23   0.001251   0.000485         let l:command = substitute(l:command, '%t', '\=ale#Escape(l:temporary_file)', 'g')
   23              0.000020     endif
                            
                                " Finish formatting so %% becomes %.
   23              0.000261     let l:command = substitute(l:command, '<<PERCENTS>>', '%', 'g')
                            
   23              0.000090     if a:pipe_file_if_needed && empty(l:temporary_file)
                                    " If we are to send the Vim buffer to a command, we'll do it
                                    " in the shell. We'll write out the file to a temporary file,
                                    " and then read it back in, in the shell.
                                    let l:temporary_file = s:TemporaryFilename(a:buffer)
                                    let l:command = l:command . ' < ' . ale#Escape(l:temporary_file)
                                endif
                            
   23   0.020833   0.001150     let l:file_created = ale#command#CreateTempFile(   a:buffer,   l:temporary_file,   a:input,)
                            
   23              0.000151     return [l:temporary_file, l:command, l:file_created]

FUNCTION  <SNR>172_PollFileParseResponse()
Called 21 times
Total time:   0.208517
 Self time:   0.140051

count  total (s)   self (s)
   21   0.032813   0.000646   if !s:Pyeval( "ycm_state.FileParseRequestReady()" )
                                let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
                                return
                              endif
                            
   21              0.137624   exec s:python_command "ycm_state.HandleFileParseRequest()"
   21   0.037011   0.000713   if s:Pyeval( "ycm_state.ShouldResendFileParseRequest()" )
                                call s:OnFileReadyToParse( 1 )
                              endif

FUNCTION  vista#statusline#Render()
Called 10 times
Total time:   0.000291
 Self time:   0.000188

count  total (s)   self (s)
   10   0.000252   0.000149   if vista#statusline#ShouldDisable()
   10              0.000012     return
                              endif
                            
                              if has_key(t:vista, 'bufnr')
                                call setbufvar(t:vista.bufnr, '&statusline', vista#statusline#())
                              endif

FUNCTION  FugitiveGitDir()
Called 12 times
Total time:   0.000763
 Self time:   0.000725

count  total (s)   self (s)
   12              0.000078   if !a:0 || type(a:1) == type(0) && a:1 < 0
    7              0.000028     if exists('g:fugitive_event')
                                  return g:fugitive_event
                                endif
    7              0.000048     let dir = get(b:, 'git_dir', '')
    7              0.000131     if empty(dir) && (empty(bufname('')) || &buftype =~# '^\%(nofile\|acwrite\|quickfix\|prompt\)$')
                                  return FugitiveExtractGitDir(getcwd())
                                endif
    7              0.000010     return dir
                              elseif type(a:1) == type(0)
                                return getbufvar(a:1, 'git_dir')
                              elseif type(a:1) == type('')
    5   0.000259   0.000222     return substitute(s:Slash(a:1), '/$', '', '')
                              else
                                return ''
                              endif

FUNCTION  ale#command#Run()
Called 23 times
Total time:   0.136114
 Self time:   0.012017

count  total (s)   self (s)
   23              0.000146     let l:options = get(a:000, 0, {})
                            
   23              0.000072     if len(a:000) > 1
                                    throw 'Too many arguments!'
                                endif
                            
   23              0.000120     let l:output_stream = get(l:options, 'output_stream', 'stdout')
   23              0.000047     let l:line_list = []
                            
   23   0.029419   0.000705     let [l:temporary_file, l:command, l:file_created] = ale#command#FormatCommand(   a:buffer,   get(l:options, 'executable', ''),   a:command,   get(l:options, 'read_buffer', 0),   get(l:options, 'input', v:null),)
   23   0.005289   0.000648     let l:command = ale#job#PrepareCommand(a:buffer, l:command)
   23              0.000850     let l:job_options = {   'exit_cb': {job_id, exit_code -> s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )},   'mode': 'nl',}
                            
   23              0.000095     if l:output_stream is# 'stdout'
   23              0.000323         let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
   23              0.000051     elseif l:output_stream is# 'stderr'
                                    let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
                                elseif l:output_stream is# 'both'
                                    let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
                                    let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
                                endif
                            
   23              0.000052     let l:status = 'failed'
                            
   23              0.000101     if get(g:, 'ale_run_synchronously') == 1
                                    if get(g:, 'ale_emulate_job_failure') == 1
                                        let l:job_id = 0
                                    else
                                        " Generate a fake job ID for tests.
                                        let s:fake_job_id = get(s:, 'fake_job_id', 0) + 1
                                        let l:job_id = s:fake_job_id
                                    endif
                                elseif has('win32')
                                    let l:job_id = ale#job#StartWithCmd(l:command, l:job_options)
                                else
   23   0.088865   0.001303         let l:job_id = ale#job#Start(l:command, l:job_options)
   23              0.000063     endif
                            
   23              0.000047     if l:job_id
   23              0.000105         let l:status = 'started'
   23              0.000315         let l:job_type = getbufvar(a:buffer, 'ale_job_type', 'all')
                            
   23   0.002037   0.001338         call ale#command#InitData(a:buffer)
   23              0.000230         let s:buffer_data[a:buffer].jobs[l:job_id] = l:job_type
   23              0.000088     endif
                            
   23              0.000075     if g:ale_history_enabled
   23   0.002942   0.000462         call ale#history#Add(a:buffer, l:status, l:job_id, l:command)
   23              0.000025     endif
                            
   23              0.000041     if !l:job_id
                                    return 0
                                endif
                            
                                " We'll return this Dictionary. A `result_callback` can be assigned to it
                                " later for capturing the result of a:Callback.
                                "
                                " The `_deferred_job_id` is used for both checking the type of object, and
                                " for checking the job ID and status.
                                "
                                " The original command here is used in tests.
   23              0.000305     let l:result = {   '_deferred_job_id': l:job_id,   'executable': get(l:options, 'executable', ''),   'command': a:command,}
                            
   23              0.000115     if get(g:, 'ale_run_synchronously') == 1 && l:job_id
                                    if !exists('g:ale_run_synchronously_callbacks')
                                        let g:ale_run_synchronously_callbacks = []
                                    endif
                            
                                    if get(g:, 'ale_run_synchronously_emulate_commands', 0)
                                        call add(   g:ale_run_synchronously_callbacks,   {exit_code, output -> [       extend(l:line_list, output),       l:job_options.exit_cb(l:job_id, exit_code),   ]})
                                    else
                                        " Run a command synchronously if this test option is set.
                                        call extend(l:line_list, systemlist(   type(l:command) is v:t_list       ? join(l:command[0:1]) . ' ' . ale#Escape(l:command[2])       : l:command))
                            
                                        " Don't capture output when the callbacks aren't set.
                                        if !has_key(l:job_options, 'out_cb')&& !has_key(l:job_options, 'err_cb')
                                            let l:line_list = []
                                        endif
                            
                                        call add(   g:ale_run_synchronously_callbacks,   {-> l:job_options.exit_cb(l:job_id, v:shell_error)})
                                    endif
                                endif
                            
   23              0.000080     return l:result

FUNCTION  ale#events#ClockMilliseconds()
Called 3 times
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
    3              0.000075     return float2nr(reltimefloat(reltime()) * 1000)

FUNCTION  ale#events#FileTypeEvent()
Called 6 times
Total time:   0.000617
 Self time:   0.000380

count  total (s)   self (s)
                                " The old filetype will be set to an empty string by the BuFEnter event,
                                " and not linting when the old filetype hasn't been set yet prevents
                                " buffers being checked when you enter them when linting on enter is off.
    6              0.000259     let l:old_filetype = getbufvar(a:buffer, 'ale_original_filetype', v:null)
                            
    6              0.000032     if l:old_filetype isnot v:null&& !empty(a:new_filetype)&& a:new_filetype isnot# l:old_filetype
                                    " Remember what the new filetype is.
    1              0.000004         call setbufvar(a:buffer, 'ale_original_filetype', a:new_filetype)
                            
    1              0.000001         if g:ale_lint_on_filetype_changed
    1   0.000243   0.000006             call ale#Queue(300, 'lint_file', a:buffer)
    1              0.000000         endif
    1              0.000000     endif

FUNCTION  <SNR>161_BuildCmd()
Called 10 times
Total time:   0.022695
 Self time:   0.003877

count  total (s)   self (s)
   10   0.019045   0.002988   let s:tmp_file = s:IntoTemp(a:origin_fpath)
   10              0.000064   if empty(s:tmp_file)
    1              0.000001     return ''
                              endif
                            
    9              0.000055   let s:fpath = a:origin_fpath
                            
    9   0.000469   0.000222   let custom_cmd = s:GetCustomCmd(&filetype)
                            
    9              0.000026   if custom_cmd isnot v:null
                                let cmd = printf('%s %s', custom_cmd, s:tmp_file)
                                if stridx(custom_cmd, '--output-format=json') > -1
                                  let s:TagParser = function('vista#parser#ctags#FromJSON')
                                else
                                  let s:TagParser = function('vista#parser#ctags#FromExtendedRaw')
                                endif
                              else
    9   0.002671   0.000156     let cmd = s:GetDefaultCmd(s:tmp_file)
    9              0.000042     let s:TagParser = s:DefaultTagParser
    9              0.000009   endif
                            
    9              0.000054   let t:vista.ctags_cmd = cmd
                            
    9              0.000015   return cmd

FUNCTION  <lambda>38()
Called 1 time
Total time:   0.007292
 Self time:   0.000037

count  total (s)   self (s)
    1   0.007291   0.000036 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <SNR>188_WinFindBuf()
Called 17 times
Total time:   0.000257
 Self time:   0.000257

count  total (s)   self (s)
   17              0.000180     return exists('*win_findbuf') ? win_findbuf(str2nr(a:buffer)) : [0]

FUNCTION  vista#statusline#ShouldDisable()
Called 10 times
Total time:   0.000103
 Self time:   0.000103

count  total (s)   self (s)
   10              0.000084   return get(g:, 'vista_disable_statusline', s:other_statusline_plugin_loaded)

FUNCTION  xray#settings#GetEnable()
Called 5735 times
Total time:   0.133965
 Self time:   0.133965

count  total (s)   self (s)
 5735              0.119524   return get(g:, 'xray_enable', v:true)

FUNCTION  ale#path#Simplify()
Called 608 times
Total time:   0.013496
 Self time:   0.013496

count  total (s)   self (s)
  608              0.001158     if has('unix')
  608              0.003417         let l:unix_path = substitute(a:path, '\\', '/', 'g')
                            
  608              0.008103         return substitute(simplify(l:unix_path), '^//\+', '/', 'g') " no-custom-checks
                                endif
                            
                                let l:win_path = substitute(a:path, '/', '\\', 'g')
                            
                                return substitute(simplify(l:win_path), '^\\\+', '\', 'g') " no-custom-checks

FUNCTION  vista#autocmd#Init()
Called 10 times
Total time:   0.003785
 Self time:   0.003517

count  total (s)   self (s)
                            
   10   0.000430   0.000161   call s:ClearOtherEvents(a:group_name)
                            
   10              0.000050   if index(s:registered, a:group_name) == -1
                                call add(s:registered, a:group_name)
                              endif
                            
   10              0.000073   let s:ApplyAutoUpdate = a:AUF
                            
   10              0.000085   if exists('#'.a:group_name)
   10              0.000019     let group = ''
   10              0.000040     redir => group
   10              0.002519     silent execute 'autocmd' a:group_name
   10              0.000063     redir END
   10              0.000389     if len(split(group, '\n')) > 1
   10              0.000015       return
                                endif
                              endif
                            
                              execute 'augroup' a:group_name
                                autocmd!
                            
                                " vint: -ProhibitAutocmdWithNoGroup
                                autocmd WinEnter,WinLeave __vista__ call vista#statusline#RenderOnWinEvent()
                            
                                " BufReadPost is needed for reloading the current buffer if the file
                                " was changed by an external command;
                                "
                                " CursorHold and CursorHoldI event have been removed in order to
                                " highlight the nearest tag automatically.
                                autocmd BufWritePost,BufReadPost, * call s:GenericAutoUpdate(+expand('<abuf>'), fnamemodify(expand('<afile>'), ':p'))
                            
                                autocmd BufEnter * call s:OnBufEnter(+expand('<abuf>'), fnamemodify(expand('<afile>'), ':p'))
                            
                                if get(g:, 'vista_update_on_text_changed', 0)
                                  autocmd TextChanged,TextChangedI * call s:AutoUpdateWithDelay(+expand('<abuf>'), fnamemodify(expand('<afile>'), ':p'))
                                endif
                              augroup END

FUNCTION  <SNR>119_LocalBrowse()
Called 8 times
Total time:   0.000689
 Self time:   0.000689

count  total (s)   self (s)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                              
    8              0.000055   if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
                               return
                              endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
    8              0.000042   if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
                              elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                            "   call Decho("(s:LocalBrowse) COMBAK#23: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               sil! call netrw#LocalBrowseCheck(a:dirname)
                            "   call Decho("(s:LocalBrowse) COMBAK#24: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                            "    call Decho("(s:LocalBrowse) COMBAK#25: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                               endif
                            
                              else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
    8              0.000007   endif
                            "  call Decho("(s:LocalBrowse) COMBAK#26: buf#".bufnr("%")." file<".expand("%")."> line#".line(".")." col#".col("."))
                            
                            "  call Dret("s:LocalBrowse")

FUNCTION  deoplete#util#get_keyword_pattern()
Called 2 times
Total time:   0.001835
 Self time:   0.000437

count  total (s)   self (s)
    2   0.000263   0.000243   let keyword_patterns = deoplete#custom#_get_option('keyword_patterns')
    2              0.000008   if empty(keyword_patterns)
                                let patterns = deoplete#custom#_get_filetype_option(   'keyword_patterns', a:filetype, '')
                              else
    2              0.000009     let filetype = has_key(keyword_patterns, a:filetype) ? a:filetype : '_'
    2              0.000008     let patterns = get(keyword_patterns, filetype, '')
    2              0.000001   endif
    2   0.000051   0.000029   let pattern = join(deoplete#util#convert2list(patterns), '|')
                            
                              " Convert keyword.
    2   0.001447   0.000091   let k_pattern = deoplete#util#vimoption2python( &l:iskeyword . (&l:lisp ? ',-' : ''))
    2              0.000022   return substitute(pattern, '\\k', '\=k_pattern', 'g')

FUNCTION  ale#command#IsDeferred()
Called 46 times
Total time:   0.000452
 Self time:   0.000452

count  total (s)   self (s)
   46              0.000385     return type(a:value) is v:t_dict && has_key(a:value, '_deferred_job_id')

FUNCTION  xray#highlight#ConfigureVisualHighlights()
Called 1 time
Total time:   0.000365
 Self time:   0.000349

count  total (s)   self (s)
    1   0.000117   0.000102   if xray#highlight#IsGuiOrTrueColorTerm()
    1              0.000025     let l:visual_highlight = 'gui=bold guibg=bg guifg=bg'
    1              0.000016   elseif xray#highlight#IsSupportedColorTerm()
                                let l:visual_highlight = 'cterm=bold ctermbg=bg ctermfg=bg'
                              endif
                            
    1              0.000099   execute 'silent highlight SpecialKey ' . l:visual_highlight
    1              0.000100   execute 'silent highlight NonText    ' . l:visual_highlight

FUNCTION  <SNR>172_OnTextChangedInsertMode()
Called 69 times
Total time:   0.766275
 Self time:   0.155788

count  total (s)   self (s)
   69   0.001311   0.000599   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
   69              0.000147   if s:completion_stopped
                                let s:completion_stopped = 0
                                let s:completion = s:default_completion
                                return
                              endif
                            
   69   0.132871   0.000553   call s:IdentifierFinishedOperations()
                            
                              " We have to make sure we correctly leave semantic mode even when the user
                              " inserts something like a "operator[]" candidate string which fails
                              " CurrentIdentifierFinished check.
   69              0.001137   if s:force_semantic && !s:Pyeval( 'base.LastEnteredCharIsIdentifierChar()' )
                                let s:force_semantic = 0
                              endif
                            
   69   0.276505   0.003248   if &completefunc == "youcompleteme#CompleteFunc" && ( g:ycm_auto_trigger || s:force_semantic ) && !s:InsideCommentOrStringAndShouldStop() && !s:OnBlankLine()
                                " Immediately call previous completion to avoid flickers.
   19   0.002209   0.000490     call s:Complete()
   19   0.203141   0.000660     call s:InvokeCompletion()
   19              0.000035   endif
                            
   69              0.145844   exec s:python_command "ycm_state.OnCursorMoved()"
                            
   69              0.000502   if g:ycm_autoclose_preview_window_after_completion
                                call s:ClosePreviewWindowIfNeeded()
                              endif

FUNCTION  denite#util#substitute_path_separator()
Called 2 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    2              0.000012   return s:is_windows ? substitute(a:path, '\\', '/', 'g') : a:path

FUNCTION  <SNR>4_lines()
Called 9 times
Total time:   0.000167
 Self time:   0.000167

count  total (s)   self (s)
    9              0.000159   return split(a:msg, "[\r\n]")

FUNCTION  <SNR>182_add_sign()
Called 39 times
Total time:   0.006464
 Self time:   0.006240

count  total (s)   self (s)
   39              0.000187   call add(a:sy.lines, a:line)
   39              0.000163   let a:sy.signtable[a:line] = 1
                            
   39              0.000144   if has_key(a:sy.internal, a:line)
                                " There is a sign on this line already.
   14              0.000060     if a:type == a:sy.internal[a:line].type
                                  " Keep current sign since the new one is of the same type.
                                  return a:sy.internal[a:line].id
                                else
                                  " Update sign by overwriting the ID of the current sign.
   14              0.000050       let id = a:sy.internal[a:line].id
   14              0.000011     endif
   14              0.000008   endif
                            
   39              0.000122   if !exists('id')
   25   0.002994   0.002770     let id = sy#sign#id_next(a:sy)
   25              0.000024   endif
                            
   39              0.000339   if a:type =~# 'SignifyDelete'
                                execute printf('sign define %s text=%s texthl=SignifySignDelete linehl=%s', a:type, a:1, s:delete_highlight[g:signify_line_highlight])
                              endif
   39              0.001123   execute printf('sign place %d line=%d name=%s buffer=%s', id, a:line, a:type, a:sy.buffer)
                            
   39              0.000060   return id

FUNCTION  denite#custom#_get()
Called 1 time
Total time:   0.000153
 Self time:   0.000153

count  total (s)   self (s)
    1              0.000112   if !exists('s:custom')
                                call denite#custom#_init()
                              endif
                            
    1              0.000006   return s:custom

FUNCTION  LSP#character()
Called 424 times
Total time:   0.004272
 Self time:   0.004272

count  total (s)   self (s)
  424              0.003860     return col('.') - 1

FUNCTION  denite#util#has_yarp()
Called 2 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    2              0.000012   return !has('nvim')

FUNCTION  ale#util#InSandbox()
Called 448 times
Total time:   0.013323
 Self time:   0.013323

count  total (s)   self (s)
  448              0.000644     try
  448              0.005037         let &l:equalprg=&l:equalprg
  448              0.001104     catch /E48/
                                    " E48 is the sandbox error.
                                    return 1
                                endtry
                            
  448              0.000538     return 0

FUNCTION  denite#helper#_parse_options_args()
Called 1 time
Total time:   0.002720
 Self time:   0.000231

count  total (s)   self (s)
    1              0.000005   let _ = []
    1   0.002579   0.000090   let [args, options] = s:parse_options(a:cmdline)
                            
    4              0.000007   for arg in args
                                " Add source name.
    3              0.000039     let source_name = matchstr(arg, '^[^:]*')
    3              0.000009     let source_arg = arg[len(source_name)+1 :]
    3              0.000004     let source_args = []
    3              0.000003     if source_arg !=# ''
                                  for s in split(source_arg, s:re_unquoted_match('\\\@<!:'), 1)
                                    call add(source_args, s:remove_quote_pairs(s))
                                  endfor
                                endif
    3              0.000012     call add(_, { 'name': source_name, 'args': source_args })
    3              0.000016   endfor
                            
    1              0.000002   return [_, options]

FUNCTION  <SNR>228_MarkdownRefreshSyntax()
Called 1 time
Total time:   0.001049
 Self time:   0.000070

count  total (s)   self (s)
    1              0.000010     if &filetype =~ 'markdown' && line('$') > 1
    1   0.001037   0.000058         call s:MarkdownHighlightSources(a:force)
    1              0.000001     endif

FUNCTION  FugitiveDetect()
Called 4 times
Total time:   0.005211
 Self time:   0.000196

count  total (s)   self (s)
    4              0.000033   if exists('b:git_dir') && b:git_dir =~# '^$\|/$\|^fugitive:'
                                unlet b:git_dir
                              endif
    4              0.000008   if !exists('b:git_dir')
    4   0.004070   0.000070     let dir = FugitiveExtractGitDir(a:path)
    4              0.000006     if dir !=# ''
    4              0.000007       let b:git_dir = dir
    4              0.000003     endif
    4              0.000001   endif
    4              0.000010   if exists('b:git_dir')
    4   0.001055   0.000040     return fugitive#Init()
                              endif

FUNCTION  LSP#filename()
Called 511 times
Total time:   0.140148
 Self time:   0.140148

count  total (s)   self (s)
                                " When executing autocommand, `%` might have already changed.
  511              0.101480     let l:filename = expand('<afile>:p')
  511              0.002948     if !l:filename
  511              0.030317         let l:filename = expand('%:p')
  511              0.001126     endif
  511              0.001552     return l:filename

FUNCTION  <SNR>142_GetAliasedFiletype()
Called 26 times
Total time:   0.002913
 Self time:   0.002913

count  total (s)   self (s)
   26              0.000353     let l:buffer_aliases = get(b:, 'ale_linter_aliases', {})
                            
                                " b:ale_linter_aliases can be set to a List or String.
   26              0.000479     if type(l:buffer_aliases) is v:t_list|| type(l:buffer_aliases) is v:t_string
                                    return l:buffer_aliases
                                endif
                            
                                " Check for aliased filetypes first in a buffer variable,
                                " then the global variable,
                                " then in the default mapping,
                                " otherwise use the original filetype.
  104              0.000542     for l:dict in [   l:buffer_aliases,   g:ale_linter_aliases,   s:default_ale_linter_aliases,]
   78              0.000469         if has_key(l:dict, a:original_filetype)
                                        return l:dict[a:original_filetype]
                                    endif
   78              0.000071     endfor
                            
   26              0.000059     return a:original_filetype

FUNCTION  sy#start()
Called 14 times
Total time:   0.081639
 Self time:   0.003392

count  total (s)   self (s)
   14              0.000058   if g:signify_locked
                                call sy#verbose('Locked.')
                                return
                              endif
                            
   14              0.000090   let bufnr = a:0 && has_key(a:1, 'bufnr') ? a:1.bufnr : bufnr('')
   14              0.000071   let sy = getbufvar(bufnr, 'sy')
                            
   14              0.000032   if empty(sy)
    6   0.000676   0.000091     let path = s:get_path(bufnr)
    6   0.000416   0.000081     if s:skip(bufnr, path)
    3   0.000059   0.000016       call sy#verbose('Skip file: '. path)
    3              0.000002       return
                                endif
    3   0.000074   0.000021     call sy#verbose('Register new file: '. path)
    3   0.000305   0.000175     let new_sy = { 'path':       path, 'buffer':     bufnr, 'active':     0, 'detecting':  0, 'vcs':        [], 'hunks':      [], 'signid':     0x100, 'updated_by': '', 'stats':      [-1, -1, -1], 'info':       {    'dir':  fnamemodify(path, ':p:h'),    'path': sy#util#escape(path),    'file': sy#util#escape(fnamemodify(path, ':t')) }}
    3              0.000019     call setbufvar(bufnr, 'sy', new_sy)
    3              0.000009     if get(g:, 'signify_disable_by_default')
                                  call sy#verbose('Disabled by default.')
                                  return
                                endif
    3              0.000005     let new_sy.active = 1
    3              0.000009     call setbufvar(bufnr, 'sy', new_sy)
    3   0.027890   0.000109     call sy#repo#detect(bufnr)
    3              0.000010   elseif has('vim_starting')
                                call sy#verbose("Don't run Sy more than once during startup.")
                                return
                              elseif !sy.active
                                call sy#verbose('Inactive buffer.')
                                return
                              elseif empty(sy.vcs)
                                if get(sy, 'retry')
                                  let sy.retry = 0
                                  call sy#verbose('Redetecting VCS.')
                                  call sy#repo#detect(sy.buffer)
                                else
                                  if get(sy, 'detecting')
                                    call sy#verbose('Detection is already in progress.')
                                  else
                                    call sy#verbose('No VCS found. Disabling.')
                                    call sy#disable(sy.buffer)
                                  endif
                                endif
                              else
   16              0.000090     for vcs in sy.vcs
    8              0.000057       let job_id = getbufvar(sy.buffer, 'sy_job_id_'. vcs, 0)
    8              0.000038       if type(job_id) != type(0) || job_id > 0
    1   0.000043   0.000018         call sy#verbose('Update is already in progress.', vcs)
    1              0.000001       else
    7   0.000279   0.000110         call sy#verbose('Updating signs.', vcs)
    7   0.049637   0.000512         call sy#repo#get_diff(sy.buffer, vcs, function('sy#sign#set_signs'))
    7              0.000033       endif
    8              0.000023     endfor
    8              0.000010   endif

FUNCTION  <SNR>161_IntoTemp()
Called 10 times
Total time:   0.016057
 Self time:   0.012459

count  total (s)   self (s)
                              " Don't use tempname() if possible since it would cause the changing of the anonymous tag name.
                              "
                              " Ref: https://github.com/liuchengxu/vista.vim/issues/122#issuecomment-511115932
   10              0.000034   try
   10              0.000067     if exists('$TMPDIR')
   10   0.001828   0.000151       let tmpdir = s:Tempdir()
   10   0.002157   0.000236       let tempname = s:TempnameBasedOnSourceBufname()
   10              0.000038       let tmp = tmpdir.tempname
   10              0.000011     else
                                  if s:is_mac || s:is_linux
                                    let tmpdir = '/tmp/vista.vim_ctags_tmp/'
                                    if !isdirectory(tmpdir)
                                      call mkdir(tmpdir)
                                    endif
                                    let tempname = s:TempnameBasedOnSourceBufname()
                                    let tmp = tmpdir.tempname
                                  endif
                                endif
   10              0.000013   catch
                              endtry
                            
   10              0.000044   if !exists('l:tmp')
                                let tmp = s:BuiltinTempname()
                              endif
                            
   10              0.000044   if get(t:vista, 'on_text_changed', 0)
                                let lines = t:vista.source.lines()
                                let t:vista.on_text_changed = 0
                              else
   10              0.000031     if empty(a:1)
                                  let lines = t:vista.source.lines()
                                else
   10              0.000010       try
   10              0.003348         let lines = readfile(a:1)
                                  " Vim cannot read a temporary file, this may happen when you open vim with
                                  " a file which does not exist yet, e.g., 'vim does_exist_yet.txt'
    9              0.000024       catch /E484/
    1              0.000002         return
                                  endtry
    9              0.000007     endif
    9              0.000006   endif
                            
    9              0.007792   if writefile(lines, tmp) == 0
    9              0.000071     return tmp
                              else
                                return vista#error#('Fail to write into a temp file.')
                              endif

FUNCTION  <SNR>150_evaluate_expand()
Called 42 times
Total time:   0.576285
 Self time:   0.002966

count  total (s)   self (s)
   42              0.000091   try
   42   0.573317   0.000990     let result = eval(a:component . '()')
   42              0.000214     if type(result) == 1 && result ==# ''
    9              0.000013       return []
                                endif
   33              0.000051   catch
                                return []
                              endtry
   33   0.002315   0.001323   return map(type(result) == 3 ? (result + [[], [], []])[:2] : [[], [result], []], 'filter(s:normalize(v:val), "v:val !=# ''''")')

FUNCTION  vista#source#Update()
Called 12 times
Total time:   0.000505
 Self time:   0.000505

count  total (s)   self (s)
   12              0.000086   if !exists('t:_vista_initialized')
                                call s:EnsureExists()
                                let t:_vista_initialized = 1
                              endif
                            
   12              0.000043   let t:vista.source.bufnr = a:bufnr
                            
   12              0.000019   if a:0 == 1
                                let t:vista.source.fname = a:1
                              elseif a:0 == 2
   12              0.000091     let t:vista.source.fname = a:1
   12              0.000060     let t:vista.source.fpath = a:2
   12              0.000011   endif

FUNCTION  <SNR>211_parse_snippet_name()
Called 16 times
Total time:   0.002672
 Self time:   0.002494

count  total (s)   self (s)
                              " Initialize snippet dict.
   16   0.000387   0.000210   let snippet_dict = { 'word' : '', 'linenr' : a:linenr, 'options' : neosnippet#parser#_initialize_snippet_options() }
                            
                              " Try using the name without the description (abbr).
   16              0.000626   let base_name = matchstr(a:line, '^snippet\s\+\zs\S\+')
   16              0.000043   let snippet_dict.name = base_name
                            
                              " Fall back to using the name with integer counter,
                              " but only if the name is a duplicate.
                              " SnipMate snippets may have duplicate names, but different
                              " descriptions (abbrs).
   16              0.000484   let description = matchstr(a:line, '^snippet\s\+\S\+\s\+\zs.*$')
   16              0.000083   if g:neosnippet#enable_snipmate_compatibility && description !=# '' && description !=# snippet_dict.name && has_key(a:dup_check, snippet_dict.name)
                                " Convert description.
                                let i = 0
                                while has_key(a:dup_check, snippet_dict.name)
                                  let snippet_dict.name = base_name . '__' . i
                                  let i += 1
                                endwhile
                              endif
                            
                              " Collect the description (abbr) of the snippet, if set on snippet line.
                              " This is for compatibility with SnipMate-style snippets.
   16              0.000525   let snippet_dict.abbr = matchstr(a:line, '^snippet\s\+\S\+\s\+\zs.*$')
                            
                              " Check for duplicated names.
   16              0.000056   if has_key(a:dup_check, snippet_dict.name)
                                let dup = a:dup_check[snippet_dict.name]
                                call neosnippet#util#print_error(printf( '%s:%d is overriding `%s` from %s:%d', a:snippets_file, a:linenr, snippet_dict.name, dup.action__path, dup.action__line))
                                call neosnippet#util#print_error(printf( 'Please rename the snippet name or use `delete %s`.', snippet_dict.name))
                              endif
                            
   16              0.000018   return snippet_dict

FUNCTION  test#clojure#fireplacetest#test_file()
Called 6 times
Total time:   0.000761
 Self time:   0.000761

count  total (s)   self (s)
    6              0.000731   return a:file =~# g:test#clojure#fireplacetest#file_pattern

FUNCTION  LSP#viewport()
Called 424 times
Total time:   0.015539
 Self time:   0.015539

count  total (s)   self (s)
  424              0.014082     return { 'start': line('w0') - 1, 'end': line('w$'), }

FUNCTION  <SNR>139_is_file_exist()
Called 121 times
Total time:   0.082979
 Self time:   0.082979

count  total (s)   self (s)
  121              0.075208   let ignore = !empty(g:neomru#file_mru_ignore_pattern) && a:path =~ g:neomru#file_mru_ignore_pattern
  121              0.007493   return !ignore && (getftype(a:path) ==# 'file' || getftype(a:path) ==# 'link' || a:path =~ '^\h\w\+:')

FUNCTION  <SNR>156_skip()
Called 6 times
Total time:   0.000335
 Self time:   0.000335

count  total (s)   self (s)
    6              0.000191   if getbufvar(a:bufnr, '&diff') || !filereadable(a:path)
    3              0.000003     return 1
                              endif
                            
    3              0.000010   if exists('g:signify_skip_filetype')
                                if has_key(g:signify_skip_filetype, getbufvar(a:bufnr, '&filetype'))
                                  return 1
                                elseif has_key(g:signify_skip_filetype, 'help') && getbufvar(a:bufnr, '&buftype') == 'help'
                                  return 1
                                endif
                              endif
                            
    3              0.000010   if exists('g:signify_skip_filename') && has_key(g:signify_skip_filename, a:path)
                                return 1
                              endif
                            
                              " DEPRECATED: Use g:signify_skip.pattern instead.
    3              0.000008   if exists('g:signify_skip_filename_pattern')
                                for pattern in g:signify_skip_filename_pattern
                                  if a:path =~ pattern
                                    return 1
                                  endif
                                endfor
                              endif
                            
    3              0.000007   if exists('g:signify_skip')
                                if has_key(g:signify_skip, 'pattern')
                                  for pattern in g:signify_skip.pattern
                                    if a:path =~ pattern
                                      return 1
                                    endif
                                  endfor
                                endif
                              endif
                            
    3              0.000002   return 0

FUNCTION  <SNR>106_Tree()
Called 14 times
Total time:   0.000391
 Self time:   0.000391

count  total (s)   self (s)
   14              0.000032   let dir = a:path
   14              0.000258   if dir =~# '/\.git$'
    5              0.000028     return len(dir) ==# 5 ? '/' : dir[0:-6]
                              elseif dir ==# ''
    9              0.000009     return ''
                              endif
                              if !has_key(s:worktree_for_dir, dir)
                                let s:worktree_for_dir[dir] = ''
                                let config_file = dir . '/config'
                                if filereadable(config_file)
                                  let config = readfile(config_file,'',10)
                                  call filter(config,'v:val =~# "^\\s*worktree *="')
                                  if len(config) == 1
                                    let worktree = FugitiveVimPath(matchstr(config[0], '= *\zs.*'))
                                  endif
                                elseif filereadable(dir . '/gitdir')
                                  let worktree = fnamemodify(FugitiveVimPath(readfile(dir . '/gitdir')[0]), ':h')
                                  if worktree ==# '.'
                                    unlet! worktree
                                  endif
                                endif
                                if exists('worktree')
                                  let s:worktree_for_dir[dir] = s:Slash(resolve(worktree))
                                  let s:dir_for_worktree[s:worktree_for_dir[dir]] = dir
                                endif
                              endif
                              if s:worktree_for_dir[dir] =~# '^\.'
                                return simplify(dir . '/' . s:worktree_for_dir[dir])
                              else
                                return s:worktree_for_dir[dir]
                              endif

FUNCTION  <SNR>4_reorg_rtp()
Called 1 time
Total time:   0.009301
 Self time:   0.002573

count  total (s)   self (s)
    1              0.000003   if !empty(s:first_rtp)
    1              0.000019     execute 'set rtp-='.s:first_rtp
    1              0.000022     execute 'set rtp-='.s:last_rtp
    1              0.000001   endif
                            
                              " &rtp is modified from outside
    1              0.000012   if exists('s:prtp') && s:prtp !=# &rtp
                                call s:remove_rtp()
                                unlet! s:middle
                              endif
                            
    1              0.000012   let s:middle = get(s:, 'middle', &rtp)
    1   0.007357   0.000629   let rtps     = map(s:loaded_names(), 's:rtp(g:plugs[v:val])')
    1              0.000925   let afters   = filter(map(copy(rtps), 'globpath(v:val, "after")'), '!empty(v:val)')
    1              0.000429   let rtp      = join(map(rtps, 'escape(v:val, ",")'), ',') . ','.s:middle.',' . join(map(afters, 'escape(v:val, ",")'), ',')
    1              0.000469   let &rtp     = substitute(substitute(rtp, ',,*', ',', 'g'), '^,\|,$', '', 'g')
    1              0.000005   let s:prtp   = &rtp
                            
    1              0.000003   if !empty(s:first_rtp)
    1              0.000019     execute 'set rtp^='.s:first_rtp
    1              0.000015     execute 'set rtp+='.s:last_rtp
    1              0.000001   endif

FUNCTION  denite#util#execute_path()
Called 1 time
Total time:   0.043062
 Self time:   0.001080

count  total (s)   self (s)
    1   0.000226   0.000045   let dir = denite#util#path2directory(a:path)
                              " Auto make directory.
    1              0.000042   if dir !~# '^\a\+:' && !isdirectory(dir) && denite#util#input_yesno(       printf('"%s" does not exist. Create?', dir))
                                call mkdir(dir, 'p')
                              endif
                            
    1              0.000001   try
    1   0.042778   0.000978     execute a:command fnameescape(s:expand(a:path))
    1              0.000001   catch /^Vim\%((\a\+)\)\=:E325/
                                " Ignore swap file error
                              catch
                                call denite#util#print_error(v:throwpoint)
                                call denite#util#print_error(v:exception)
                              endtry

FUNCTION  <SNR>145_AddProblemsFromOtherBuffers()
Called 2 times
Total time:   0.018035
 Self time:   0.018035

count  total (s)   self (s)
    2              0.000073     let l:filename = expand('#' . a:buffer . ':p')
    2              0.000006     let l:loclist = []
    2              0.000008     let l:name_map = {}
                            
                                " Build a map of the active linters.
    4              0.000009     for l:linter in a:linters
    2              0.000009         let l:name_map[l:linter.name] = 1
    2              0.000002     endfor
                            
                                " Find the items from other buffers, for the linters that are enabled.
   11              0.000042     for l:info in values(g:ale_buffer_info)
 1219              0.002489         for l:item in l:info.loclist
 1210              0.006287             if has_key(l:item, 'filename')&& l:item.filename is# l:filename&& has_key(l:name_map, l:item.linter_name)
                                            " Copy the items and set the buffer numbers to this one.
                                            let l:new_item = copy(l:item)
                                            let l:new_item.bufnr = a:buffer
                                            call add(l:loclist, l:new_item)
                                        endif
 1210              0.001573         endfor
    9              0.000006     endfor
                            
    2              0.000006     if !empty(l:loclist)
                                    call sort(l:loclist, function('ale#util#LocItemCompareWithText'))
                                    call uniq(l:loclist, function('ale#util#LocItemCompareWithText'))
                            
                                    " Set the loclist variable, used by some parts of ALE.
                                    let g:ale_buffer_info[a:buffer].loclist = l:loclist
                                    call ale#engine#SetResults(a:buffer, l:loclist)
                                endif

FUNCTION  <SNR>135_HandleMessage()
Called 23 times
Total time:   0.024156
 Self time:   0.021176

count  total (s)   self (s)
   23              0.000223     if a:event ==# 'stdout'
  121              0.000540         while len(a:lines) > 0
   98              0.000559             let l:line = remove(a:lines, 0)
                            
   98              0.000241             if l:line ==# ''
   48              0.000054                 continue
                                        elseif s:content_length == 0
   25              0.003746                 let s:content_length = str2nr(substitute(l:line, '.*Content-Length:', '', ''))
   25              0.000138                 continue
                                        endif
                            
   25              0.000246             let s:input .= strpart(l:line, 0, s:content_length)
   25              0.000106             if s:content_length < strlen(l:line)
                                            call insert(a:lines, strpart(l:line, s:content_length), 0)
                                            let s:content_length = 0
                                        else
   25              0.000120                 let s:content_length = s:content_length - strlen(l:line)
   25              0.000027             endif
   25              0.000041             if s:content_length > 0
                                            continue
                                        endif
                            
   25              0.000064             try
   25              0.000407                 let l:message = json_decode(s:input)
   25              0.000134                 if type(l:message) !=# s:TYPE.dict
                                                throw 'Messsage is not dict.'
                                            endif
   25              0.000031             catch
                                            call s:Debug('Error decoding message: ' . string(v:exception) . ' Message: ' . s:input)
                                            continue
                                        finally
   25              0.000073                 let s:input = ''
   25              0.000032             endtry
                            
   25              0.000101             if has_key(l:message, 'method')
   25              0.000666                 let l:id = get(l:message, 'id', v:null)
   25              0.000177                 let l:method = get(l:message, 'method')
   25              0.000094                 let l:params = get(l:message, 'params')
   25              0.000027                 try
   25              0.000141                     let l:params = type(l:params) == s:TYPE.list ? l:params : [l:params]
   25   0.002387   0.001176                     let l:result = call(l:method, l:params)
   25              0.000074                     if l:id isnot v:null
   25   0.002827   0.001058                         call LanguageClient#Write(json_encode({ 'jsonrpc': '2.0', 'id': l:id, 'result': l:result, }))
   25              0.000063                     endif
   25              0.000029                 catch
                                                let l:exception = v:exception
                                                if l:id isnot v:null
                                                    try
                                                        call LanguageClient#Write(json_encode({ 'jsonrpc': '2.0', 'id': l:id, 'error': {   'code': -32603,   'message': string(v:exception)   } }))
                                                    catch
                                                        " TODO
                                                    endtry
                                                endif
                                                call s:Debug(string(l:exception))
                                            endtry
   25              0.000109             elseif has_key(l:message, 'result') || has_key(l:message, 'error')
                                            let l:id = get(l:message, 'id')
                                            let l:Handle = get(s:handlers, l:id)
                                            unlet s:handlers[l:id]
                                            let l:type = type(l:Handle)
                                            if l:type == s:TYPE.funcref || l:type == s:TYPE.string
                                                call call(l:Handle, [l:message])
                                            elseif l:type == s:TYPE.list
                                                call add(l:Handle, l:message)
                                            elseif l:type == s:TYPE.string && exists(l:Handle)
                                                let l:outputs = eval(l:Handle)
                                                call add(l:outputs, l:message)
                                            else
                                                call s:Echoerr('Unknown Handle type: ' . string(l:Handle))
                                            endif
                                        else
                                            call s:Echoerr('Unknown message: ' . string(l:message))
                                        endif
   25              0.000048         endwhile
   23              0.000048     elseif a:event ==# 'stderr'
                                    call s:Echoerr('LanguageClient stderr: ' . string(a:lines))
                                elseif a:event ==# 'exit'
                                    if type(a:lines) == type(0) && (a:lines == 0 || a:lines == 143)
                                        return
                                    endif
                                    call s:Debug('LanguageClient exited with: ' . string(a:lines))
                                else
                                    call s:Debug('LanguageClient unknown event: ' . a:event)
                                endif

FUNCTION  ale#Queue()
Called 28 times
Total time:   0.172251
 Self time:   0.003107

count  total (s)   self (s)
   28              0.000097     if a:0 > 2
                                    throw 'too many arguments!'
                                endif
                            
   28              0.000177     let l:buffer = get(a:000, 1, v:null)
                            
   28              0.000132     if l:buffer is v:null
   17              0.000101         let l:buffer = bufnr('')
   17              0.000018     endif
                            
   28              0.000092     if type(l:buffer) isnot v:t_number
                                    throw 'buffer_number must be a Number'
                                endif
                            
   28   0.005798   0.000375     if ale#ShouldDoNothing(l:buffer)
    1              0.000001         return
                                endif
                            
                                " Default linting_flag to ''
   27              0.000129     let l:should_lint_file = get(a:000, 0) is# 'lint_file'
                            
   27              0.000058     if s:lint_timer != -1
   12              0.000060         call timer_stop(s:lint_timer)
   12              0.000030         let s:lint_timer = -1
   12              0.000009     endif
                            
   27              0.000036     if a:delay > 0
   11              0.000192         let s:lint_timer = timer_start(   a:delay,   function('s:Lint', [l:buffer, l:should_lint_file]))
   11              0.000014     else
   16   0.164336   0.000616         call s:Lint(l:buffer, l:should_lint_file, 0)
   16              0.000023     endif

FUNCTION  <SNR>161_ApplyExecute()
Called 10 times
Total time:   0.054786
 Self time:   0.001038

count  total (s)   self (s)
   10   0.023088   0.000392   let cmd = s:BuildCmd(a:fpath)
   10              0.000039   if empty(cmd)
    1              0.000001     return
                              endif
                            
    9              0.000026   if a:bang || !s:can_async
                                call s:ApplyRun(cmd)
                              else
    9   0.031459   0.000406     call s:RunAsyncCommon(cmd)
    9              0.000020   endif

FUNCTION  ale#job#PrepareCommand()
Called 23 times
Total time:   0.004641
 Self time:   0.003978

count  total (s)   self (s)
   23   0.001061   0.000399     let l:wrapper = ale#Var(a:buffer, 'command_wrapper')
                            
                                " The command will be executed in a subshell. This fixes a number of
                                " issues, including reading the PATH variables correctly, %PATHEXT%
                                " expansion on Windows, etc.
                                "
                                " NeoVim handles this issue automatically if the command is a String,
                                " but we'll do this explicitly, so we use the same exact command for both
                                " versions.
   23              0.000205     let l:command = !empty(l:wrapper) ? s:PrepareWrappedCommand(l:wrapper, a:command) : a:command
                            
                                " If a custom shell is specified, use that.
   23              0.000102     if exists('g:ale_shell')
                                    let l:shell_arguments = get(g:, 'ale_shell_arguments', &shellcmdflag)
                            
                                    return split(g:ale_shell) + split(l:shell_arguments) + [l:command]
                                endif
                            
   23              0.000124     if has('win32')
                                    return 'cmd /s/c "' . l:command . '"'
                                endif
                            
   23              0.002393     if &shell =~? 'fish$\|pwsh$'
   23              0.000165         return ['/bin/sh', '-c', l:command]
                                endif
                            
                                return split(&shell) + split(&shellcmdflag) + [l:command]

FUNCTION  <SNR>205__encode_name()
Called 3 times
Total time:   0.000568
 Self time:   0.000204

count  total (s)   self (s)
                              " Check cache directory.
    3              0.000096   if !isdirectory(a:cache_dir)
                                call mkdir(a:cache_dir, 'p')
                              endif
    3              0.000006   let cache_dir = a:cache_dir
    3              0.000022   if cache_dir !~# '/$'
                                let cache_dir .= '/'
                              endif
                            
    3   0.000421   0.000058   return cache_dir . s:_create_hash(cache_dir, a:filename)

FUNCTION  neosnippet#handlers#_all_clear_markers()
Called 3 times
Total time:   0.001761
 Self time:   0.001628

count  total (s)   self (s)
    3              0.000038   if !&l:modifiable
                                return
                              endif
                            
    3              0.000041   let pos = getpos('.')
                            
    3              0.000006   try
    3   0.000264   0.000130     while !empty(neosnippet#variables#expand_stack())
                                  call neosnippet#view#_clear_markers( neosnippet#variables#expand_stack()[-1])
                                  stopinsert
                                endwhile
    3              0.000010   finally
    3              0.000030     call setpos('.', pos)
    3              0.000248   endtry

FUNCTION  <SNR>150_normalize()
Called 99 times
Total time:   0.000992
 Self time:   0.000992

count  total (s)   self (s)
   99              0.000317   if type(a:result) == 3
   99              0.000563     return map(a:result, 'type(v:val) == 1 ? v:val : string(v:val)')
                              elseif type(a:result) == 1
                                return [a:result]
                              else
                                return [string(a:result)]
                              endif

FUNCTION  sy#repo#get_diff()
Called 13 times
Total time:   0.076250
 Self time:   0.064615

count  total (s)   self (s)
   13   0.000975   0.000495   call sy#verbose('sy#repo#get_diff()', a:vcs)
                            
   13              0.000346   let job_id = getbufvar(a:bufnr, 'sy_job_id_'.a:vcs)
                            
   13              0.000740   if getbufvar(a:bufnr, '&modified')
    4   0.008092   0.000145     let [cmd, options] = s:initialize_buffer_job(a:bufnr, a:vcs)
    4              0.000010     let options.difftool = 'diff'
    4              0.000004   else
    9   0.003460   0.000253     let [cmd, options] = s:initialize_job(a:bufnr, a:vcs)
    9              0.000030     let options.difftool = a:vcs
    9              0.000007   endif
                            
   13              0.000035   let options.func = a:func
                            
   13              0.000054   if has('nvim')
   13              0.000017     if job_id
                                  silent! call jobstop(job_id)
                                endif
   13              0.060194     let job_id = jobstart(cmd, extend(options, { 'cwd':       getbufvar(a:bufnr, 'sy').info.dir, 'on_stdout': function('s:callback_nvim_stdout'), 'on_exit':   function('s:callback_nvim_exit'), }))
   13              0.000504     call setbufvar(a:bufnr, 'sy_job_id_'.a:vcs, job_id)
   13              0.000076   elseif has('patch-8.0.902')
                                if type(job_id) != type(0)
                                  silent! call job_stop(job_id)
                                endif
                                let opts = { 'cwd':      getbufvar(a:bufnr, 'sy').info.dir, 'in_io':    'null', 'out_cb':   function('s:callback_vim_stdout', options), 'close_cb': function('s:callback_vim_close', options), }
                                let job_id = job_start(cmd, opts)
                                call setbufvar(a:bufnr, 'sy_job_id_'.a:vcs, job_id)
                              else
                                let options.stdoutbuf = split(s:run(a:vcs), '\n')
                                call s:handle_diff(options, v:shell_error)
                              endif

FUNCTION  ale#engine#IsExecutable()
Called 23 times
Total time:   0.000501
 Self time:   0.000501

count  total (s)   self (s)
   23              0.000097     if empty(a:executable)
                                    " Don't log the executable check if the executable string is empty.
                                    return 0
                                endif
                            
                                " Check for a cached executable() check.
   23              0.000154     let l:result = get(s:executable_cache_map, a:executable, v:null)
                            
   23              0.000045     if l:result isnot v:null
   23              0.000033         return l:result
                                endif
                            
                                " Check if the file is executable, and convert -1 to 1.
                                let l:result = executable(a:executable) isnot 0
                            
                                " Cache the executable check if we found it, or if the option to cache
                                " failing checks is on.
                                if l:result || get(g:, 'ale_cache_executable_check_failures', 0)
                                    let s:executable_cache_map[a:executable] = l:result
                                endif
                            
                                if g:ale_history_enabled
                                    call ale#history#Add(a:buffer, l:result, 'executable', a:executable)
                                endif
                            
                                return l:result

FUNCTION  ale#Escape()
Called 46 times
Total time:   0.001792
 Self time:   0.001792

count  total (s)   self (s)
   46              0.000646     if fnamemodify(&shell, ':t') is? 'cmd.exe'
                                    " If the string contains spaces, it will be surrounded by quotes.
                                    " Otherwise, special characters will be escaped with carets (^).
                                    return substitute(   a:str =~# ' '       ?  '"' .  substitute(a:str, '"', '""', 'g') . '"'       : substitute(a:str, '\v([&|<>^])', '^\1', 'g'),   '%',   '%%',   'g',)
                                endif
                            
   46              0.000244     return shellescape (a:str)

FUNCTION  neosnippet#commands#_make_cache()
Called 28 times
Total time:   0.041881
 Self time:   0.001568

count  total (s)   self (s)
   28   0.000737   0.000452   call neosnippet#init#check()
                            
   28              0.000106   let filetype = a:filetype ==# '' ? &filetype : a:filetype
   28              0.000049   if filetype ==# ''
                                let filetype = 'nothing'
                              endif
                            
   28   0.000533   0.000243   let snippets = neosnippet#variables#snippets()
   28              0.000089   if has_key(snippets, filetype)
   27              0.000025     return
                              endif
                            
    1              0.000003   let snippets[filetype] = {}
                            
    1   0.000134   0.000059   let cache_dir = neosnippet#variables#data_dir()
                            
    2   0.005425   0.000071   for filename in neosnippet#helpers#get_snippets_files(filetype)
                                " Clear cache file
    1   0.009457   0.000065     call s:Cache.deletefile(cache_dir, filename)
    1   0.025143   0.000228     let snippets[filetype] = extend(snippets[filetype], neosnippet#parser#_parse_snippets(filename))
    1              0.000003   endfor
                            
    1              0.000002   if g:neosnippet#enable_snipmate_compatibility
                                " Load file snippets
                                for filename in neosnippet#helpers#get_snippet_files(filetype)
                                  let trigger = fnamemodify(filename, ':t:r')
                                  let snippets[filetype][trigger] = neosnippet#parser#_parse_snippet(filename, trigger)
                                endfor
                              endif

FUNCTION  <SNR>172_OnTextChangedNormalMode()
Called 10 times
Total time:   0.140304
 Self time:   0.000375

count  total (s)   self (s)
   10   0.000305   0.000161   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
   10   0.139931   0.000146   call s:OnFileReadyToParse()

FUNCTION  <SNR>235_doModelines()
Called 4 times
Total time:   0.021589
 Self time:   0.000651

count  total (s)   self (s)
    4              0.000023   if line('$') > &modelines
    4              0.000009     let l:lines={ }
    4              0.000346     call map(filter(getline(1, &modelines) + getline(line('$') - &modelines, '$'), 'v:val =~# ":"'), 'extend(l:lines, { v:val : 0 } )')
   12              0.000053     for l:line in keys(l:lines)
    8   0.021067   0.000130       call s:doModeline(l:line)
    8              0.000012     endfo
    4              0.000004   el
                                for l:line in getline(1, '$')
                                  call s:doModeline(l:line)
                                endfo
                              en

FUNCTION  lightline#statusline()
Called 14 times
Total time:   0.030798
 Self time:   0.000573

count  total (s)   self (s)
   14              0.000056   if a:inactive && !has_key(s:highlight, 'inactive')
                                call lightline#highlight('inactive')
                              endif
   14   0.030681   0.000456   return s:line(0, a:inactive)

FUNCTION  <SNR>187_UpdateLineNumbers()
Called 17 times
Total time:   0.007559
 Self time:   0.007559

count  total (s)   self (s)
   17              0.000053     let l:line_map = {}
   17              0.000043     let l:line_numbers_changed = 0
                            
  202              0.000304     for [l:line, l:sign_id, l:name] in a:current_sign_list
  185              0.000350         let l:line_map[l:sign_id] = l:line
  185              0.000163     endfor
                            
  625              0.000576     for l:item in a:loclist
  608              0.000660         if l:item.bufnr == a:buffer
  608              0.001974             let l:lnum = get(l:line_map, get(l:item, 'sign_id', 0), 0)
                            
  608              0.000645             if l:lnum && l:item.lnum != l:lnum
                                            let l:item.lnum = l:lnum
                                            let l:line_numbers_changed = 1
                                        endif
  608              0.000227         endif
  608              0.000660     endfor
                            
                                " When the line numbers change, sort the list again
   17              0.000029     if l:line_numbers_changed
                                    call sort(a:loclist, 'ale#util#LocItemCompare')
                                endif

FUNCTION  <SNR>150_subseparator()
Called 55 times
Total time:   0.003492
 Self time:   0.003492

count  total (s)   self (s)
   55              0.000438   let [a, c, f, v, u] = [a:components, s:lightline.component, s:lightline.component_function, s:lightline.component_visible_condition, s:lightline.component_function_visible_condition]
   55              0.002091   let xs = map(range(len(a:components)), 'a:expanded[v:val] ? "1" : has_key(f, a[v:val]) ? (has_key(u, a[v:val]) ? "(".u[a[v:val]].")" : (exists("*".f[a[v:val]]) ? "" : "exists(\"*".f[a[v:val]]."\")&&").f[a[v:val]]."()!=#\"\"") : has_key(v, a[v:val]) ? "(".v[a[v:val]].")" : has_key(c, a[v:val]) ? "1" : "0"')
   55              0.000886   return '%{' . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : xs[0] . '&&(') . join(xs[1:], '||') . (xs[0] ==# '1' || xs[0] ==# '(1)' ? '' : ')') . '?"' . a:subseparator . '":""}'

FUNCTION  xray#list#RestoreOriginalListOptions()
Called 1 time
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    1              0.000007   if get(b:, 'original_list', &l:list)
    1              0.000008     execute 'silent! setlocal list'
    1              0.000001   else
                                execute 'silent! setlocal nolist'
                              endif
                            
    1              0.000005   setlocal listchars=
    1              0.000018   execute 'silent! setlocal listchars=' . escape(get(b:, 'original_listchars', split(&l:listchars, ',')), ' ')

FUNCTION  necovim#helper#make_cache()
Called 2 times
Total time:   0.012783
 Self time:   0.000152

count  total (s)   self (s)
    2              0.000010   if &filetype !=# 'vim'
                                return
                              endif
                            
    2   0.012765   0.000134   let s:script_candidates_list[bufnr('%')] = s:get_script_candidates(bufnr('%'))

FUNCTION  ale#util#BinarySearch()
Called 344 times
Total time:   0.010353
 Self time:   0.010353

count  total (s)   self (s)
  344              0.000962     let l:min = 0
  344              0.001402     let l:max = len(a:loclist) - 1
                            
  386              0.001010     while 1
  386              0.000962         if l:max < l:min
  341              0.000542             return -1
                                    endif
                            
   45              0.000139         let l:mid = (l:min + l:max) / 2
   45              0.000227         let l:item = a:loclist[l:mid]
                            
                                    " Binary search for equal buffers, equal lines, then near columns.
   45              0.000106         if l:item.bufnr < a:buffer
                                        let l:min = l:mid + 1
                                    elseif l:item.bufnr > a:buffer
                                        let l:max = l:mid - 1
                                    elseif l:item.lnum < a:line
   30              0.000070             let l:min = l:mid + 1
   30              0.000054         elseif l:item.lnum > a:line
   12              0.000017             let l:max = l:mid - 1
   12              0.000008         else
                                        " This part is a small sequential search.
    3              0.000006             let l:index = l:mid
                            
                                        " Search backwards to find the first problem on the line.
    5              0.000022             while l:index > 0&& a:loclist[l:index - 1].bufnr == a:buffer&& a:loclist[l:index - 1].lnum == a:line
    2              0.000004                 let l:index -= 1
    2              0.000001             endwhile
                            
                                        " Find the last problem on or before this column.
    3              0.000016             while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col <= a:column
                                            let l:index += 1
                                        endwhile
                            
                                        " Scan forwards to find the last item on the column for the item
                                        " we found, which will have the most serious problem.
    3              0.000009             let l:item_column = a:loclist[l:index].col
                            
    3              0.000016             while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col == l:item_column
                                            let l:index += 1
                                        endwhile
                            
    3              0.000004             return l:index
                                    endif
   42              0.000050     endwhile

FUNCTION  <SNR>161_ExtractLinewise()
Called 8 times
Total time:   0.000496
 Self time:   0.000208

count  total (s)   self (s)
    8   0.000428   0.000139   call s:PrepareContainer()
    8              0.000040   call map(a:raw_data, 's:TagParser(v:val, s:data)')

FUNCTION  <SNR>172_OnVimLeave()
Called 1 time
Total time:   0.170152
 Self time:   0.170152

count  total (s)   self (s)
    1              0.170148   exec s:python_command "ycm_state.OnVimLeave()"

FUNCTION  <SNR>151_shorten_right()
Called 16 times
Total time:   0.000693
 Self time:   0.000446

count  total (s)   self (s)
   16              0.000050   if a:oldlen + g:lightline_buffer_expand_right_icon_len <= a:newlen
                                return a:str
                              endif
   16              0.000039   if a:my_minwid < 0 || a:right_minwid < 0
    8   0.000111   0.000074     return s:mb_str_part(a:str, 0, a:newlen - g:lightline_buffer_expand_right_icon_len) . g:lightline_buffer_expand_right_icon
                              endif
                            
    8   0.000384   0.000174   return s:clickable_text(s:mb_str_part(a:str, 0, a:newlen - g:lightline_buffer_expand_right_icon_len), a:my_minwid) . s:clickable_text(g:lightline_buffer_expand_right_icon, a:right_minwid)

FUNCTION  vista#sidebar#Reload()
Called 6 times
Total time:   0.000110
 Self time:   0.000110

count  total (s)   self (s)
                              " empty(a:data):
                              "   May be triggered by autocmd event sometimes
                              "   e.g., unsupported filetypes for ctags or no related language servers.
                              "
                              " !has_key(t:vista, 'bufnr'):
                              "   May opening a new tab if bufnr does not exist in t:vista.
                              "
                              " t:vista.winnr() == -1:
                              "   vista window is not visible.
    6              0.000049   if empty(a:data) || !has_key(t:vista, 'bufnr') || t:vista.winnr() == -1
    6              0.000009     return
                              endif
                            
                              let rendered = vista#renderer#Render(a:data)
                              call vista#util#SetBufline(t:vista.bufnr, rendered)

FUNCTION  <lambda>44()
Called 1 time
Total time:   0.005187
 Self time:   0.000039

count  total (s)   self (s)
    1   0.005186   0.000038 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  test#go#test_file()
Called 6 times
Total time:   0.000467
 Self time:   0.000467

count  total (s)   self (s)
    6              0.000283   if fnamemodify(a:file, ':t') =~# a:file_pattern
                                " given the current runner, check if is can be used with the file
                                if exists('g:test#go#runner')
                                  return a:runner == g:test#go#runner
                                endif
                                let contains_ginkgo_import = (search('github.com/onsi/ginkgo', 'n') > 0)
                                if a:runner ==# 'ginkgo'
                                  return contains_ginkgo_import
                                else
                                  return !contains_ginkgo_import
                                endif
                              endif

FUNCTION  <SNR>4_lod()
Called 1 time
Total time:   0.107956
 Self time:   0.000405

count  total (s)   self (s)
    3              0.000007   for name in a:names
    2   0.000079   0.000055     call s:remove_triggers(name)
    2              0.000020     let s:loaded[name] = 1
    2              0.000011   endfor
    1   0.009371   0.000070   call s:reorg_rtp()
                            
    3              0.000007   for name in a:names
    2   0.000185   0.000017     let rtp = s:rtp(g:plugs[name])
    6              0.000010     for dir in a:types
    4   0.002284   0.000053       call s:source(rtp, dir.'/**/*.vim')
    4              0.000003     endfor
    2              0.000002     if a:0
    2   0.095716   0.000022       if !s:source(rtp, a:1) && !empty(s:glob(rtp, a:2))
                                    execute 'runtime' a:1
                                  endif
    2   0.000120   0.000015       call s:source(rtp, a:2)
    2              0.000002     endif
    2   0.000103   0.000075     call s:doautocmd('User', name)
    2              0.000001   endfor

FUNCTION  neosnippet#helpers#vim2json()
Called 1 time
Total time:   0.000320
 Self time:   0.000320

count  total (s)   self (s)
    1              0.000318   return has('patch-7.4.1498') ? json_encode(a:expr) : string(a:expr)

FUNCTION  deoplete#util#get_input()
Called 109 times
Total time:   0.012536
 Self time:   0.012536

count  total (s)   self (s)
  109              0.000522   let mode = mode()
  109              0.000257   if a:event ==# 'InsertEnter'
   23              0.000053     let mode = 'i'
   23              0.000028   endif
  109              0.009969   let input = (mode ==# 'i' ? (col('.')-1) : col('.')) >= len(getline('.')) ?      getline('.') :      matchstr(getline('.'),         '^.*\%' . (mode ==# 'i' ? col('.') : col('.') - 1)         . 'c' . (mode ==# 'i' ? '' : '.'))
                            
  109              0.000518   if a:event ==# 'InsertCharPre'
                                let input .= v:char
                              endif
                            
  109              0.000201   return input

FUNCTION  <SNR>185_IsHeaderFile()
Called 608 times
Total time:   0.009165
 Self time:   0.009165

count  total (s)   self (s)
  608              0.008771     return a:filename =~? '\v\.(h|hpp)$'

FUNCTION  <SNR>172_AllowedToCompleteInBuffer()
Called 652 times
Total time:   0.002286
 Self time:   0.002286

count  total (s)   self (s)
  652              0.001746   return 1
                              let buffer_filetype = getbufvar( a:buffer, '&filetype' )
                            
                              if empty( buffer_filetype ) || getbufvar( a:buffer, '&buftype' ) ==# 'nofile' || buffer_filetype ==# 'qf'
                                return 0
                              endif
                            
                              if s:DisableOnLargeFile( a:buffer )
                                return 0
                              endif
                            
                              let whitelist_allows = has_key( g:ycm_filetype_whitelist, '*' ) || has_key( g:ycm_filetype_whitelist, buffer_filetype )
                              let blacklist_allows = !has_key( g:ycm_filetype_blacklist, buffer_filetype )
                            
                              let allowed = whitelist_allows && blacklist_allows
                              if allowed
                                let s:previous_allowed_buffer_number = bufnr( a:buffer )
                              endif
                              return allowed

FUNCTION  <SNR>232_MarkdownSetupFolding()
Called 2 times
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
    2              0.000007     if !get(g:, "vim_markdown_folding_disabled", 0)
    2              0.000005         if get(g:, "vim_markdown_folding_style_pythonic", 0)
                                        if get(g:, "vim_markdown_override_foldtext", 1)
                                            setlocal foldtext=Foldtext_markdown()
                                        endif
                                    endif
    2              0.000013         setlocal foldexpr=Foldexpr_markdown(v:lnum)
    2              0.000007         setlocal foldmethod=expr
    2              0.000001     endif

FUNCTION  fugitive#CommonDir()
Called 5 times
Total time:   0.000280
 Self time:   0.000280

count  total (s)   self (s)
    5              0.000040   if empty(a:dir)
                                return ''
                              endif
    5              0.000047   if !has_key(s:commondirs, a:dir)
    1              0.000024     if getfsize(a:dir . '/HEAD') < 10
                                  let s:commondirs[a:dir] = ''
                                elseif filereadable(a:dir . '/commondir')
                                  let cdir = get(readfile(a:dir . '/commondir', 1), 0, '')
                                  if cdir =~# '^/\|^\a:/'
                                    let s:commondirs[a:dir] = s:Slash(FugitiveVimPath(cdir))
                                  else
                                    let s:commondirs[a:dir] = simplify(a:dir . '/' . cdir)
                                  endif
                                else
    1              0.000003       let s:commondirs[a:dir] = a:dir
    1              0.000001     endif
    1              0.000000   endif
    5              0.000015   return s:commondirs[a:dir]

FUNCTION  <SNR>172_AllowedToCompleteInCurrentBuffer()
Called 641 times
Total time:   0.010982
 Self time:   0.008765

count  total (s)   self (s)
  641   0.010291   0.008074   return s:AllowedToCompleteInBuffer( '%' )

FUNCTION  FugitiveCommonDir()
Called 5 times
Total time:   0.001087
 Self time:   0.000410

count  total (s)   self (s)
    5   0.000542   0.000145   let dir = FugitiveGitDir(a:0 ? a:1 : -1)
    5              0.000079   if empty(dir)
                                return ''
                              endif
    5   0.000428   0.000148   return fugitive#CommonDir(dir)

FUNCTION  sy#util#escape()
Called 6 times
Total time:   0.000131
 Self time:   0.000131

count  total (s)   self (s)
    6              0.000025   if exists('+shellslash')
                                let old_ssl = &shellslash
                                if fnamemodify(&shell, ':t') == 'cmd.exe'
                                  set noshellslash
                                else
                                  set shellslash
                                endif
                              endif
                            
    6              0.000025   let path = shellescape(a:path)
                            
    6              0.000012   if exists('old_ssl')
                                let &shellslash = old_ssl
                              endif
                            
    6              0.000007   return path

FUNCTION  neomru#_save()
Called 1 time
Total time:   0.050567
 Self time:   0.000204

count  total (s)   self (s)
    1              0.000038   let opts = a:0 >= 1 && type(a:1) == type({}) ? a:1 : {}
                            
    3              0.000049   for m in values(s:MRUs)
    2   0.050442   0.000080     call m.save(opts)
    2              0.000014   endfor

FUNCTION  <SNR>151_mb_str_part()
Called 392 times
Total time:   0.002475
 Self time:   0.002475

count  total (s)   self (s)
  392              0.002197     return strcharpart(a:mb_string, a:start, a:len)

FUNCTION  deoplete#util#vimoption2python()
Called 2 times
Total time:   0.001356
 Self time:   0.000035

count  total (s)   self (s)
    2   0.001354   0.000033   return '[\w' . s:vimoption2python(a:option) . ']'

FUNCTION  ale#linter#GetCommand()
Called 23 times
Total time:   0.006108
 Self time:   0.000599

count  total (s)   self (s)
   23              0.000251     let l:Command = has_key(a:linter, 'command_callback')   ? function(a:linter.command_callback)   : a:linter.command
                            
   23   0.005800   0.000291     return type(l:Command) is v:t_func   ? l:Command(a:buffer)   : l:Command

FUNCTION  <SNR>198_is_beginning_of_line()
Called 8 times
Total time:   0.001428
 Self time:   0.001428

count  total (s)   self (s)
    8              0.000100   let keyword_pattern = '\S\+'
    8              0.001087   let cur_keyword_str = matchstr(a:cur_text, keyword_pattern.'$')
    8              0.000096   let line_part = a:cur_text[: -1-len(cur_keyword_str)]
    8              0.000083   let prev_word_end = matchend(line_part, keyword_pattern)
                            
    8              0.000019   return prev_word_end <= 0

FUNCTION  lightline#mode()
Called 2312 times
Total time:   0.027345
 Self time:   0.027345

count  total (s)   self (s)
 2312              0.024536   return get(s:lightline.mode_map, mode(), '')

FUNCTION  xray#settings#GetAllowedFiletypes()
Called 5735 times
Total time:   0.058547
 Self time:   0.058547

count  total (s)   self (s)
 5735              0.051753   return get(g:, 'xray_allowed_filetypes', [])

FUNCTION  <lambda>43()
Called 1 time
Total time:   0.002299
 Self time:   0.000024

count  total (s)   self (s)
    1   0.002298   0.000023 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <SNR>232_is_mkdCode()
Called 116 times
Total time:   0.310297
 Self time:   0.310297

count  total (s)   self (s)
  116              0.305612     let name = synIDattr(synID(a:lnum, 1, 0), 'name')
  116              0.004462     return (name =~ '^mkd\%(Code$\|Snippet\)' || name != '' && name !~ '^\%(mkd\|html\)')

FUNCTION  deoplete#custom#_update_cache()
Called 91 times
Total time:   0.015783
 Self time:   0.013970

count  total (s)   self (s)
   91              0.000512   if !exists('s:custom')
                                call deoplete#custom#_init()
                              endif
                            
   91   0.002634   0.000821   let custom_buffer = deoplete#custom#_get_buffer()
                            
   91              0.002647   let s:cached.option = copy(s:custom.option)
   91              0.000474   let s:cached.buffer_option = copy(custom_buffer.option)
   91              0.000974   call extend(s:cached.option, s:cached.buffer_option)
                            
   91              0.000567   let s:cached.source_vars = {}
  273              0.001328   for [name, source] in items(s:custom.source)
  182              0.001165     let s:cached.source_vars[name] = get(source, 'vars', {})
  182              0.000467   endfor
   91              0.000538   for [name, vars] in items(custom_buffer.source_vars)
                                if !has_key(s:cached.source_vars, name)
                                  let s:cached.source_vars[name] = {}
                                endif
                                call extend(s:cached.source_vars[name], vars)
                              endfor
   91              0.000230   let s:cached.filter = {}
   91              0.000371   for [name, vars] in items(s:custom.filter)
                                let s:cached.filter[name] = vars
                              endfor
   91              0.000393   for [name, vars] in items(custom_buffer.filter)
                                if !has_key(s:cached.filter, name)
                                  let s:cached.filter[name] = {}
                                endif
                                call extend(s:cached.filter[name], vars)
                              endfor

FUNCTION  neosnippet#util#get_cur_text()
Called 11 times
Total time:   0.001484
 Self time:   0.001484

count  total (s)   self (s)
   11              0.001433   return (mode() ==# 'i' ? (col('.')-1) : col('.')) >= len(getline('.')) ?      getline('.') :      matchstr(getline('.'),         '^.*\%' . col('.') . 'c' . (mode() ==# 'i' ? '' : '.'))

FUNCTION  <SNR>161_ApplyExtracted()
Called 8 times
Total time:   0.009637
 Self time:   0.008560

count  total (s)   self (s)
                              " Update cache when new data comes.
    8              0.000064   let s:cache = get(s:, 'cache', {})
    8              0.000044   let s:cache[s:fpath] = s:data
    8              0.000327   let s:cache.ftime = getftime(s:fpath)
    8              0.000032   let s:cache.bufnr = bufnr('')
                            
    8   0.008206   0.007809   let [s:reload_only, s:should_display] = vista#renderer#LSPProcess(s:data, s:reload_only, s:should_display)
                            
    8              0.000027   if exists('s:jodid')
    6              0.000025     unlet s:jodid
    6              0.000006   endif
                            
    8   0.000855   0.000176   call s:DeleteTemp()

FUNCTION  <SNR>219_parse_options()
Called 1 time
Total time:   0.002489
 Self time:   0.002172

count  total (s)   self (s)
    1              0.000004   let args = []
    1              0.000003   let options = {}
                            
                              " Eval
    1              0.000097   let cmdline = (a:cmdline =~# '\\\@<!`.*\\\@<!`') ? s:eval_cmdline(a:cmdline) : a:cmdline
                            
    6   0.001048   0.001023   for s in split(cmdline, s:re_unquoted_match('\%(\\\@<!\s\)\+'))
    5              0.000038     let arg = substitute(s, '\\\( \)', '\1', 'g')
    5              0.000100     let arg_key = substitute(arg, '=\zs.*$', '', '')
                            
    5              0.000041     let name = substitute(tr(arg_key, '-', '_'), '=$', '', '')[1:]
    5              0.000018     if name =~# '^no_'
                                  let name = name[3:]
                                  let value = v:false
                                else
    5   0.000157   0.000133       let value = (arg_key =~# '=$') ? s:remove_quote_pairs(arg[len(arg_key) :]) : v:true
    5              0.000006     endif
                            
    5   0.000784   0.000516     if index(keys(denite#init#_user_options()) + keys(denite#init#_deprecated_options()), name) >= 0
    2              0.000007       let options[name] = value
    2              0.000001     else
    3              0.000013       call add(args, arg)
    3              0.000002     endif
    5              0.000004   endfor
                            
    1              0.000002   return [args, options]

FUNCTION  <lambda>49()
Called 1 time
Total time:   0.000031
 Self time:   0.000018

count  total (s)   self (s)
    1   0.000030   0.000018 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <SNR>172_OnFileTypeSet()
Called 6 times
Total time:   0.082526
 Self time:   0.035669

count  total (s)   self (s)
    6   0.000080   0.000033   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
    6   0.000204   0.000027   call s:SetUpCompleteopt()
    6   0.000064   0.000025   call s:SetCompleteFunc()
    6   0.000096   0.000025   call s:StartMessagePoll()
                            
    6              0.035392   exec s:python_command "ycm_state.OnBufferVisit()"
    6   0.046663   0.000141   call s:OnFileReadyToParse( 1 )

FUNCTION  WebDevIconsGetFileTypeSymbol()
Called 316 times
Total time:   0.357389
 Self time:   0.353235

count  total (s)   self (s)
  316              0.000955   if a:0 == 0
                                let fileNodeExtension = expand('%:e')
                                let fileNode = expand('%:t')
                                let isDirectory = 0
                              else
  316              0.001564     let fileNodeExtension = fnamemodify(a:1, ':e')
  316              0.001285     let fileNode = fnamemodify(a:1, ':t')
  316              0.001296     if a:0 > 1
  316              0.000724       let isDirectory = a:2
  316              0.000239     else
                                  let isDirectory = 0
                                endif
  316              0.000180   endif
                            
  316              0.000700   if isDirectory == 0 || g:DevIconsEnableFolderPatternMatching
                            
  316              0.001179     let symbol = g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
  316              0.001481     let fileNodeExtension = tolower(fileNodeExtension)
  316              0.002165     let fileNode = tolower(fileNode)
                            
 3160              0.019753     for [pattern, glyph] in items(g:WebDevIconsUnicodeDecorateFileNodesPatternSymbols)
 2844              0.249583       if match(fileNode, pattern) != -1
                                    let symbol = glyph
                                    break
                                  endif
 2844              0.020595     endfor
                            
  316              0.001534     if symbol == g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol
  316              0.001986       if has_key(g:WebDevIconsUnicodeDecorateFileNodesExactSymbols, fileNode)
                                    let symbol = g:WebDevIconsUnicodeDecorateFileNodesExactSymbols[fileNode]
                                  elseif ((isDirectory == 1 && g:DevIconsEnableFolderExtensionPatternMatching) || isDirectory == 0) && has_key(g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols, fileNodeExtension)
  264              0.001203         let symbol = g:WebDevIconsUnicodeDecorateFileNodesExtensionSymbols[fileNodeExtension]
  264              0.000374       elseif isDirectory == 1
                                    let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
                                  endif
  316              0.000188     endif
                            
  316              0.000198   else
                                let symbol = g:WebDevIconsUnicodeDecorateFolderNodesDefaultSymbol
                              endif
                            
  316   0.009052   0.004898   let artifactFix = s:DevIconsGetArtifactFix()
                            
  316              0.001883   return symbol . artifactFix
                            

FUNCTION  lightline#tabline()
Called 14 times
Total time:   0.605756
 Self time:   0.001208

count  total (s)   self (s)
   14              0.000182   if !has_key(s:highlight, 'tabline')
                                call lightline#highlight('tabline')
                              endif
   14              0.000105   if s:lightline.tabline_configured || s:tabnr != tabpagenr() || s:tabcnt != tabpagenr('$')
   14              0.000099     let s:tabnr = tabpagenr()
   14              0.000051     let s:tabcnt = tabpagenr('$')
   14   0.605084   0.000536     let s:tabline = s:line(1, 0)
   14              0.000015   endif
   14              0.000029   return s:tabline

FUNCTION  <SNR>187_GroupCmd()
Called 33 times
Total time:   0.000353
 Self time:   0.000353

count  total (s)   self (s)
   33              0.000098     if s:supports_sign_groups
                                    return ' group=ale '
                                else
   33              0.000040         return ' '
                                endif

FUNCTION  sy#highlight#line_disable()
Called 9 times
Total time:   0.001311
 Self time:   0.001311

count  total (s)   self (s)
    9              0.000548   execute 'sign define SignifyAdd text='. s:sign_add 'texthl=SignifySignAdd linehl='
    9              0.000410   execute 'sign define SignifyChange text='. s:sign_change 'texthl=SignifySignChange linehl='
    9              0.000273   execute 'sign define SignifyRemoveFirstLine text='. s:sign_delete_first_line 'texthl=SignifySignDeleteFirstLine linehl='
    9              0.000040   let g:signify_line_highlight = 0

FUNCTION  neosnippet#variables#snippets_dir()
Called 1 time
Total time:   0.000060
 Self time:   0.000049

count  total (s)   self (s)
                              " Set snippets_dir.
    1   0.000056   0.000044   let snippets_dir = map(neosnippet#util#option2list(   g:neosnippet#snippets_directory), 'neosnippet#util#expand(v:val)')
    1              0.000002   return map(snippets_dir, 'substitute(v:val, "[\\\\/]$", "", "")')

FUNCTION  <SNR>261_all()
Called 3 times
Total time:   0.000144
 Self time:   0.000091

count  total (s)   self (s)
    3              0.000006   let all = []
    3   0.000100   0.000046   for key in s:roots()
                                for value in b:projectionist[key]
                                  call add(all, [key, value])
                                endfor
                              endfor
    3              0.000004   return all

FUNCTION  xray#list#AreXrayListOptionsConfigured()
Called 5735 times
Total time:   0.118597
 Self time:   0.118597

count  total (s)   self (s)
 5735              0.070588   if &l:list == 1 && &l:listchars != get(b:, 'original_listchars', &l:listchars)
    5              0.000022     return v:true
                              endif
                            
 5730              0.009523   return v:false

FUNCTION  ale#sign#ParsePattern()
Called 17 times
Total time:   0.000743
 Self time:   0.000743

count  total (s)   self (s)
   17              0.000077     if s:supports_sign_groups
                                    " Matches output like :
                                    " line=4  id=1  group=ale  name=ALEErrorSign
                                    " ÑÑ‚Ñ€Ð¾ÐºÐ°=1  id=1000001  Ð³Ñ€ÑƒÐ¿Ð¿Ð°=ale  Ð¸Ð¼Ñ=ALEErrorSign
                                    " è¡Œ=1  è­˜åˆ¥å­=1000001  ã‚°ãƒ«ãƒ¼ãƒ—=ale  åå‰=ALEWarningSign
                                    " lÃ­nea=12 id=1000001 grupo=ale  nombre=ALEWarningSign
                                    " riga=1 id=1000001  gruppo=ale   nome=ALEWarningSign
                                    " Zeile=235  id=1000001 Gruppe=ale  Name=ALEErrorSign
                                    let l:pattern = '\v^.*\=(\d+).*\=(\d+).*\=ale>.*\=(ALE[a-zA-Z]+Sign)'
                                else
                                    " Matches output like :
                                    " line=4  id=1  name=ALEErrorSign
                                    " ÑÑ‚Ñ€Ð¾ÐºÐ°=1  id=1000001  Ð¸Ð¼Ñ=ALEErrorSign
                                    " è¡Œ=1  è­˜åˆ¥å­=1000001  åå‰=ALEWarningSign
                                    " lÃ­nea=12 id=1000001 nombre=ALEWarningSign
                                    " riga=1 id=1000001  nome=ALEWarningSign
                                    " Zeile=235  id=1000001  Name=ALEErrorSign
   17              0.000064         let l:pattern = '\v^.*\=(\d+).*\=(\d+).*\=(ALE[a-zA-Z]+Sign)'
   17              0.000016     endif
                            
   17              0.000159     return l:pattern

FUNCTION  <SNR>137_Dir()
Called 7 times
Total time:   0.000501
 Self time:   0.000136

count  total (s)   self (s)
    7   0.000467   0.000102   return a:0 ? FugitiveGitDir(a:1) : FugitiveGitDir()

FUNCTION  neosnippet#helpers#get_snippets_directory()
Called 1 time
Total time:   0.001003
 Self time:   0.000159

count  total (s)   self (s)
    1   0.000031   0.000009   let filetype = get(a:000, 0, neosnippet#helpers#get_filetype())
    1              0.000001   let snippets_dir = []
    1              0.000005   if !get(g:neosnippet#disable_runtime_snippets, filetype, get(g:neosnippet#disable_runtime_snippets, '_', 0))
    1   0.000822   0.000060     let snippets_dir += neosnippet#variables#runtime_dir()
    1              0.000001   endif
    1   0.000140   0.000080   let snippets_dir += copy(neosnippet#variables#snippets_dir())
                            
    1              0.000001   return snippets_dir

FUNCTION  denite#start()
Called 1 time
Total time:   0.399265
 Self time:   0.000112

count  total (s)   self (s)
    1              0.000008   call inputsave()
    1              0.000001   try
    1              0.000006     let user_context = get(a:000, 0, {})
    1   0.399233   0.000080     return s:start(a:sources, user_context)
                              finally
    1              0.000007     call inputrestore()
    1              0.000001   endtry

FUNCTION  <SNR>172_VisitedBufferRequiresReparse()
Called 8 times
Total time:   0.000377
 Self time:   0.000238

count  total (s)   self (s)
    8              0.000087   if bufnr( '%' ) ==# s:previous_allowed_buffer_number
                                return 0
                              endif
                            
    8   0.000247   0.000108   return s:AllowedToCompleteInCurrentBuffer()

FUNCTION  lightline#buffer#bufferinfo()
Called 14 times
Total time:   0.143879
 Self time:   0.000478

count  total (s)   self (s)
   14   0.143754   0.000353   call lightline#buffer#bufferline()
   14              0.000072   if exists('g:lightline_buffer_status_info.info')
   14              0.000031     return g:lightline_buffer_status_info.info
                              endif
                              return ''

FUNCTION  <SNR>139_fnamemodify()
Called 36 times
Total time:   0.001459
 Self time:   0.001245

count  total (s)   self (s)
   36   0.001395   0.001181   return s:substitute_path_separator(fnamemodify(a:fname, a:mods))

FUNCTION  neomru#_append()
Called 19 times
Total time:   0.090374
 Self time:   0.000987

count  total (s)   self (s)
   19              0.000326   if &l:buftype =~ 'help\|nofile' || &l:previewwindow
    1              0.000001     return
                              endif
   18   0.089876   0.000489   call neomru#append(s:expand('%:p'))

FUNCTION  <SNR>189_highlight_range()
Called 1212 times
Total time:   0.136206
 Self time:   0.031738

count  total (s)   self (s)
                                " Set all of the positions, which are chunked into Lists which
                                " are as large as will be accepted by matchaddpos.
 1212   0.133626   0.029159     call map(   ale#highlight#CreatePositions(       a:range.lnum,       a:range.col,       a:range.end_lnum,       a:range.end_col   ),   's:matchaddpos(a:group, v:val)')

FUNCTION  <SNR>172_OnBlankLine()
Called 20 times
Total time:   0.022734
 Self time:   0.000434

count  total (s)   self (s)
   20   0.022696   0.000396   return s:Pyeval( 'not vim.current.line or vim.current.line.isspace()' )

FUNCTION  denite#init#_initialize()
Called 1 time
Total time:   0.000086
 Self time:   0.000076

count  total (s)   self (s)
    1   0.000084   0.000075   if denite#init#_check_channel()
    1              0.000001     return
                              endif
                            
                              augroup denite
                                autocmd!
                              augroup END
                            
                              if !has('python3')
                                call denite#util#print_error( 'denite.nvim does not work with this version.')
                                call denite#util#print_error( 'It requires Neovim with Python3 support("+python3").')
                                return 1
                              endif
                            
                              if has('nvim') && !has('nvim-0.3.0')
                                call denite#util#print_error('denite.nvim requires nvim +v0.3.0.')
                                return 1
                              endif
                              if !has('nvim') && v:version < 800
                                call denite#util#print_error('denite.nvim requires Vim 8.0+.')
                                return 1
                              endif
                            
                              try
                                if denite#util#has_yarp()
                                  let g:denite#_yarp = yarp#py3('denite')
                                  call g:denite#_yarp.request('_denite_init')
                                  let g:denite#_channel_id = 1
                                else
                                  " rplugin.vim may not be loaded on VimEnter
                                  if !exists('g:loaded_remote_plugins')
                                    runtime! plugin/rplugin.vim
                                  endif
                                  call _denite_init()
                                endif
                                call s:initialize_variables()
                              catch
                                call denite#util#print_error(v:exception)
                                call denite#util#print_error(v:throwpoint)
                            
                                if denite#util#has_yarp()
                                  if !has('nvim') && !exists('*neovim_rpc#serveraddr')
                                    call denite#util#print_error( 'denite requires vim-hug-neovim-rpc plugin in Vim.')
                                  endif
                            
                                  if !exists('*yarp#py3')
                                    call denite#util#print_error( 'denite requires nvim-yarp plugin.')
                                  endif
                                else
                                  call denite#util#print_error( 'denite failed to load. ' .'Try the :UpdateRemotePlugins command and restart Neovim. ' .'See also :checkhealth.')
                                endif
                                return 1
                              endtry

FUNCTION  ale#events#SaveEvent()
Called 3 times
Total time:   0.015149
 Self time:   0.000445

count  total (s)   self (s)
    3   0.000281   0.000106     let l:should_lint = ale#Var(a:buffer, 'enabled') && g:ale_lint_on_save
                            
    3              0.000018     if l:should_lint
    3              0.000041         call setbufvar(a:buffer, 'ale_save_event_fired', 1)
    3              0.000007     endif
                            
    3   0.000141   0.000052     if ale#Var(a:buffer, 'fix_on_save') && !ale#events#QuitRecently(a:buffer)
                                    let l:will_fix = ale#fix#Fix(a:buffer, 'save_file')
                                    let l:should_lint = l:should_lint && !l:will_fix
                                endif
                            
    3   0.000203   0.000071     if l:should_lint && !ale#events#QuitRecently(a:buffer)
    2   0.014378   0.000069         call ale#Queue(0, 'lint_file', a:buffer)
    2              0.000001     endif

FUNCTION  <SNR>4_rtp()
Called 71 times
Total time:   0.006571
 Self time:   0.000789

count  total (s)   self (s)
   71   0.006546   0.000763     return s:dirpath(a:spec.dir . get(a:spec, 'rtp', ''))

FUNCTION  sy#sign#id_next()
Called 25 times
Total time:   0.000224
 Self time:   0.000224

count  total (s)   self (s)
   25              0.000111   let id = a:sy.signid
   25              0.000049   let a:sy.signid += 1
   25              0.000035   return id

FUNCTION  <SNR>135_SkipSendingMessage()
Called 512 times
Total time:   0.015722
 Self time:   0.015722

count  total (s)   self (s)
  512              0.008375     if expand('%') =~# '^jdt://'
                                    return v:false
                                endif
                            
  512              0.004311     return &buftype !=# '' || &filetype ==# '' || expand('%') ==# ''

FUNCTION  <SNR>139_is_directory_exist()
Called 18 times
Total time:   0.003941
 Self time:   0.003941

count  total (s)   self (s)
   18              0.003214   let ignore = !empty(g:neomru#directory_mru_ignore_pattern) && a:path =~ g:neomru#directory_mru_ignore_pattern
   18              0.000702   return !ignore && (isdirectory(a:path) || a:path =~ '^\h\w\+:')

FUNCTION  <SNR>172_IdentifierFinishedOperations()
Called 69 times
Total time:   0.132318
 Self time:   0.031625

count  total (s)   self (s)
   69   0.101614   0.000922   if !s:Pyeval( 'base.CurrentIdentifierFinished()' )
   63              0.000254     return
                              endif
    6              0.030193   exec s:python_command "ycm_state.OnCurrentIdentifierFinished()"
    6              0.000059   let s:force_semantic = 0
    6              0.000042   let s:completion = s:default_completion

FUNCTION  test#javascript#mocha#test_file()
Called 6 times
Total time:   0.000216
 Self time:   0.000216

count  total (s)   self (s)
    6              0.000171   return a:file =~# g:test#javascript#mocha#file_pattern && test#javascript#has_package('mocha')

FUNCTION  <SNR>145_RunLinter()
Called 23 times
Total time:   0.162259
 Self time:   0.002590

count  total (s)   self (s)
   23              0.000151     if !empty(a:linter.lsp)
                                    return ale#lsp_linter#CheckWithLSP(a:buffer, a:linter)
                                else
   23   0.002728   0.000613         let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
   23   0.158809   0.001253         return s:RunIfExecutable(a:buffer, a:linter, l:executable)
                                endif
                            
                                return 0

FUNCTION  denite#util#convert2list()
Called 2 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    2              0.000018   return type(a:expr) ==# v:t_list ? a:expr : [a:expr]

FUNCTION  ale#engine#FixLocList()
Called 17 times
Total time:   0.079611
 Self time:   0.058210

count  total (s)   self (s)
   17              0.000250     let l:bufnr_map = {}
   17              0.000033     let l:new_loclist = []
                            
                                " Some errors have line numbers beyond the end of the file,
                                " so we need to adjust them so they set the error at the last line
                                " of the file instead.
   17   0.000944   0.000167     let l:last_line_number = ale#util#GetLineCount(a:buffer)
                            
  625              0.000699     for l:old_item in a:loclist
                                    " Copy the loclist item with some default values and corrections.
                                    "
                                    " line and column numbers will be converted to numbers.
                                    " The buffer will default to the buffer being checked.
                                    " The vcol setting will default to 0, a byte index.
                                    " The error type will default to 'E' for errors.
                                    " The error number will default to -1.
                                    "
                                    " The line number and text are the only required keys.
                                    "
                                    " The linter_name will be set on the errors so it can be used in
                                    " output, filtering, etc..
  608              0.008095         let l:item = {   'bufnr': a:buffer,   'text': l:old_item.text,   'lnum': str2nr(l:old_item.lnum),   'col': str2nr(get(l:old_item, 'col', 0)),   'vcol': 0,   'type': get(l:old_item, 'type', 'E'),   'nr': get(l:old_item, 'nr', -1),   'linter_name': a:linter_name,}
                            
  608              0.000658         if a:from_other_source
                                        let l:item.from_other_source = 1
                                    endif
                            
  608              0.001126         if has_key(l:old_item, 'code')
                                        let l:item.code = l:old_item.code
                                    endif
                            
  608   0.023804   0.003625         if has_key(l:old_item, 'filename')&& !ale#path#IsTempName(l:old_item.filename)
                                        " Use the filename given.
                                        " Temporary files are assumed to be for this buffer,
                                        " and the filename is not included then, because it looks bad
                                        " in the loclist window.
                                        let l:filename = l:old_item.filename
                                        let l:item.filename = l:filename
                            
                                        if has_key(l:old_item, 'bufnr')
                                            " If a buffer number is also given, include that too.
                                            " If Vim detects that he buffer number is valid, it will
                                            " be used instead of the filename.
                                            let l:item.bufnr = l:old_item.bufnr
                                        elseif has_key(l:bufnr_map, l:filename)
                                            " Get the buffer number from the map, which can be faster.
                                            let l:item.bufnr = l:bufnr_map[l:filename]
                                        else
                                            " Look up the buffer number.
                                            let l:item.bufnr = bufnr(l:filename)
                                            let l:bufnr_map[l:filename] = l:item.bufnr
                                        endif
                                    elseif has_key(l:old_item, 'bufnr')
                                        let l:item.bufnr = l:old_item.bufnr
                                    endif
                            
  608              0.001129         if has_key(l:old_item, 'detail')
                                        let l:item.detail = l:old_item.detail
                                    endif
                            
                                    " Pass on a end_col key if set, used for highlights.
  608              0.001109         if has_key(l:old_item, 'end_col')
    1              0.000003             let l:item.end_col = str2nr(l:old_item.end_col)
    1              0.000001         endif
                            
  608              0.001072         if has_key(l:old_item, 'end_lnum')
                                        let l:item.end_lnum = str2nr(l:old_item.end_lnum)
                                    endif
                            
  608              0.001070         if has_key(l:old_item, 'sub_type')
                                        let l:item.sub_type = l:old_item.sub_type
                                    endif
                            
  608              0.000611         if l:item.lnum < 1
                                        " When errors appear before line 1, put them at line 1.
                                        let l:item.lnum = 1
                                    elseif l:item.bufnr == a:buffer && l:item.lnum > l:last_line_number
                                        " When errors go beyond the end of the file, put them at the end.
                                        " This is only done for the current buffer.
                                        let l:item.lnum = l:last_line_number
                                    elseif get(l:old_item, 'vcol', 0)
                                        " Convert virtual column positions to byte positions.
                                        " The positions will be off if the buffer has changed recently.
                                        let l:line = getbufline(a:buffer, l:item.lnum)[0]
                            
                                        let l:item.col = ale#util#Col(l:line, l:item.col)
                            
                                        if has_key(l:item, 'end_col')
                                            let l:end_line = get(l:item, 'end_lnum', l:line) != l:line   ? getbufline(a:buffer, l:item.end_lnum)[0]   : l:line
                            
                                            let l:item.end_col = ale#util#Col(l:end_line, l:item.end_col)
                                        endif
                                    endif
                            
  608              0.001443         call add(l:new_loclist, l:item)
  608              0.000371     endfor
                            
   17   0.000662   0.000217     let l:type_map = get(ale#Var(a:buffer, 'type_map'), a:linter_name, {})
                            
   17              0.000041     if !empty(l:type_map)
                                    call s:RemapItemTypes(l:type_map, l:new_loclist)
                                endif
                            
   17              0.000021     return l:new_loclist

FUNCTION  deoplete#send_event()
Called 13 times
Total time:   0.007415
 Self time:   0.004950

count  total (s)   self (s)
   13   0.003092   0.002898   let sources = deoplete#util#convert2list(get(a:000, 0, []))
   13   0.004259   0.001989   call deoplete#util#rpcnotify('deoplete_on_event', {'event': a:event, 'sources': sources})

FUNCTION  LanguageClient#handleCompleteDone()
Called 14 times
Total time:   0.000483
 Self time:   0.000483

count  total (s)   self (s)
   14              0.000260     let user_data = get(v:completed_item, 'user_data', '')
   14              0.000137     if user_data ==# ''
   14              0.000035         return
                                endif
                            
                                try
                                    call LanguageClient#Notify('languageClient/handleCompleteDone', { 'filename': LSP#filename(), 'completed_item': v:completed_item, 'line': LSP#line(), 'character': LSP#character(), })
                                catch
                                    call s:Debug('LanguageClient caught exception: ' . string(v:exception))
                                endtry

FUNCTION  LanguageClient#handleCursorMoved()
Called 488 times
Total time:   0.273231
 Self time:   0.057278

count  total (s)   self (s)
  488              0.011439     let l:cursor_line = getcurpos()[1] - 1
  488              0.003425     if l:cursor_line == s:last_cursor_line
   70              0.000115         return
                                endif
  418              0.002056     let s:last_cursor_line = l:cursor_line
                            
  418              0.000951     try
  418   0.244530   0.028577         call LanguageClient#Notify('languageClient/handleCursorMoved', { 'buftype': &buftype, 'filename': LSP#filename(), 'position': LSP#position(), 'viewport': LSP#viewport(), })
  418              0.000992     catch
                                    call s:Debug('LanguageClient caught exception: ' . string(v:exception))
                                endtry

FUNCTION  <SNR>151_shorten_name()
Called 236 times
Total time:   0.010646
 Self time:   0.008498

count  total (s)   self (s)
  236              0.002774   if a:oldlen <= a:newlen
   72              0.000139     return a:name
                              endif
                            
  164   0.006800   0.004652   return s:mb_str_part(a:name, 0, a:newlen - g:lightline_buffer_ellipsis_icon_len - a:extlen) . g:lightline_buffer_ellipsis_icon . s:mb_str_part(a:name, a:oldlen - a:extlen, a:extlen)

FUNCTION  <SNR>146_TemporaryFilename()
Called 23 times
Total time:   0.001897
 Self time:   0.001023

count  total (s)   self (s)
   23              0.000219     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
   23              0.000071     if empty(l:filename)
                                    " If the buffer's filename is empty, create a dummy filename.
                                    let l:ft = getbufvar(a:buffer, '&filetype')
                                    let l:filename = 'file' . ale#filetypes#GuessExtension(l:ft)
                                endif
                            
                                " Create a temporary filename, <temp_dir>/<original_basename>
                                " The file itself will not be created by this function.
   23   0.001338   0.000465     return ale#util#Tempname() . (has('win32') ? '\' : '/') . l:filename

FUNCTION  LanguageClient#handleVimLeavePre()
Called 1 time
Total time:   0.000936
 Self time:   0.000601

count  total (s)   self (s)
    1              0.000006     try
    1              0.000018         if get(g:, 'LanguageClient_autoStop', 1)
    1   0.000876   0.000541             call LanguageClient#exit()
    1              0.000005         endif
    1              0.000003     catch
                                    call s:Debug('LanguageClient caught exception: ' . string(v:exception))
                                endtry

FUNCTION  ale#util#GetItemPriority()
Called 608 times
Total time:   0.006240
 Self time:   0.006240

count  total (s)   self (s)
  608              0.000835     if a:item.type is# 'I'
                                    return g:ale#util#info_priority
                                endif
                            
  608              0.000740     if a:item.type is# 'W'
  608              0.001404         if get(a:item, 'sub_type', '') is# 'style'
                                        return g:ale#util#style_warning_priority
                                    endif
                            
  608              0.000613         return g:ale#util#warning_priority
                                endif
                            
                                if get(a:item, 'sub_type', '') is# 'style'
                                    return g:ale#util#style_error_priority
                                endif
                            
                                return g:ale#util#error_priority

FUNCTION  <lambda>48()
Called 1 time
Total time:   0.000057
 Self time:   0.000036

count  total (s)   self (s)
    1   0.000056   0.000035 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <SNR>146_GatherOutput()
Called 609 times
Total time:   0.002635
 Self time:   0.002635

count  total (s)   self (s)
  609              0.002352     call add(a:line_list, a:line)

FUNCTION  ale#cursor#TruncatedEcho()
Called 3 times
Total time:   0.006202
 Self time:   0.005968

count  total (s)   self (s)
    3              0.000013     let l:message = a:original_message
                                " Change tabs to spaces.
    3              0.000031     let l:message = substitute(l:message, "\t", ' ', 'g')
                                " Remove any newlines in the message.
    3              0.000020     let l:message = substitute(l:message, "\n", '', 'g')
                            
                                " We need to remember the setting for shortmess and reset it again.
    3              0.000013     let l:shortmess_options = &l:shortmess
                            
    3              0.000004     try
    3              0.000014         let l:cursor_position = getpos('.')
                            
                                    " The message is truncated and saved to the history.
    3              0.000095         silent! setlocal shortmess+=T
                            
    3              0.000004         try
    3   0.005598   0.005364             exec "norm! :echomsg l:message\n"
    3              0.000013         catch /^Vim\%((\a\+)\)\=:E523/
                                        " Fallback into manual truncate (#1987)
                                        let l:winwidth = winwidth(0)
                            
                                        if l:winwidth < strdisplaywidth(l:message)
                                            " Truncate message longer than window width with trailing '...'
                                            let l:message = l:message[:l:winwidth - 4] . '...'
                                        endif
                            
                                        exec 'echomsg l:message'
                                    endtry
                            
                                    " Reset the cursor position if we moved off the end of the line.
                                    " Using :norm and :echomsg can move the cursor off the end of the
                                    " line.
    3              0.000029         if l:cursor_position != getpos('.')
                                        call setpos('.', l:cursor_position)
                                    endif
    3              0.000005     finally
    3              0.000034         let &l:shortmess = l:shortmess_options
    3              0.000004     endtry

FUNCTION  <SNR>161_TempnameBasedOnSourceBufname()
Called 10 times
Total time:   0.001921
 Self time:   0.001487

count  total (s)   self (s)
   10              0.001100   let tempname = sha256(fnamemodify(bufname(t:vista.source.bufnr), ':p'))
   10   0.000795   0.000361   return s:TryAppendExtension(tempname)

FUNCTION  <SNR>187_PriorityCmd()
Called 25 times
Total time:   0.000236
 Self time:   0.000236

count  total (s)   self (s)
   25              0.000074     if s:supports_sign_groups
                                    return ' priority=' . g:ale_sign_priority . ' '
                                else
   25              0.000025         return ''
                                endif

FUNCTION  LanguageClient#handleFileType()
Called 6 times
Total time:   0.002178
 Self time:   0.000371

count  total (s)   self (s)
    6              0.000008     try
    6   0.000266   0.000108         if s:Debounce(2, 'LanguageClient#handleFileType')
    6   0.001839   0.000189             call LanguageClient#Notify('languageClient/handleFileType', { 'filename': LSP#filename(), 'position': LSP#position(), 'viewport': LSP#viewport(), })
    6              0.000007         endif
    6              0.000006     catch
                                    call s:Debug('LanguageClient caught exception: ' . string(v:exception))
                                endtry

FUNCTION  ale#engine#RunLinters()
Called 23 times
Total time:   0.208139
 Self time:   0.014154

count  total (s)   self (s)
                                " Initialise the buffer information if needed.
   23   0.000944   0.000439     let l:new_buffer = ale#engine#InitBufferInfo(a:buffer)
   23   0.006553   0.000448     call s:StopCurrentJobs(a:buffer, a:should_lint_file)
   23   0.006199   0.000566     call s:RemoveProblemsForDisabledLinters(a:buffer, a:linters)
                            
                                " We can only clear the results if we aren't checking the buffer.
   23   0.001029   0.000559     let l:can_clear_results = !ale#engine#IsCheckingBuffer(a:buffer)
                            
   23   0.006578   0.005599     silent doautocmd <nomodeline> User ALELintPre
                            
   46              0.001652     for l:linter in a:linters
                                    " Only run lint_file linters if we should.
   23              0.000091         if !l:linter.lint_file || a:should_lint_file
   23   0.164898   0.002640             if s:RunLinter(a:buffer, l:linter)
                                            " If a single linter ran, we shouldn't clear everything.
   23              0.000154                 let l:can_clear_results = 0
   23              0.000049             endif
   23              0.000024         else
                                        " If we skipped running a lint_file linter still in the list,
                                        " we shouldn't clear everything.
                                        let l:can_clear_results = 0
                                    endif
   23              0.000035     endfor
                            
                                " Clear the results if we can. This needs to be done when linters are
                                " disabled, or ALE itself is disabled.
   23              0.000057     if l:can_clear_results
                                    call ale#engine#SetResults(a:buffer, [])
                                elseif l:new_buffer
    2   0.018163   0.000128         call s:AddProblemsFromOtherBuffers(a:buffer, a:linters)
    2              0.000002     endif

FUNCTION  neosnippet#get_placeholder_marker_pattern()
Called 10 times
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
   10              0.000039   return '<`\d\+\%(:.\{-}\)\?\\\@<!`>'

FUNCTION  LanguageClient#handleBufWritePost()
Called 3 times
Total time:   0.002267
 Self time:   0.000200

count  total (s)   self (s)
    3              0.000011     try
    3   0.002184   0.000118         call LanguageClient#Notify('languageClient/handleBufWritePost', { 'filename': LSP#filename(), })
    3              0.000015     catch
                                    call s:Debug('LanguageClient caught exception: ' . string(v:exception))
                                endtry

FUNCTION  necosyntax#gather_candidates()
Called 11 times
Total time:   0.001465
 Self time:   0.001000

count  total (s)   self (s)
   11              0.000130   let filetype = &filetype
   11              0.000049   if filetype == ''
                                return []
                              endif
                            
   11              0.000079   if !has_key(s:syntax_list, filetype)
   10   0.000330   0.000159     call s:make_cache()
   10              0.000009   endif
                            
   11              0.000022   let list = []
   22   0.000526   0.000232   for ft in s:get_context_filetypes(filetype)
   11              0.000065     let list += get(s:syntax_list, ft, [])
   11              0.000032   endfor
   11              0.000015   return list

FUNCTION  xray#settings#GetTabChars()
Called 2 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    2              0.000010   return get(g:, 'xray_tab_chars', 'â€º ')

FUNCTION  deoplete#mapping#_restore_completeopt()
Called 17 times
Total time:   0.000340
 Self time:   0.000340

count  total (s)   self (s)
   17              0.000163   if exists('g:deoplete#_saved_completeopt')
                                let &completeopt = g:deoplete#_saved_completeopt
                                unlet g:deoplete#_saved_completeopt
                              endif

FUNCTION  <SNR>205_deletefile()
Called 1 time
Total time:   0.009392
 Self time:   0.009198

count  total (s)   self (s)
    1   0.000233   0.000039   let cache_name = s:_encode_name(a:cache_dir, a:filename)
    1              0.009157   return delete(cache_name)

FUNCTION  <SNR>138_analyze_variable_line()
Called 33 times
Total time:   0.008695
 Self time:   0.007730

count  total (s)   self (s)
   33              0.001127   if a:line =~ '\<\%(let\|for\)\s\+\a[[:alnum:]_:]*'
                                " let var = pattern.
   33              0.001489     let word = matchstr(a:line, '\<\%(let\|for\)\s\+\zs\a[[:alnum:]_:]*')
   33              0.001703     let expression = matchstr(a:line, '\<let\s\+\a[[:alnum:]_:]*\s*=\s*\zs.*$')
   33              0.000184     if !has_key(a:keyword_dict, word) 
   18   0.001374   0.000409       let a:keyword_dict[word] = { 'word' : word, 'kind' : s:get_variable_type(expression)}
   18              0.000047     elseif expression != '' && a:keyword_dict[word].kind == ''
                                  " Update kind.
                                  let a:keyword_dict[word].kind = s:get_variable_type(expression)
                                endif
   33              0.000046   elseif a:line =~ '\<\%(let\|for\)\s\+\[.\{-}\]'
                                " let [var1, var2] = pattern.
                                let words = split(matchstr(a:line,'\<\%(let\|for\)\s\+\[\zs.\{-}\ze\]'), '[,[:space:]]\+')
                                  let expressions = split(matchstr(a:line,'\<let\s\+\[.\{-}\]\s*=\s*\[\zs.\{-}\ze\]$'), '[,[:space:];]\+')
                            
                                  let i = 0
                                  while i < len(words)
                                    let expression = get(expressions, i, '')
                                    let word = words[i]
                            
                                    if !has_key(a:keyword_dict, word) 
                                      let a:keyword_dict[word] = { 'word' : word, 'kind' : s:get_variable_type(expression)}
                                    elseif expression != '' && a:keyword_dict[word].kind == ''
                                      " Update kind.
                                      let a:keyword_dict[word].kind = s:get_variable_type(expression)
                                    endif
                            
                                    let i += 1
                                  endwhile
                                elseif a:line =~ '\<fu\%[nction]!\?\s\+'
                                  " Get function arguments.
                                  for arg in split(matchstr(a:line, '^[^(]*(\zs[^)]*'), '\s*,\s*')
                                    let word = 'a:' . (arg == '...' ?  '000' : arg)
                                    let a:keyword_dict[word] = { 'word' : word, 'kind' : (arg == '...' ?  '[]' : '')}
                            
                                  endfor
                                  if a:line =~ '\.\.\.)'
                                    " Extra arguments.
                                    for arg in range(5)
                                      let word = 'a:' . arg
                                      let a:keyword_dict[word] = { 'word' : word, 'kind' : (arg == 0 ?  '0' : '')}
                                    endfor
                                  endif
                                endif

FUNCTION  <SNR>139_writefile()
Called 14 times
Total time:   0.012730
 Self time:   0.012730

count  total (s)   self (s)
   14              0.000444   let path = fnamemodify(a:path, ':p')
   14              0.000287   if !isdirectory(fnamemodify(path, ':h'))
                                call mkdir(fnamemodify(path, ':h'), 'p')
                              endif
                            
   14              0.011875   call writefile(a:list, path)

FUNCTION  deoplete#handler#_check_omnifunc()
Called 1 time
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    1              0.000010   let prev = g:deoplete#_prev_completion
    1              0.000003   let blacklist = ['LanguageClient#complete']
    1              0.000014   if a:context.event ==# 'Manual' || &l:omnifunc ==# '' || index(blacklist, &l:omnifunc) >= 0 || prev.input ==# a:context.input || s:check_input_method()
    1              0.000001     return
                              endif
                            
                              for filetype in a:context.filetypes
                                for pattern in deoplete#util#convert2list( deoplete#custom#_get_filetype_option(   'omni_patterns', filetype, ''))
                                  if pattern !=# '' && a:context.input =~# '\%('.pattern.'\)$'
                                    let g:deoplete#_context.candidates = []
                            
                                    let prev.event = a:context.event
                                    let prev.input = a:context.input
                                    let prev.candidates = []
                            
                                    call deoplete#mapping#_set_completeopt()
                                    call feedkeys("\<C-x>\<C-o>", 'in')
                                    return 1
                                  endif
                                endfor
                              endfor

FUNCTION  <SNR>161_Tempdir()
Called 10 times
Total time:   0.001677
 Self time:   0.001677

count  total (s)   self (s)
   10              0.000055   let tmpdir = $TMPDIR
   10              0.000040   if empty(tmpdir)
                                let tmpdir = '/tmp/'
                              elseif tmpdir !~# '/$'
                                let tmpdir .= '/'
                              endif
   10              0.000028   return tmpdir

FUNCTION  <SNR>87_alternate_file()
Called 3 times
Total time:   0.006265
 Self time:   0.001220

count  total (s)   self (s)
    3              0.000030   if get(g:, 'test#no_alternate') | return '' | endif
    3              0.000010   let alternate_file = ''
                            
    3              0.000035   if empty(alternate_file) && exists('g:loaded_projectionist')
    3   0.006128   0.001083     let alternate_file = get(filter(projectionist#query_file('alternate'), 'filereadable(v:val)'), 0, '')
    3              0.000003   endif
                            
    3              0.000022   if empty(alternate_file) && exists('g:loaded_rails') && !empty(rails#app())
                                let alternate_file = rails#buffer().alternate()
                              endif
                            
    3              0.000005   return alternate_file

FUNCTION  ale#highlight#RemoveHighlights()
Called 30 times
Total time:   0.001602
 Self time:   0.001202

count  total (s)   self (s)
   30              0.000087     if s:has_nvim_highlight
   30   0.000757   0.000357         call ale#highlight#nvim_buf_clear_namespace(bufnr(''), s:ns_id, 0, -1)
   30              0.000345     else
                                    for l:match in getmatches()
                                        if l:match.group =~? '\v^ALE(Style)?(Error|Warning|Info)(Line)?$'
                                            call matchdelete(l:match.id)
                                        endif
                                    endfor
                                endif

FUNCTION  ale#engine#Cleanup()
Called 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
                                " Don't bother with cleanup code when newer NeoVim versions are exiting.
    1              0.000005     if get(v:, 'exiting', v:null) isnot v:null
                                    return
                                endif
                            
    1              0.000003     if exists('*ale#lsp#CloseDocument')
                                    call ale#lsp#CloseDocument(a:buffer)
                                endif
                            
    1              0.000006     if !has_key(g:ale_buffer_info, a:buffer)
    1              0.000001         return
                                endif
                            
                                call ale#engine#RunLinters(a:buffer, [], 1)
                            
                                call remove(g:ale_buffer_info, a:buffer)

FUNCTION  <SNR>158_callback_nvim_exit()
Called 12 times
Total time:   0.236186
 Self time:   0.000400

count  total (s)   self (s)
   12   0.236170   0.000383   return s:handle_diff(self, a:exitval)

FUNCTION  vista#extension#markdown#AutoUpdate()
Called 2 times
Total time:   0.000320
 Self time:   0.000040

count  total (s)   self (s)
    2   0.000318   0.000038   call s:AutoUpdate(a:fpath)

FUNCTION  ale#util#Mode()
Called 388 times
Total time:   0.003513
 Self time:   0.003513

count  total (s)   self (s)
  388              0.002901     return call('mode', a:000)

FUNCTION  deoplete#handler#_completion_begin()
Called 79 times
Total time:   0.044544
 Self time:   0.002469

count  total (s)   self (s)
   79   0.011863   0.000721   call deoplete#custom#_update_cache()
                            
   79   0.031900   0.001106   if s:is_skip(a:event)
   78              0.000284     let g:deoplete#_context.candidates = []
   78              0.000058     return
                              endif
                            
    1   0.000077   0.000065   call s:check_prev_completion(a:event)
                            
    1              0.000002   if a:event !=# 'Update' && a:event !=# 'Async'
    1   0.000121   0.000051     call deoplete#init#_prev_completion()
    1              0.000001   endif
                            
    1   0.000066   0.000008   call deoplete#util#rpcnotify( 'deoplete_auto_completion_begin', {'event': a:event})

FUNCTION  ale#util#StartPartialTimer()
Called 15 times
Total time:   0.000359
 Self time:   0.000359

count  total (s)   self (s)
   15              0.000209     let l:timer_id = timer_start(a:delay, function('s:ApplyPartialTimer'))
   15              0.000098     let s:partial_timers[l:timer_id] = [a:callback, a:args]
                            
   15              0.000022     return l:timer_id

FUNCTION  <SNR>4_doautocmd()
Called 4 times
Total time:   0.068078
 Self time:   0.000072

count  total (s)   self (s)
    4              0.000035   if exists('#'.join(a:000, '#'))
    2   0.068030   0.000024     execute 'doautocmd' ((v:version > 703 || has('patch442')) ? '<nomodeline>' : '') join(a:000)
    2              0.000001   endif

FUNCTION  <SNR>216_NetrwOptionSave()
Called 1 time
Total time:   0.122142
 Self time:   0.122142

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwOptionSave(vt<".a:vt.">) win#".winnr()." buf#".bufnr("%")."<".bufname(bufnr("%")).">"." winnr($)=".winnr("$")." mod=".&mod." ma=".&ma)
                            "  call Decho(a:vt."netrw_optionsave".(exists("{a:vt}netrw_optionsave")? ("=".{a:vt}netrw_optionsave) : " doesn't exist"),'~'.expand("<slnum>"))
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))
                            
    1              0.000030   if !exists("{a:vt}netrw_optionsave")
    1              0.000016    let {a:vt}netrw_optionsave= 1
    1              0.000004   else
                            "   call Dret("s:NetrwOptionSave : options already saved")
                               return
                              endif
                            "  call Decho("prior to save: fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist")." diff=".&l:diff,'~'.expand("<slnum>"))
                            
                              " Save current settings and current directory
                            "  call Decho("saving current settings and current directory",'~'.expand("<slnum>"))
    1              0.000020   let s:yykeep          = @@
    1              0.000039   if exists("&l:acd")|let {a:vt}netrw_acdkeep  = &l:acd|endif
    1              0.000016   let {a:vt}netrw_aikeep    = &l:ai
    1              0.000014   let {a:vt}netrw_awkeep    = &l:aw
    1              0.000015   let {a:vt}netrw_bhkeep    = &l:bh
    1              0.000014   let {a:vt}netrw_blkeep    = &l:bl
    1              0.000014   let {a:vt}netrw_btkeep    = &l:bt
    1              0.000010   let {a:vt}netrw_bombkeep  = &l:bomb
    1              0.000009   let {a:vt}netrw_cedit     = &cedit
    1              0.000014   let {a:vt}netrw_cikeep    = &l:ci
    1              0.000014   let {a:vt}netrw_cinkeep   = &l:cin
    1              0.000015   let {a:vt}netrw_cinokeep  = &l:cino
    1              0.000015   let {a:vt}netrw_comkeep   = &l:com
    1              0.000015   let {a:vt}netrw_cpokeep   = &l:cpo
    1              0.000012   let {a:vt}netrw_diffkeep  = &l:diff
    1              0.000013   let {a:vt}netrw_fenkeep   = &l:fen
    1              0.000011   if !exists("g:netrw_ffkeep") || g:netrw_ffkeep
    1              0.000015    let {a:vt}netrw_ffkeep    = &l:ff
    1              0.000002   endif
    1              0.000013   let {a:vt}netrw_fokeep    = &l:fo           " formatoptions
    1              0.000012   let {a:vt}netrw_gdkeep    = &l:gd           " gdefault
    1              0.000008   let {a:vt}netrw_hidkeep   = &l:hidden
    1              0.000011   let {a:vt}netrw_imkeep    = &l:im
    1              0.000012   let {a:vt}netrw_iskkeep   = &l:isk
    1              0.000010   let {a:vt}netrw_lskeep    = &l:ls
    1              0.000010   let {a:vt}netrw_makeep    = &l:ma
    1              0.000009   let {a:vt}netrw_magickeep = &l:magic
    1              0.000012   let {a:vt}netrw_modkeep   = &l:mod
    1              0.000010   let {a:vt}netrw_nukeep    = &l:nu
    1              0.000010   let {a:vt}netrw_rnukeep   = &l:rnu
    1              0.000008   let {a:vt}netrw_repkeep   = &l:report
    1              0.000010   let {a:vt}netrw_rokeep    = &l:ro
    1              0.000011   let {a:vt}netrw_selkeep   = &l:sel
    1              0.000009   let {a:vt}netrw_spellkeep = &l:spell
    1              0.000004   if !g:netrw_use_noswf
                               let {a:vt}netrw_swfkeep  = &l:swf
                              endif
    1              0.000013   if has("clipboard")
    1              0.121340    let {a:vt}netrw_starkeep = @*
    1              0.000004   endif
    1              0.000018   let {a:vt}netrw_tskeep    = &l:ts
    1              0.000011   let {a:vt}netrw_twkeep    = &l:tw           " textwidth
    1              0.000017   let {a:vt}netrw_wigkeep   = &l:wig          " wildignore
    1              0.000010   let {a:vt}netrw_wrapkeep  = &l:wrap
    1              0.000010   let {a:vt}netrw_writekeep = &l:write
                            
                              " save a few selected netrw-related variables
                            "  call Decho("saving a few selected netrw-related variables",'~'.expand("<slnum>"))
    1              0.000005   if g:netrw_keepdir
    1              0.000021    let {a:vt}netrw_dirkeep  = getcwd()
    1              0.000002   endif
    1              0.000013   if has("clipboard")
    1              0.000062    if &go =~# 'a' | sil! let {a:vt}netrw_regstar = @* | endif
    1              0.000002   endif
    1              0.000013   sil! let {a:vt}netrw_regslash= @/
                            
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))
                            "  call Dret("s:NetrwOptionSave : tab#".tabpagenr()." win#".winnr())

FUNCTION  neosnippet#variables#expand_stack()
Called 568 times
Total time:   0.011936
 Self time:   0.011936

count  total (s)   self (s)
  568              0.006464   if !exists('s:expand_stack')
                                let s:expand_stack = []
                              endif
                            
  568              0.001502   return s:expand_stack

FUNCTION  <SNR>172_ReceiveMessages()
Called 14 times
Total time:   0.128884
 Self time:   0.001094

count  total (s)   self (s)
   14   0.128089   0.000299   let poll_again = s:Pyeval( 'ycm_state.OnPeriodicTick()' )
                            
   14              0.000222   if poll_again
    7              0.000282     let s:pollers.receive_messages.id = timer_start( s:pollers.receive_messages.wait_milliseconds, function( 's:ReceiveMessages' ) )
    7              0.000028   else
                                " Don't poll again until we open another buffer
    7              0.000060     let s:pollers.receive_messages.id = -1
    7              0.000007   endif

FUNCTION  <SNR>171_on_insert_leave()
Called 7 times
Total time:   0.001036
 Self time:   0.000555

count  total (s)   self (s)
    7   0.000422   0.000216   call deoplete#mapping#_restore_completeopt()
    7              0.000184   let g:deoplete#_context = {}
    7   0.000391   0.000116   call deoplete#init#_prev_completion()

FUNCTION  ale#command#InitData()
Called 46 times
Total time:   0.001572
 Self time:   0.001572

count  total (s)   self (s)
   46              0.001093     if !has_key(s:buffer_data, a:buffer)
   17              0.000141         let s:buffer_data[a:buffer] = {   'jobs': {},   'file_list': [],   'directory_list': [],}
   17              0.000020     endif

FUNCTION  <SNR>87_extend()
Called 6 times
Total time:   0.001897
 Self time:   0.001897

count  total (s)   self (s)
    6              0.000018   let result = {}
    6              0.000035   for [key, value] in items(a:source)
                                let result[key] = value
                              endfor
  132              0.000537   for [key, value] in items(a:dict)
  126              0.000935     let result[key] = get(result, key, []) + value
  126              0.000256   endfor
    6              0.000013   return result

FUNCTION  fugitive#ReloadStatus()
Called 3 times
Total time:   0.002426
 Self time:   0.001392

count  total (s)   self (s)
    3   0.001934   0.000935   call s:ExpireStatus(a:0 ? a:1 : -1)
    3              0.000007   if a:0 > 1 ? a:2 : 1
                                let t = reltime()
                                let t:fugitive_reload_status = t
                                for tabnr in exists('*settabvar') ? range(1, tabpagenr('$')) : []
                                  call settabvar(tabnr, 'fugitive_reload_status', t)
                                endfor
                                call s:ReloadTabStatus()
                                exe s:DoAutocmdChanged(a:0 ? a:1 : -1)
                              else
    3   0.000397   0.000362     call s:ReloadWinStatus()
    3              0.000003   endif
    3              0.000003   return ''

FUNCTION  ale#util#LocItemCompare()
Called 1210 times
Total time:   0.018588
 Self time:   0.018588

count  total (s)   self (s)
 1210              0.001385     if a:left.bufnr < a:right.bufnr
                                    return -1
                                endif
                            
 1210              0.001255     if a:left.bufnr > a:right.bufnr
                                    return 1
                                endif
                            
 1210              0.001129     if a:left.bufnr == -1
                                    if a:left.filename < a:right.filename
                                        return -1
                                    endif
                            
                                    if a:left.filename > a:right.filename
                                        return 1
                                    endif
                                endif
                            
 1210              0.001163     if a:left.lnum < a:right.lnum
  485              0.000293         return -1
                                endif
                            
  725              0.000697     if a:left.lnum > a:right.lnum
  299              0.000177         return 1
                                endif
                            
  426              0.000395     if a:left.col < a:right.col
  423              0.000227         return -1
                                endif
                            
    3              0.000003     if a:left.col > a:right.col
    3              0.000002         return 1
                                endif
                            
                                " When either of the items lacks a problem type, then the two items should
                                " be considered equal. This is important for loclist jumping.
                                if !has_key(a:left, 'type') || !has_key(a:right, 'type')
                                    return 0
                                endif
                            
                                let l:left_priority = ale#util#GetItemPriority(a:left)
                                let l:right_priority = ale#util#GetItemPriority(a:right)
                            
                                if l:left_priority < l:right_priority
                                    return -1
                                endif
                            
                                if l:left_priority > l:right_priority
                                    return 1
                                endif
                            
                                return 0

FUNCTION  <SNR>151_mb_str_len()
Called 2384 times
Total time:   0.015612
 Self time:   0.015612

count  total (s)   self (s)
 2384              0.013830     return strdisplaywidth(a:mb_string)

FUNCTION  deoplete#custom#_get_buffer()
Called 91 times
Total time:   0.001813
 Self time:   0.001688

count  total (s)   self (s)
   91              0.000617   if !exists('b:custom')
    3   0.000618   0.000493     call deoplete#custom#_init_buffer()
    3              0.000008   endif
                            
   91              0.000139   return b:custom

FUNCTION  sy#sign#process_diff()
Called 9 times
Total time:   0.220161
 Self time:   0.007037

count  total (s)   self (s)
    9              0.000120   let a:sy.signtable             = {}
    9              0.000188   let a:sy.hunks                 = []
    9              0.000056   let [added, modified, deleted] = [0, 0, 0]
                            
    9   0.203083   0.000215   call sy#sign#get_current_signs(a:sy)
                            
                              " Determine where we have to put our signs.
   19              0.000674   for line in filter(a:diff, 'v:val =~ "^@@ "')
   10              0.000085     let a:sy.lines = []
   10              0.000021     let ids        = []
                            
   10   0.002458   0.000330     let [old_line, old_count, new_line, new_count] = sy#sign#parse_hunk(line)
                            
                                " Workaround for non-conventional diff output in older Fossil versions:
                                " https://fossil-scm.org/forum/forumpost/834ce0f1e1
                                " Fixed as of: https://fossil-scm.org/index.html/info/7fd2a3652ea7368a
   10              0.000048     if a:vcs == 'fossil' && new_line == 0
                                  let new_line = old_line - 1 - deleted
                                endif
                            
                                " Pure add:
                            
                                " @@ -5,0 +6,2 @@ this is line 5
                                " +this is line 5
                                " +this is line 5
   10              0.000028     if (old_count == 0) && (new_count >= 1)
    4              0.000011       let added += new_count
    4              0.000011       let offset = 0
   12              0.000029       while offset < new_count
    8              0.000024         let line    = new_line + offset
    8              0.000016         let offset += 1
    8   0.000320   0.000160         if s:external_sign_present(a:sy, line) | continue | endif
    8   0.000721   0.000144         call add(ids, s:add_sign(a:sy, line, 'SignifyAdd'))
    8              0.000011       endwhile
                            
                                " Pure delete
                            
                                " @@ -6,2 +5,0 @@ this is line 5
                                " -this is line 6
                                " -this is line 7
    4              0.000010     elseif (old_count >= 1) && (new_count == 0)
                                  if s:external_sign_present(a:sy, new_line) | continue | endif
                                  let deleted += old_count
                                  if new_line == 0
                                    call add(ids, s:add_sign(a:sy, 1, 'SignifyRemoveFirstLine'))
                                  elseif s:sign_show_count
                                    let text = s:sign_delete . (old_count <= 99 ? old_count : '>')
                                    while strwidth(text) > 2
                                      let text = substitute(text, '.', '', '')
                                    endwhile
                                    call add(ids, s:add_sign(a:sy, new_line, 'SignifyDelete'. old_count, text))
                                  else
                                    call add(ids, s:add_sign(a:sy, new_line, 'SignifyDeleteMore', s:sign_delete))
                                  endif
                            
                                " There are additions and deletions, however we don't know which lines are
                                " 'changed' and which are new so we just show the whole block as changed.
                                "
                                " With sufficiently smart heuristics we could see which lines are the most
                                " dissimilar to the previous lines and mark them as additions but for now
                                " we will not do that.
                                else
    6              0.000017       let modified += old_count
    6              0.000023       let offset    = 0
   37              0.000249       while offset < new_count
   31              0.000087         let line    = new_line + offset
   31              0.000061         let offset += 1
   31   0.001601   0.000278         if s:external_sign_present(a:sy, line) | continue | endif
   31   0.006789   0.000902         call add(ids, s:add_sign(a:sy, line, 'SignifyChange'))
   31              0.000039       endwhile
    6              0.000004     endif
                            
   10              0.000029     if !empty(ids)
   10              0.000092       call add(a:sy.hunks, { 'ids'  : ids, 'start': a:sy.lines[0], 'end'  : a:sy.lines[-1] })
   10              0.000009     endif
   10              0.000040   endfor
                            
                              " Remove obsoleted signs.
   10              0.000144   for line in filter(keys(a:sy.internal), '!has_key(a:sy.signtable, v:val)')
    1              0.000009     execute 'sign unplace' a:sy.internal[line].id 'buffer='.a:sy.buffer
    1              0.000001   endfor
                            
    9              0.000045   if empty(a:sy.updated_by) && empty(a:sy.hunks)
    4   0.000144   0.000057     call sy#verbose('Successful exit value, but no diff. Keep VCS for time being.', a:vcs)
    4              0.000006     return
                              endif
                            
    5   0.000142   0.000047   call sy#verbose('Signs updated.', a:vcs)
    5              0.000018   let a:sy.updated_by = a:vcs
    5              0.000017   if len(a:sy.vcs) > 1
                                call sy#verbose('Disable all other VCS.', a:vcs)
                                let a:sy.vcs = [a:vcs]
                              endif
                            
    5              0.000073   let a:sy.stats = [added, modified, deleted]

FUNCTION  neosnippet#variables#current_neosnippet()
Called 11 times
Total time:   0.000178
 Self time:   0.000178

count  total (s)   self (s)
   11              0.000069   if !exists('b:neosnippet')
    3              0.000027     let b:neosnippet = { 'snippets' : {}, 'selected_text' : '', 'target' : '', 'trigger' : 0, 'optional_tabstop' : 0,}
    3              0.000003   endif
                            
   11              0.000020   return b:neosnippet

FUNCTION  <SNR>158_check_diff_git()
Called 5 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    5              0.000029   return a:exitval ? [0, []] : [1, a:diff]

FUNCTION  ale#handlers#alex#DefineLinter()
Called 1 time
Total time:   0.001277
 Self time:   0.000188

count  total (s)   self (s)
    1   0.000071   0.000042     call ale#Set('alex_executable', 'alex')
    1   0.000026   0.000012     call ale#Set('alex_use_global', get(g:, 'ale_use_global_executables', 0))
                            
    1   0.001168   0.000122     call ale#linter#Define(a:filetype, {   'name': 'alex',   'executable': function('ale#handlers#alex#GetExecutable'),   'command': ale#handlers#alex#CreateCommandCallback(a:flags),   'output_stream': 'stderr',   'callback': 'ale#handlers#alex#Handle',   'lint_file': 1,})

FUNCTION  <SNR>172_InsideCommentOrStringAndShouldStop()
Called 69 times
Total time:   0.250523
 Self time:   0.004015

count  total (s)   self (s)
   69   0.249400   0.002892   let retval = s:InsideCommentOrString()
   69              0.000213   let inside_comment = retval == 1
   69              0.000133   let inside_string = retval == 2
                            
   69              0.000274   if inside_comment && g:ycm_complete_in_comments || inside_string && g:ycm_complete_in_strings
                                return 0
                              endif
                            
   69              0.000086   return retval

FUNCTION  vista#util#JobStop()
Called 2 times
Total time:   0.000795
 Self time:   0.000795

count  total (s)   self (s)
    2              0.000790     silent! call jobstop(a:jobid)

FUNCTION  <SNR>207_uniq()
Called 1 time
Total time:   0.000090
 Self time:   0.000041

count  total (s)   self (s)
    1   0.000089   0.000040   return s:uniq_by(a:list, 'v:val')

FUNCTION  <SNR>149_NeoVimCallback()
Called 56 times
Total time:   0.907402
 Self time:   0.007994

count  total (s)   self (s)
   56              0.000505     let l:info = s:job_map[a:job]
                            
   56              0.000175     if a:event is# 'stdout'
   33   0.016545   0.003221         let l:info.out_cb_line = ale#util#JoinNeovimOutput(   a:job,   l:info.out_cb_line,   a:data,   l:info.mode,   ale#util#GetFunction(l:info.out_cb),)
   33              0.000060     elseif a:event is# 'stderr'
                                    let l:info.err_cb_line = ale#util#JoinNeovimOutput(   a:job,   l:info.err_cb_line,   a:data,   l:info.mode,   ale#util#GetFunction(l:info.err_cb),)
                                else
   23              0.000159         if has_key(l:info, 'out_cb') && !empty(l:info.out_cb_line)
                                        call ale#util#GetFunction(l:info.out_cb)(a:job, l:info.out_cb_line)
                                    endif
                            
   23              0.000096         if has_key(l:info, 'err_cb') && !empty(l:info.err_cb_line)
                                        call ale#util#GetFunction(l:info.err_cb)(a:job, l:info.err_cb_line)
                                    endif
                            
   23              0.000024         try
   23   0.887055   0.000971             call ale#util#GetFunction(l:info.exit_cb)(a:job, a:data)
   23              0.000041         finally
                                        " Automatically forget about the job after it's done.
   23              0.000134             if has_key(s:job_map, a:job)
   23              0.000124                 call remove(s:job_map, a:job)
   23              0.000021             endif
   23              0.000027         endtry
   23              0.000016     endif

FUNCTION  <SNR>161_TryAppendExtension()
Called 10 times
Total time:   0.000434
 Self time:   0.000266

count  total (s)   self (s)
   10   0.000288   0.000120   let ext = t:vista.source.extension()
   10              0.000032   if !empty(ext)
   10              0.000098     return join([a:tempname, ext], '.')
                              else
                                return a:tempname
                              endif

FUNCTION  ale_linters#vim#vint#GetCommand()
Called 23 times
Total time:   0.003553
 Self time:   0.002403

count  total (s)   self (s)
   23   0.002462   0.001797     let l:can_use_no_color_flag = empty(a:version)   || ale#semver#GTE(a:version, [0, 3, 7])
                            
   23   0.000723   0.000238     let l:warning_flag = ale#Var(a:buffer, 'vim_vint_show_style_issues') ? '-s' : '-w'
                            
   23              0.000233     return '%e'   . ' ' . l:warning_flag   . (l:can_use_no_color_flag ? ' --no-color' : '')   . s:enable_neovim   . ' ' . s:format   . ' %t'

FUNCTION  <SNR>145_RunIfExecutable()
Called 23 times
Total time:   0.157555
 Self time:   0.004073

count  total (s)   self (s)
   23   0.000646   0.000363     if ale#command#IsDeferred(a:executable)
                                    let a:executable.result_callback = {   executable -> s:RunIfExecutable(a:buffer, a:linter, executable)}
                            
                                    return 1
                                endif
                            
   23   0.001149   0.000648     if ale#engine#IsExecutable(a:buffer, a:executable)
                                    " Use different job types for file or linter jobs.
   23              0.000092         let l:job_type = a:linter.lint_file ? 'file_linter' : 'linter'
   23              0.000224         call setbufvar(a:buffer, 'ale_job_type', l:job_type)
                            
   23              0.000084         if has_key(a:linter, 'command_chain')
                                        let [l:command, l:options] = ale#engine#ProcessChain(   a:buffer,   a:executable,   a:linter,   0,   [])
                            
                                        return s:RunJob(l:command, l:options)
                                    endif
                            
   23   0.006480   0.000373         let l:command = ale#linter#GetCommand(a:buffer, a:linter)
   23              0.000323         let l:options = {   'executable': a:executable,   'buffer': a:buffer,   'linter': a:linter,   'output_stream': get(a:linter, 'output_stream', 'stdout'),   'next_chain_index': 1,   'read_buffer': a:linter.read_buffer,}
                            
   23   0.147839   0.001248         return s:RunJob(l:command, l:options)
                                endif
                            
                                return 0

FUNCTION  <SNR>106_Slash()
Called 19 times
Total time:   0.000242
 Self time:   0.000242

count  total (s)   self (s)
   19              0.000092   if exists('+shellslash')
                                return tr(a:path, '\', '/')
                              else
   19              0.000033     return a:path
                              endif

FUNCTION  projectionist#query()
Called 3 times
Total time:   0.000852
 Self time:   0.000469

count  total (s)   self (s)
    3              0.000007   let candidates = []
    3              0.000327   let file = a:0 > 1 ? a:2 : get(a:0 ? a:1 : {}, 'file', get(b:, 'projectionist_file', expand('%:p')))
    3   0.000474   0.000091   for [value, expansions] in projectionist#query_raw(a:key, file)
                                call extend(expansions, a:0 ? a:1 : {}, 'keep')
                                call add(candidates, [expansions.project, s:expand_placeholders(value, expansions)])
                                unlet value
                              endfor
    3              0.000004   return candidates

FUNCTION  <SNR>139_expand()
Called 18 times
Total time:   0.002029
 Self time:   0.001815

count  total (s)   self (s)
   18   0.001989   0.001774   return s:substitute_path_separator(expand(a:path))

FUNCTION  <lambda>55()
Called 1 time
Total time:   0.000119
 Self time:   0.000073

count  total (s)   self (s)
    1   0.000116   0.000071 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <SNR>197_make_cache_from_syntax()
Called 1 time
Total time:   0.034372
 Self time:   0.000398

count  total (s)   self (s)
                              " Get current syntax list.
    1   0.034014   0.000039   let syntax_list = s:redir('syntax list')
    1              0.000047   if syntax_list =~ '^E\d\+' || syntax_list =~ '^No Syntax items'
                                return []
                              endif
                            
    1              0.000296   let lines = split(syntax_list, '\n')
    1              0.000005   if len(lines) > g:necosyntax#max_syntax_lines
                                " Too long.
    1              0.000001     return []
                              endif
                            
                              let group_name = ''
                              let keyword_pattern = '\h\w*'
                            
                              let keyword_list = []
                              for line in lines
                                if line =~ '^\h\w\+'
                                  " Change syntax group name.
                                  let group_name = matchstr(line, '^\S\+')
                                  let line = substitute(line, '^\S\+\s*xxx', '', '')
                                endif
                            
                                if line =~ 'Syntax items' || line =~ '^\s*links to' || line =~ '^\s*nextgroup='
                                  " Next line.
                                  continue
                                endif
                            
                                let line = substitute(line, 'contained\|skipwhite\|skipnl\|oneline', '', 'g')
                                let line = substitute(line, '^\s*nextgroup=.*\ze\s', '', '')
                            
                                if line =~ '^\s*match'
                                  let line = s:substitute_candidate( matchstr(line, '/\zs[^/]\+\ze/'))
                                elseif line =~ '^\s*start='
                                  let line =s:substitute_candidate(   matchstr(line, 'start=/\zs[^/]\+\ze/')) . ' ' .s:substitute_candidate(   matchstr(line, 'end=/zs[^/]\+\ze/'))
                                endif
                            
                                " Add keywords.
                                let match_num = 0
                                let match_str = matchstr(line, keyword_pattern, match_num)
                            
                                while match_str != ''
                                  " Ignore too short keyword.
                                  if len(match_str) >= g:necosyntax#min_keyword_length&& match_str =~ '^[[:print:]]\+$'
                                    call add(keyword_list, match_str)
                                  endif
                            
                                  let match_num += len(match_str)
                            
                                  let match_str = matchstr(line, keyword_pattern, match_num)
                                endwhile
                              endfor
                            
                              let keyword_list = s:uniq(keyword_list)
                            
                              return keyword_list

FUNCTION  <SNR>151_cat_buffer_names()
Called 84 times
Total time:   0.148005
 Self time:   0.135008

count  total (s)   self (s)
   84              0.000225   let l:current_str = ''
   84              0.000132   let l:before_str = ''
   84              0.000224   let l:after_str = ''
   84              0.000197   let l:visable_current_str = ''
   84              0.000134   let l:visable_before_str = ''
   84              0.000134   let l:visable_after_str = ''
   84              0.000194   let l:visable_before_str_len = 0
   84              0.000265   let l:visable_after_str_len = 0
                              "let l:debug_str = ''
                            
                              " current - from left to right
  624              0.001379   for nr in range(0, len(a:names) - 1)
  540              0.001178     let l:val = a:names[nr]
  540              0.001307     if l:val[0] == a:current_bufnr
   84              0.000143       let l:display_name = ''
   84              0.000167       if g:lightline_buffer_show_bufnr != 0
   84              0.000465           let l:display_name .= l:val[0] . ' ' . l:val[1]
   84              0.000065       else
                                      let l:display_name .= l:val[1]
                                  endif
                            
                                  "let l:debug_str .= '=' . l:display_name
   84              0.000289       let l:current_str .= l:display_name
   84              0.000251       let l:visable_current_str .= l:display_name
   84              0.000075     endif
  540              0.001059   endfor
                            
                              " before - from right to left
  624              0.001824   for nr in range(len(a:names) - 1, 0, -1)
  540              0.001244     let l:val = a:names[nr]
  540              0.001392     if l:val[0] < a:current_bufnr
  360              0.000593       let l:display_name = ''
  360              0.000597       if g:lightline_buffer_show_bufnr != 0
  360              0.001932           let l:display_name .= l:val[0] . ' ' . l:val[1]
  360              0.000293       else
                                      let l:display_name .= l:val[1]
                                  endif
                            
                                  "let l:debug_str .= '<' . l:display_name
  360              0.001952       let l:temp_visable_str = g:lightline_buffer_separator_left_icon . l:display_name . g:lightline_buffer_separator_right_icon
                            
  360              0.000539       if a:shorten_left_len > 0
  144              0.000220         if 0 != g:lightline_buffer_debug_info
                                      let g:lightline_buffer_status_info.info = a:shorten_left_len
                                    endif
  144              0.000296         if l:visable_before_str_len < a:shorten_left_len
  144   0.002934   0.002265           let l:temp_visable_str_len = s:mb_str_len(l:temp_visable_str)
  144              0.000352           if l:visable_before_str_len + l:temp_visable_str_len >= a:shorten_left_len
   24   0.002113   0.000335             let l:temp_str = s:shorten_left(l:temp_visable_str, a:shorten_left_len - l:visable_before_str_len, l:temp_visable_str_len, l:val[0], a:names[0][0])
   24              0.000083             let l:before_str = l:temp_str . l:before_str
   24   0.000702   0.000202             let l:temp_visable_str = s:shorten_left(l:temp_visable_str, a:shorten_left_len - l:visable_before_str_len, l:temp_visable_str_len, -1, -1)
   24              0.000017           else
  120   0.002556   0.001501             let l:before_str = s:clickable_text(l:temp_visable_str, l:val[0]) . l:before_str
  120              0.000088           endif
  144              0.000470           let l:visable_before_str = l:temp_visable_str . l:visable_before_str
  144              0.000080         endif
  144              0.000070       else
  216              0.001037         let l:visable_before_str = l:temp_visable_str . l:visable_before_str
  216   0.007201   0.004358         let l:before_str = s:clickable_text(l:temp_visable_str, l:val[0]) . l:before_str
  216              0.000182       endif
                            
  360   0.005856   0.003578       let l:visable_before_str_len = s:mb_str_len(l:visable_before_str)
  360              0.000259     endif
  540              0.004809   endfor
                            
                              " before - left icon
   84              0.000576   let l:before_str .= g:lightline_buffer_active_buffer_left_icon
   84              0.000385   let l:visable_before_str .= g:lightline_buffer_active_buffer_left_icon
   84   0.001081   0.000590   let l:visable_before_str_len = s:mb_str_len(l:visable_before_str)
                            
                              " after - from left to right
  624              0.001725   for nr in range(0, len(a:names) - 1)
  540              0.001478     let l:val = a:names[nr]
  540              0.001560     if l:val[0] > a:current_bufnr
   96              0.000197       let l:display_name = ''
   96              0.000192       if g:lightline_buffer_show_bufnr != 0
   96              0.000532           let l:display_name .= l:val[0] . ' ' . l:val[1]
   96              0.000089       else
                                      let l:display_name .= l:val[1]
                                  endif
                            
                                  "let l:debug_str .= '>' . l:display_name
   96              0.000626       let l:temp_visable_str = g:lightline_buffer_separator_left_icon . l:display_name . g:lightline_buffer_separator_right_icon
                            
   96              0.000169       if a:shorten_right_len > 0
   40              0.000065         if 0 != g:lightline_buffer_debug_info
                                      let g:lightline_buffer_status_info.info = a:shorten_right_len
                                    endif
   40              0.000082         if l:visable_after_str_len < a:shorten_right_len
   40   0.000530   0.000327           let l:temp_visable_str_len = s:mb_str_len(l:temp_visable_str)
   40              0.000121           if l:visable_after_str_len + l:temp_visable_str_len >= a:shorten_right_len
    8   0.000665   0.000145             let l:temp_str = s:shorten_right(l:temp_visable_str, a:shorten_right_len - l:visable_after_str_len, l:temp_visable_str_len, l:val[0], a:names[len(a:names) - 1][0])
    8              0.000030             let l:after_str .= l:temp_str
    8   0.000254   0.000080             let l:temp_visable_str = s:shorten_right(l:temp_visable_str, a:shorten_right_len - l:visable_after_str_len, l:temp_visable_str_len, -1, -1)
    8              0.000007           else
   32   0.000789   0.000421             let l:after_str .= s:clickable_text(l:temp_visable_str, l:val[0])
   32              0.000028           endif
   40              0.000177           let l:visable_after_str .= l:temp_visable_str
   40              0.000030         endif
   40              0.000024       else
   56              0.000234         let l:visable_after_str .= l:temp_visable_str
   56   0.002110   0.001347         let l:after_str .= s:clickable_text(l:temp_visable_str, l:val[0])
   56              0.000058       endif
                            
   96   0.003177   0.002329       let l:visable_after_str_len = s:mb_str_len(l:visable_after_str)
   96              0.000085     endif
  540              0.002091   endfor
                            
                              " after - #8 not empty tabline_separator
                              " if before_str empty and tabline_separator not empty
                              " should add a space to after_str to keep text static
   84              0.000869   let l:tabline_separator_not_empty = exists('g:lightline.tabline_separator.left') && '' != g:lightline.tabline_separator.left
   84              0.000858   let l:separator_not_empty = exists('g:lightline.separator.left') && '' != g:lightline.separator.left
   84              0.000934   if (l:tabline_separator_not_empty || l:separator_not_empty) && '' == l:before_str && '' == l:visable_before_str
                                let l:after_str = ' ' . l:after_str
                                let l:visable_after_str = ' ' . l:visable_after_str
                                let l:visable_after_str_len = s:mb_str_len(l:visable_after_str)
                              endif
                            
                              " after - right icon
   84              0.000398   let l:after_str = g:lightline_buffer_active_buffer_right_icon . l:after_str
   84              0.000777   let l:visable_after_str = g:lightline_buffer_active_buffer_right_icon . l:visable_after_str
   84   0.001456   0.000948   let l:visable_after_str_len = s:mb_str_len(l:visable_after_str)
                            
                              " all
   84              0.000747   let l:strs = [ l:current_str, l:before_str, l:after_str, l:visable_current_str, l:visable_before_str, l:visable_after_str ]
                              "echo l:debug_str
                            
   84              0.000612   return l:strs

FUNCTION  <SNR>232_MarkdownSetupFoldLevel()
Called 1 time
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    1              0.000004     if get(g:, "vim_markdown_folding_style_pythonic", 0)
                                    " set default foldlevel
                                    execute "setlocal foldlevel=".s:vim_markdown_folding_level
                                endif

FUNCTION  <lambda>54()
Called 1 time
Total time:   0.012261
 Self time:   0.000052

count  total (s)   self (s)
    1   0.012259   0.000050 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  ternjs#deleteTernPort()
Called 1 time
Total time:   0.000145
 Self time:   0.000145

count  total (s)   self (s)
    1              0.000118     if !empty(glob(join([getcwd(), ".tern-port"], "/")))
                                    echo delete(fnameescape(join([getcwd(), ".tern-port"], "/"))) == 0 ? "Success" : "Fail"
                                endif

FUNCTION  <SNR>150_term()
Called 8 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    8              0.000031   return get(a:p, 4) !=# '' ? 'term='.a:p[4].' cterm='.a:p[4].' gui='.a:p[4] : ''

FUNCTION  <SNR>151_clickable_text()
Called 488 times
Total time:   0.005612
 Self time:   0.005612

count  total (s)   self (s)
  488              0.002308   if has('tablineat')
  488              0.002678     return '%' . a:minwid . '@lightline#buffer#clickbuf@' . a:text . '%X'
                              endif
                            
                              return a:text

FUNCTION  denite#util#input()
Called 1 time
Total time:   0.016984
 Self time:   0.007395

count  total (s)   self (s)
    1              0.000012   let text = get(a:000, 0, '')
    1              0.000003   let completion = get(a:000, 1, '')
    1              0.000001   try
    1              0.000002     if completion !=# ''
                                  return input(a:prompt, text, completion)
                                else
    1   0.016949   0.007360       return input(a:prompt, text)
                                endif
                              catch
                                " ignore the errors
                                return ''
                              endtry

FUNCTION  <lambda>56()
Called 1 time
Total time:   0.000075
 Self time:   0.000046

count  total (s)   self (s)
    1   0.000073   0.000044 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <SNR>205_check_old_cache()
Called 1 time
Total time:   0.000210
 Self time:   0.000055

count  total (s)   self (s)
                              " Check old cache file.
    1   0.000164   0.000009   let cache_name = s:_encode_name(a:cache_dir, a:filename)
    1              0.000027   let ret = getftime(cache_name) == -1 || getftime(cache_name) <= getftime(a:filename)
    1              0.000013   if ret && filereadable(cache_name)
                                " Delete old cache.
                                call delete(cache_name)
                              endif
                            
    1              0.000001   return ret

FUNCTION  ale#linter#GetAll()
Called 26 times
Total time:   0.039832
 Self time:   0.011182

count  total (s)   self (s)
                                " Don't return linters in the sandbox.
                                " Otherwise a sandboxed script could modify them.
   26   0.000776   0.000277     if ale#util#InSandbox()
                                    return []
                                endif
                            
   26              0.000071     let l:combined_linters = []
                            
   52              0.000133     for l:filetype in a:filetypes
                                    " Load linters from runtimepath if we haven't done that yet.
   26              0.000133         if !has_key(s:runtime_loaded_map, l:filetype)
    1   0.037241   0.009090             execute 'silent! runtime! ale_linters/' . l:filetype . '/*.vim'
                            
    1              0.000016             let s:runtime_loaded_map[l:filetype] = 1
    1              0.000002         endif
                            
   26              0.000286         call extend(l:combined_linters, get(s:linters, l:filetype, []))
   26              0.000033     endfor
                            
   26              0.000055     return l:combined_linters

FUNCTION  ale#handlers#gcc#HandleGCCFormat()
Called 17 times
Total time:   0.355039
 Self time:   0.043842

count  total (s)   self (s)
   17              0.000061     let l:output = []
                            
  625   0.183799   0.003169     for l:match in ale#util#GetMatches(a:lines, s:pattern)
                                    " Filter out the pragma errors
  608   0.016199   0.007035         if s:IsHeaderFile(bufname(bufnr('')))&& l:match[5][:len(s:pragma_error) - 1] is# s:pragma_error
                                        continue
                                    endif
                            
                                    " If the 'error type' is a note, make it detail related to
                                    " the previous error parsed in output
  608              0.001377         if l:match[4] is# 'note'
                                        if !empty(l:output)
                                            if !has_key(l:output[-1], 'detail')
                                                let l:output[-1].detail = l:output[-1].text
                                            endif
                            
                                            let l:output[-1].detail = l:output[-1].detail . "\n"   . s:RemoveUnicodeQuotes(l:match[0])
                                        endif
                            
                                        continue
                                    endif
                            
  608   0.130183   0.008781         let l:item = {   'lnum': str2nr(l:match[2]),   'type': (l:match[4] is# 'error' || l:match[4] is# 'fatal error') ? 'E' : 'W',   'text': s:RemoveUnicodeQuotes(l:match[5]),}
                            
  608              0.002070         if !empty(l:match[3])
  608              0.002137             let l:item.col = str2nr(l:match[3])
  608              0.000450         endif
                            
                                    " If the filename is something like <stdin>, <nofile> or -, then
                                    " this is an error for the file we checked.
  608              0.002222         if l:match[1] isnot# '-' && l:match[1][0] isnot# '<'
  608              0.001701             let l:item['filename'] = l:match[1]
  608              0.000329         endif
                            
  608              0.001845         call add(l:output, l:item)
  608              0.000455     endfor
                            
   17              0.000026     return l:output

FUNCTION  ale_linters#vim#vint#Handle()
Called 17 times
Total time:   0.546345
 Self time:   0.191306

count  total (s)   self (s)
   17   0.355354   0.000315     let l:loclist = ale#handlers#gcc#HandleGCCFormat(a:buffer, a:lines)
                            
  625              0.000658     for l:item in l:loclist
  608              0.000829         let l:match = []
                            
 3039              0.004084         for l:regex in s:word_regex_list
 2432              0.160810             let l:match = matchlist(l:item.text, l:regex)
                            
 2432              0.004937             if !empty(l:match)
    1              0.000005                 let l:item.end_col = l:item.col + len(l:match[1]) - 1
    1              0.000001                 break
                                        endif
 2431              0.004421         endfor
  608              0.000280     endfor
                            
   17              0.000025     return l:loclist

FUNCTION  xray#highlight#IsGuiOrTrueColorTerm()
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000010   if exists('g:xray_use_gui')
    1              0.000003     return g:xray_use_gui
                              endif
                            
                              let g:xray_use_gui = v:false
                            
                              if has('gui_running')
                                let g:xray_use_gui = v:true
                              else
                                " check both that the terminal supports truecolor mode _and_ that
                                " Vim supports it _and_ that the user has chosen to use it
                                if exists('$COLORTERM') && $COLORTERM ==? 'truecolor' && has('termguicolors') && &l:termguicolors
                                  let g:xray_use_gui = v:true
                                endif
                              endif
                            
                              return g:xray_use_gui

FUNCTION  <SNR>6_DetectElixir()
Called 4 times
Total time:   0.000240
 Self time:   0.000240

count  total (s)   self (s)
    4              0.000193   if (!did_filetype() || &filetype !=# 'elixir') && getline(1) =~# '^#!.*\<elixir\>'
                                set filetype=elixir
                              endif

FUNCTION  <lambda>59()
Called 1 time
Total time:   0.011427
 Self time:   0.000033

count  total (s)   self (s)
    1   0.011426   0.000032 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <SNR>158_initialize_buffer_job()
Called 4 times
Total time:   0.007947
 Self time:   0.001073

count  total (s)   self (s)
    4              0.000024   let bufferfile = tempname()
    4   0.005910   0.000313   call s:write_buffer(a:bufnr, bufferfile)
                            
    4              0.000148   let basefile = tempname()
    4   0.001462   0.000338   let base_cmd = s:get_base_cmd(a:bufnr, a:vcs, g:signify_vcs_cmds_diffmode) . '>' . fnameescape(basefile) . ' && '
                            
    4              0.000097   let diff_cmd = base_cmd .  s:difftool . ' -U0 ' . fnameescape(basefile) . ' ' . fnameescape(bufferfile)
    4   0.000234   0.000081   let [cmd, options] = s:wrap_cmd(a:bufnr, a:vcs, diff_cmd)
                            
    4              0.000018   let options.tempfiles = [basefile, bufferfile]
                            
    4              0.000009   return [cmd, options]

FUNCTION  ale#util#FindItemAtCursor()
Called 344 times
Total time:   0.030147
 Self time:   0.019794

count  total (s)   self (s)
  344              0.005493     let l:info = get(g:ale_buffer_info, a:buffer, {})
  344              0.001972     let l:loclist = get(l:info, 'loclist', [])
  344              0.002129     let l:pos = getpos('.')
  344   0.015581   0.005228     let l:index = ale#util#BinarySearch(l:loclist, a:buffer, l:pos[1], l:pos[2])
  344              0.001517     let l:loc = l:index >= 0 ? l:loclist[l:index] : {}
                            
  344              0.002246     return [l:info, l:loc]

FUNCTION  test#javascript#jasmine#test_file()
Called 6 times
Total time:   0.000262
 Self time:   0.000262

count  total (s)   self (s)
    6              0.000231   return a:file =~? g:test#javascript#jasmine#file_pattern && test#javascript#has_package('jasmine')

FUNCTION  ale#linter#ResolveFiletype()
Called 26 times
Total time:   0.006193
 Self time:   0.003280

count  total (s)   self (s)
   26   0.005862   0.002950     let l:filetype = s:GetAliasedFiletype(a:original_filetype)
                            
   26              0.000117     if type(l:filetype) isnot v:t_list
   26              0.000147         return [l:filetype]
                                endif
                            
                                return l:filetype

FUNCTION  defx#init#_check_channel()
Called 3 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
    3              0.000040   return exists('g:defx#_channel_id')

FUNCTION  ale#engine#SetResults()
Called 17 times
Total time:   0.223802
 Self time:   0.005711

count  total (s)   self (s)
   17   0.001345   0.000970     let l:linting_is_done = !ale#engine#IsCheckingBuffer(a:buffer)
                            
                                " Set signs first. This could potentially fix some line numbers.
                                " The List could be sorted again here by SetSigns.
   17              0.000056     if g:ale_set_signs
   17   0.120241   0.000875         call ale#sign#SetSigns(a:buffer, a:loclist)
   17              0.000012     endif
                            
   17              0.000041     if g:ale_set_quickfix || g:ale_set_loclist
   17   0.002669   0.000465         call ale#list#SetLists(a:buffer, a:loclist)
   17              0.000012     endif
                            
   17              0.000073     if exists('*ale#statusline#Update')
                                    " Don't load/run if not already loaded.
                                    call ale#statusline#Update(a:buffer, a:loclist)
                                endif
                            
   17              0.000027     if g:ale_set_highlights
   17   0.073421   0.000312         call ale#highlight#SetHighlights(a:buffer, a:loclist)
   17              0.000015     endif
                            
   17              0.000028     if l:linting_is_done
   17              0.000024         if g:ale_echo_cursor
                                        " Try and echo the warning now.
                                        " This will only do something meaningful if we're in normal mode.
   17   0.006805   0.000156             call ale#cursor#EchoCursorWarning()
   17              0.000012         endif
                            
   17              0.000026         if g:ale_virtualtext_cursor
                                        " Try and show the warning now.
                                        " This will only do something meaningful if we're in normal mode.
                                        call ale#virtualtext#ShowCursorWarning()
                                    endif
                            
                                    " Reset the save event marker, used for opening windows, etc.
   17              0.000106         call setbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Set a marker showing how many times a buffer has been checked.
   17              0.000104         call setbufvar(   a:buffer,   'ale_linted',   getbufvar(a:buffer, 'ale_linted', 0) + 1)
                            
                                    " Automatically remove all managed temporary files and directories
                                    " now that all jobs have completed.
   17   0.016163   0.000383         call ale#command#RemoveManagedFiles(a:buffer)
                            
                                    " Call user autocommands. This allows users to hook into ALE's lint cycle.
   17   0.002097   0.001488         silent doautocmd <nomodeline> User ALELintPost
   17              0.000035     endif

FUNCTION  ale#semver#GTE()
Called 23 times
Total time:   0.000665
 Self time:   0.000665

count  total (s)   self (s)
   23              0.000155     if empty(a:lhs)
                                    return 0
                                endif
                            
   23              0.000070     if a:lhs[0] > a:rhs[0]
                                    return 1
                                elseif a:lhs[0] == a:rhs[0]
   23              0.000046         if a:lhs[1] > a:rhs[1]
                                        return 1
                                    elseif a:lhs[1] == a:rhs[1]
   23              0.000131             return get(a:lhs, 2) >= get(a:rhs, 2)
                                    endif
                                endif
                            
                                return 0

FUNCTION  <SNR>135_GetVar()
Called 20 times
Total time:   0.001050
 Self time:   0.001050

count  total (s)   self (s)
   20              0.000079     let name = a:1
                            
   20              0.000129     if exists('b:' . name)
                                    return get(b:, name)
                                elseif exists('g:' . name)
    5              0.000018         return get(g:, name)
                                else
   15              0.000063         return get(a:000, 1, v:null)
                                endif

FUNCTION  <SNR>138_get_variable_type()
Called 18 times
Total time:   0.000965
 Self time:   0.000965

count  total (s)   self (s)
                              " Analyze variable type.
   18              0.000238   if a:expression =~ '^\%(\s*+\)\?\s*\d\+\.\d\+'
                                return '.'
                              elseif a:expression =~ '^\%(\s*+\)\?\s*\d\+'
                                return '0'
                              elseif a:expression =~ '^\%(\s*\.\)\?\s*["'']'
   16              0.000024     return '""'
                              elseif a:expression =~ '\<function('
                                return '()'
                              elseif a:expression =~ '^\%(\s*+\)\?\s*\['
                                return '[]'
                              elseif a:expression =~ '^\s*{\|^\.\h[[:alnum:]_:]*'
    1              0.000001     return '{}'
                              elseif a:expression =~ '\<\h\w*('
                                " Function.
                                let func_name = matchstr(a:expression, '\<\zs\h\w*\ze(')
                                return has_key(s:function_return_types, func_name) ? s:function_return_types[func_name] : ''
                              else
    1              0.000001     return ''
                              endif

FUNCTION  <SNR>161_PrepareContainer()
Called 8 times
Total time:   0.000288
 Self time:   0.000288

count  total (s)   self (s)
    8              0.000044   let s:data = {}
    8              0.000065   let t:vista = get(t:, 'vista', {})
    8              0.000031   let t:vista.functions = []
    8              0.000017   let t:vista.raw = []
    8              0.000021   let t:vista.kinds = []
    8              0.000021   let t:vista.raw_by_kind = {}
    8              0.000017   let t:vista.with_scope = []
    8              0.000030   let t:vista.without_scope = []
    8              0.000017   let t:vista.tree = {}

FUNCTION  <SNR>135_useVirtualText()
Called 5 times
Total time:   0.000310
 Self time:   0.000161

count  total (s)   self (s)
    5   0.000224   0.000075     let l:use = s:GetVar('LanguageClient_useVirtualText')
    5              0.000017     if l:use isnot v:null
                                    return l:use
                                endif
                            
    5              0.000024     if exists('*nvim_buf_set_virtual_text')
    5              0.000007         return 'All'
                                else
                                    return 'No'
                                endif

FUNCTION  LanguageClient#Write()
Called 348 times
Total time:   0.026231
 Self time:   0.026231

count  total (s)   self (s)
  348              0.003460     let l:message = a:message . "\n"
  348              0.002182     if has('nvim')
                                    " jobsend respond 1 for success.
  348              0.019667         return !jobsend(s:job, l:message)
                                elseif has('channel')
                                    return ch_sendraw(s:job, l:message)
                                else
                                    echoerr 'Not supported: not nvim nor vim with +channel.'
                                endif

FUNCTION  <SNR>59_expand()
Called 1 time
Total time:   0.000016
 Self time:   0.000013

count  total (s)   self (s)
    1   0.000015   0.000012   return denite#util#substitute_path_separator( (a:path =~# '^\~') ? fnamemodify(a:path, ':p') : a:path)

FUNCTION  <SNR>106_CeilingDirectories()
Called 25 times
Total time:   0.000851
 Self time:   0.000851

count  total (s)   self (s)
   25              0.000105   if !exists('s:ceiling_directories')
                                let s:ceiling_directories = []
                                let resolve = 1
                                for dir in split($GIT_CEILING_DIRECTORIES, has('win32') ? ';' : ':', 1)
                                  if empty(dir)
                                    let resolve = 0
                                  elseif resolve
                                    call add(s:ceiling_directories, resolve(dir))
                                  else
                                    call add(s:ceiling_directories, dir)
                                  endif
                                endfor
                              endif
   25              0.000111   return s:ceiling_directories + get(g:, 'ceiling_directories', [])

FUNCTION  xray#highlight#GetHighlightGroupDetails()
Called 8 times
Total time:   0.003954
 Self time:   0.003954

count  total (s)   self (s)
    8              0.000113   redir => l:highlight_output
    8              0.001892   execute 'silent highlight ' . a:group
    8              0.000130   redir END
                            
                              " recurse to find actual highlight group if needed
    8              0.000122   while l:highlight_output =~ 'links to'
                                let l:index        = stridx(l:highlight_output, 'links to') + len('links to')
                                let l:linked_group = strpart(l:highlight_output, l:index + 1)
                            
                                redir => l:highlight_output
                                execute 'silent highlight ' . l:linked_group
                                redir END
                              endwhile
                            
                              " extract highlight group details
    8              0.001434   return substitute(matchlist(l:highlight_output, '\<xxx\>\s\+\(.*\)')[1], '\n', ' ', 'g')

FUNCTION  neosnippet#util#uniq()
Called 11 times
Total time:   0.001625
 Self time:   0.001625

count  total (s)   self (s)
   11              0.000201   let list = copy(a:list)
   11              0.000022   let i = 0
   11              0.000023   let seen = {}
   44              0.000309   while i < len(list)
   33              0.000088     let key = list[i]
   33              0.000147     if key !=# '' && has_key(seen, key)
   11              0.000044       call remove(list, i)
   11              0.000008     else
   22              0.000034       if key !=# ''
   22              0.000064         let seen[key] = 1
   22              0.000014       endif
   22              0.000038       let i += 1
   22              0.000013     endif
   33              0.000040   endwhile
   11              0.000020   return list

FUNCTION  ale#list#SetLists()
Called 17 times
Total time:   0.002204
 Self time:   0.000668

count  total (s)   self (s)
   17              0.000146     if get(g:, 'ale_set_lists_synchronously') == 1|| getbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Update lists immediately if running a test synchronously, or if the
                                    " buffer was saved.
                                    "
                                    " The lists need to be updated immediately when saving a buffer so
                                    " that we can reliably close window automatically, if so configured.
    2   0.001196   0.000018         call s:SetListsImpl(-1, a:buffer, a:loclist)
    2              0.000001     else
   15   0.000652   0.000293         call ale#util#StartPartialTimer(   0,   function('s:SetListsImpl'),   [a:buffer, a:loclist],)
   15              0.000012     endif

FUNCTION  denite#init#_check_channel()
Called 3 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    3              0.000020   return exists('g:denite#_channel_id')

FUNCTION  fugitive#Init()
Called 4 times
Total time:   0.001015
 Self time:   0.000443

count  total (s)   self (s)
    4              0.000026   if exists('#User#FugitiveBoot')
                                exe s:DoAutocmd('User FugitiveBoot')
                              endif
    4   0.000151   0.000035   let dir = s:Dir()
    4              0.000040   if &tags !~# '\.git' && @% !~# '\.git' && !exists('s:tags_warning')
                                let actualdir = fugitive#Find('.git/', dir)
                                if filereadable(actualdir . 'tags')
                                  let s:tags_warning = 1
                                  echohl WarningMsg
                                  echo "Fugitive .git/tags support removed in favor of `:set tags^=./.git/tags;`"
                                  echohl NONE
                                endif
                              endif
    4   0.000742   0.000285   exe s:DoAutocmd('User Fugitive')

FUNCTION  pencil#init()
Called 4 times
Total time:   0.380456
 Self time:   0.007064

count  total (s)   self (s)
    4              0.000024   let l:args = a:0 ? a:1 : {}
                            
                              " flag to suspend autoformat for the next Insert
    4              0.000011   let b:pencil_suspend_af = 0
                            
    4              0.000019   if !exists('b:pencil_wrap_mode')
    1              0.000002     let b:pencil_wrap_mode = s:WRAP_MODE_OFF
    1              0.000001   en
    4              0.000013   if !exists('b:max_textwidth')
    1              0.000001     let b:max_textwidth = -1
    1              0.000000   en
                            
                              " If user explicitly requested wrap_mode thru args, go with that.
    4              0.000021   let l:wrap_arg = get(l:args, 'wrap', 'detect')
                            
    4              0.000066   if (b:pencil_wrap_mode && l:wrap_arg ==# 'toggle') || l:wrap_arg =~# '^\(0\|off\|disable\|false\)$'
                                let b:pencil_wrap_mode = s:WRAP_MODE_OFF
                              elsei l:wrap_arg ==# 'hard'
                                let b:pencil_wrap_mode = s:WRAP_MODE_HARD
                              elsei l:wrap_arg ==# 'soft'
                                let b:pencil_wrap_mode = s:WRAP_MODE_SOFT
                              elsei l:wrap_arg ==# 'default'
                                let b:pencil_wrap_mode = s:WRAP_MODE_DEFAULT
                              el
                                " this can return s:WRAP_MODE_ for soft, hard or default
    4   0.021884   0.000094     let b:pencil_wrap_mode = s:detect_wrap_mode()
    4              0.000003   en
                            
                              " translate default(-1) to soft(1) or hard(2) or off(0)
    4              0.000009   if b:pencil_wrap_mode ==# s:WRAP_MODE_DEFAULT
                                if g:pencil#wrapModeDefault =~# '^\(0\|off\|disable\|false\)$'
                                  let b:pencil_wrap_mode = s:WRAP_MODE_OFF
                                elsei g:pencil#wrapModeDefault ==# 'soft'
                                  let b:pencil_wrap_mode = s:WRAP_MODE_SOFT
                                el
                                  let b:pencil_wrap_mode = s:WRAP_MODE_HARD
                                en
                              en
                            
                              " autoformat is only used in Hard mode, and then only during
                              " Insert mode
    4   0.000511   0.000265   call pencil#setAutoFormat( b:pencil_wrap_mode ==# s:WRAP_MODE_HARD && get(l:args, 'autoformat', g:pencil#autoformat))
                            
    4              0.000008   if b:pencil_wrap_mode ==# s:WRAP_MODE_HARD
                                if &modeline ==# 0 && b:max_textwidth > 0
                                  " Compensate for disabled modeline
                                  exe 'setl textwidth=' . b:max_textwidth
                                elsei &textwidth ==# 0
                                  exe 'setl textwidth=' . get(l:args, 'textwidth', g:pencil#textwidth)
                                el
                                  setl textwidth<
                                en
                                setl nowrap
                            
                                " flag to suspend autoformat for next Insert
                                " optional user-defined mapping
                                if exists('g:pencil#map#suspend_af') && g:pencil#map#suspend_af !=# ''
                                  exe 'no <buffer> <silent> ' . g:pencil#map#suspend_af . ' :let b:pencil_suspend_af=1<CR>'
                                en
                            
                              elsei b:pencil_wrap_mode ==# s:WRAP_MODE_SOFT
    4              0.000061     setl textwidth=0
    4              0.000022     setl wrap
                            
    4              0.000019     if has('linebreak')
    4              0.000014       setl linebreak
                                  " TODO breakat not working yet with n and m-dash
    4              0.000026       setl breakat-=*         " avoid breaking footnote*
    4              0.000015       setl breakat-=@         " avoid breaking at email addresses
    4              0.000003     en
                            
    4              0.000014     if exists('&colorcolumn')
    4              0.000071       setl colorcolumn=0      " doesn't align as expected
    4              0.000003     en
    4              0.000002   el
                                setl textwidth<
                                setl wrap< nowrap<
                            
                                if has('linebreak')
                                  setl linebreak< nolinebreak<
                                  setl breakat<
                                en
                            
                                if exists('&colorcolumn')
                                  setl colorcolumn<
                                en
                              en
                            
    4              0.000017   if (  v:version > 704 ||   (v:version ==# 704 && has('patch-7.4.338')))
    4              0.000009     if b:pencil_wrap_mode ==# s:WRAP_MODE_SOFT
    4              0.000018       setl breakindent
    4              0.000003     el
                                  setl breakindent<
                                en
    4              0.000002   en
                            
                              " global settings
    4              0.000005   if b:pencil_wrap_mode
    4              0.000143     set display+=lastline
    4              0.000022     set backspace=indent,eol,start
    4              0.000020     if get(l:args, 'joinspaces', g:pencil#joinspaces)
                                  set joinspaces         " two spaces after .!?
                                el
    4              0.000015       set nojoinspaces       " only one space after a .!? (default)
    4              0.000003     en
    4              0.000002   en
                            
                              " because ve=onemore is relatively rare and could break
                              " other plugins, restrict its presence to buffer
                              " Better: restore ve to original setting
    4              0.000017   if has('virtualedit')
    4              0.000017     if b:pencil_wrap_mode && get(l:args, 'cursorwrap', g:pencil#cursorwrap)
    4              0.000021       set whichwrap+=<,>,b,s,h,l,[,]
    4              0.000019       aug pencil_cursorwrap
    4              0.000038         au BufEnter <buffer> set virtualedit+=onemore
    4              0.000020         au BufLeave <buffer> set virtualedit-=onemore
    4              0.000005       aug END
    4              0.000003     el
                                  sil! au! pencil_cursorwrap * <buffer>
                                en
    4              0.000002   en
                            
                              " Because syntax for fenced code blocks will mess with the
                              " definition of a word (via iskeyword) we'll impose a prose-
                              " oriented definition.
                              " e.g., let g:markdown_fenced_languages = ['sh',]  " adds '.'
                              "
                              " Support $20 30% D&D #40 highest-rated O'Toole Mary's
                              " TODO how to separate quote from apostrophe use?
    4              0.000009   if b:pencil_wrap_mode
    4              0.000008     aug pencil_iskeyword
    4              0.000015       au BufEnter <buffer> setl isk& | setl isk-=_ | setl isk+=$,%,&,#,-,',+
    4              0.000003     aug END
    4              0.000002   el
                                sil! au! pencil_iskeyword * <buffer>
                              en
                            
                              " window/buffer settings
    4              0.000006   if b:pencil_wrap_mode
    4              0.000020     setl nolist
    4              0.000020     setl wrapmargin=0
    4              0.000015     setl autoindent         " needed by formatoptions=n
    4              0.000019     setl indentexpr=
    4              0.000017     if has('smartindent')
    4              0.000016       setl nosmartindent      " avoid c-style indents in prose
    4              0.000003     en
    4              0.000009     if has('cindent')
    4              0.000012       setl nocindent          " avoid c-style indents in prose
    4              0.000003     en
                            
    4              0.000021     setl formatoptions+=n   " recognize numbered lists
    4              0.000015     setl formatoptions+=1   " don't break line before 1 letter word
    4              0.000014     setl formatoptions+=t   " autoformat of text (vim default)
                                "setl formatoptions+=2   " preserve indent based on 2nd line for rest of paragraph
                            
                                " clean out stuff we likely don't want
    4              0.000015     setl formatoptions-=v   " only break line at blank entered during insert
    4              0.000013     setl formatoptions-=w   " avoid erratic behavior if mixed spaces
    4              0.000013     setl formatoptions-=a   " autoformat will turn on with Insert in HardPencil mode
    4              0.000013     setl formatoptions-=2   " doesn't work with with fo+=n, says docs
                            
                                " plasticboy/vim-markdown sets these to handle bullet points
                                " as comments. Not changing for now.
                                "setl formatoptions-=o   " don't insert comment leader
                                "setl formatoptions-=c   " no autoformat of comments
                                "setl formatoptions+=r   " don't insert comment leader
                            
    4              0.000016     if has('conceal') && v:version >= 703
    4              0.000048       exe ':setl conceallevel=' . get(l:args, 'conceallevel',  g:pencil#conceallevel)
    4              0.000042       exe ':setl concealcursor=' . get(l:args, 'concealcursor', g:pencil#concealcursor)
    4              0.000003     en
    4              0.000002   el
                                if has('smartindent')
                                  setl smartindent< nosmartindent<
                                en
                                if has('cindent')
                                  setl cindent< nocindent<
                                en
                                if has('conceal')
                                  setl conceallevel<
                                  setl concealcursor<
                                en
                            
                                setl indentexpr<
                                setl autoindent< noautoindent<
                                setl list< nolist<
                                setl wrapmargin<
                                setl formatoptions<
                              en
                            
    4              0.000009   if b:pencil_wrap_mode ==# s:WRAP_MODE_SOFT
    4   0.046666   0.000249     exe 'nn <buffer> <silent>' . Mapkey('$', 'n') . ' g$'
    4   0.044085   0.000282     exe 'nn <buffer> <silent>' . Mapkey('0', 'n') . ' g0'
    4   0.044907   0.000231     exe 'vn <buffer> <silent>' . Mapkey('$', 'v') . ' g$'
    4   0.043311   0.000233     exe 'vn <buffer> <silent>' . Mapkey('0', 'v') . ' g0'
    4              0.000091     no <buffer> <silent> <Home> g<Home>
    4              0.000067     no <buffer> <silent> <End>  g<End>
    4              0.000056     nn <buffer> <silent> g0 0
    4              0.000046     nn <buffer> <silent> g$ $
    4              0.000044     vn <buffer> <silent> g0 0
    4              0.000053     vn <buffer> <silent> g$ $
                            
                                " preserve behavior of home/end keys in popups
    4   0.000402   0.000261     call s:imap(1, '<Home>', '<C-o>g<Home>')
    4   0.000343   0.000058     call s:imap(1, '<End>' , '<C-o>g<End>' )
    4              0.000003   el
                                sil! nun <buffer> $
                                sil! nun <buffer> 0
                                sil! vu  <buffer> $
                                sil! vu  <buffer> 0
                                sil! nun <buffer> <Home>
                                sil! nun <buffer> <End>
                                sil! iu  <buffer> <Home>
                                sil! iu  <buffer> <End>
                              en
                            
    4              0.000009   if b:pencil_wrap_mode
    4   0.049816   0.000181     exe 'nn <buffer> <silent> ' . Mapkey('j', 'n') . ' gj'
    4   0.041360   0.000248     exe 'nn <buffer> <silent> ' . Mapkey('k', 'n') . ' gk'
    4   0.041694   0.000226     exe 'vn <buffer> <silent> ' . Mapkey('j', 'v') . ' gj'
    4   0.040690   0.000221     exe 'vn <buffer> <silent> ' . Mapkey('k', 'v') . ' gk'
    4              0.000088     no <buffer> <silent> <Up>   gk
    4              0.000066     no <buffer> <silent> <Down> gj
    4              0.000058     nn <buffer> <silent> gj j
    4              0.000049     nn <buffer> <silent> gk k
    4              0.000050     vn <buffer> <silent> gj j
    4              0.000042     vn <buffer> <silent> gk k
                            
                                " preserve behavior of up/down keys in popups
    4   0.000213   0.000066     call s:imap(1, '<Up>'  , '<C-o>g<Up>'  )
    4   0.000162   0.000035     call s:imap(1, '<Down>', '<C-o>g<Down>')
    4              0.000003   el
                                sil! nun <buffer> j
                                sil! nun <buffer> k
                                sil! vu  <buffer> j
                                sil! vu  <buffer> k
                                sil! unm <buffer> <Up>
                                sil! unm <buffer> <Down>
                                sil! nun <buffer> gj j
                                sil! nun <buffer> gk k
                                sil! vu <buffer> gj j
                                sil! vu <buffer> gk k
                            
                                sil! iu <buffer> <Up>
                                sil! iu <buffer> <Down>
                              en
                            
                              " set undo points around common punctuation,
                              " line <c-u> and word <c-w> deletions
    4              0.000009   if b:pencil_wrap_mode
    4              0.000285     ino <buffer> . .<c-g>u
    4              0.000261     ino <buffer> ! !<c-g>u
    4              0.000046     ino <buffer> ? ?<c-g>u
    4              0.000034     ino <buffer> , ,<c-g>u
    4              0.000033     ino <buffer> ; ;<c-g>u
    4              0.000032     ino <buffer> : :<c-g>u
    4              0.000037     ino <buffer> <c-u> <c-g>u<c-u>
    4              0.000035     ino <buffer> <c-w> <c-g>u<c-w>
                            
                                " map <cr> only if not already mapped
    4              0.000061     if empty(maparg('<cr>', 'i'))
                                  ino <buffer> <cr> <c-g>u<cr>
                                  let b:pencil_cr_mapped = 1
                                el
    4              0.000010       let b:pencil_cr_mapped = 0
    4              0.000002     en
    4              0.000002   el
                                sil! iu <buffer> .
                                sil! iu <buffer> !
                                sil! iu <buffer> ?
                                sil! iu <buffer> ,
                                sil! iu <buffer> ;
                                sil! iu <buffer> :
                                sil! iu <buffer> <c-u>
                                sil! iu <buffer> <c-w>
                            
                                " unmap <cr> only if we mapped it ourselves
                                if exists('b:pencil_cr_mapped') && b:pencil_cr_mapped
                                  sil! iu <buffer> <cr>
                                en
                              en

FUNCTION  <SNR>261_uniq()
Called 3 times
Total time:   0.000076
 Self time:   0.000076

count  total (s)   self (s)
    3              0.000007   let i = 0
    3              0.000005   let seen = {}
    3              0.000013   while i < len(a:list)
                                let str = string(a:list[i])
                                if has_key(seen, str)
                                  call remove(a:list, i)
                                else
                                  let seen[str] = 1
                                  let i += 1
                                endif
                              endwhile
    3              0.000004   return a:list

FUNCTION  <SNR>158_check_diff_diff()
Called 4 times
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
    4              0.000048   return a:exitval <= 1 ? [1, a:diff] : [0, []]

FUNCTION  <SNR>172_CloseCompletionMenu()
Called 74 times
Total time:   0.000656
 Self time:   0.000553

count  total (s)   self (s)
   74              0.000203   if pumvisible()
    4   0.000175   0.000072     call s:SendKeys( "\<C-e>" )
    4              0.000010   endif

FUNCTION  <SNR>22_LoadFTPlugin()
Called 7 times
Total time:   0.113977
 Self time:   0.059658

count  total (s)   self (s)
    7              0.000056     if exists("b:undo_ftplugin")
    2              0.000090       exe b:undo_ftplugin
    2              0.000005       unlet! b:undo_ftplugin b:did_ftplugin
    2              0.000001     endif
                            
    7              0.000037     let s = expand("<amatch>")
    7              0.000015     if s != ""
    7              0.000583       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
                                  endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
   14              0.000098       for name in split(s, '\.')
    7   0.112834   0.058515 	exe 'runtime! ftplugin/' . name . '.vim ftplugin/' . name . '_*.vim ftplugin/' . name . '/*.vim'
    7              0.000110       endfor
    7              0.000007     endif

FUNCTION  xray#drawing#DrawXray()
Called 5735 times
Total time:   2.293631
 Self time:   1.143690

count  total (s)   self (s)
 5735   1.246682   0.335978   if xray#settings#GetEnable() && !xray#settings#ShouldIgnoreFiletype() && xray#highlight#CanSetHighlight()
 5735   0.164294   0.049671     if xray#mode#IsVisualOrSelectMode()
    5   0.001614   0.000127       if !xray#list#AreXrayListOptionsConfigured() && !xray#highlight#AreXrayHighlightsConfigured()
    1              0.000002         try
    1   0.001436   0.000962           call xray#highlight#SaveOriginalHighlights()
    1   0.000084   0.000068           call xray#list#SaveOriginalListOptions()
    1   0.000451   0.000086           call xray#highlight#ConfigureVisualHighlights()
    1   0.001204   0.000103           call xray#list#ConfigureListOptionsForVisualMode()
    1              0.000004         catch
                                      if xray#settings#GetVerbose()
                                        echom 'Caught exception "' . v:exception . '" from ' . v:throwpoint
                                      endif
                                      call xray#highlight#RestoreOriginalHighlights()
                                      call xray#list#RestoreOriginalListOptions()
                                    endtry
    1   0.169739   0.169728         if xray#settings#GetForceRedraw() | redraw | endif
    1              0.000001       endif
    5              0.000004     else
 5730   0.186018   0.065032       if xray#list#AreXrayListOptionsConfigured() && xray#highlight#AreXrayHighlightsConfigured()
    1   0.000240   0.000113         call xray#highlight#RestoreOriginalHighlights()
    1   0.000104   0.000060         call xray#list#RestoreOriginalListOptions()
    1   0.142956   0.142952         if xray#settings#GetForceRedraw() | redraw | endif
    1              0.000000       endif
 5730              0.004384     endif
 5735              0.004020   endif

FUNCTION  xray#settings#GetSpaceChar()
Called 2 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    2              0.000014   return get(g:, 'xray_space_char', 'Â·')

FUNCTION  sy#sign#set_signs()
Called 9 times
Total time:   0.222706
 Self time:   0.000886

count  total (s)   self (s)
    9   0.000444   0.000097   call sy#verbose('sy#sign#set_signs()', a:vcs)
                            
    9              0.000057   if a:sy.stats == [-1, -1, -1]
    3              0.000021     let a:sy.stats = [0, 0, 0]
    3              0.000002   endif
                            
    9              0.000024   if empty(a:diff)
                                call sy#verbose('No changes found.', a:vcs)
                                let a:sy.stats = [0, 0, 0]
                                call sy#sign#remove_all_signs(a:sy.buffer)
                                return
                              endif
                            
    9              0.000037   if get(g:, 'signify_line_highlight')
                                call sy#highlight#line_enable()
                              else
    9   0.001445   0.000135     call sy#highlight#line_disable()
    9              0.000009   endif
                            
    9   0.220345   0.000184   call sy#sign#process_diff(a:sy, a:vcs, a:diff)
                            
    9              0.000113   if exists('#User#Signify')
                                doautocmd <nomodeline> User Signify
                              endif

FUNCTION  <SNR>158_write_buffer()
Called 4 times
Total time:   0.005597
 Self time:   0.005597

count  total (s)   self (s)
    4              0.000114   let bufcontents = getbufline(a:bufnr, 1, '$')
                            
    4              0.000017   if bufcontents == [''] && line2byte(1) == -1
                                " Special case: completely empty buffer.
                                " A nearly empty buffer of only a newline has line2byte(1) == 1.
                                call writefile([], a:file)
                                return
                              endif
                            
    4              0.000018   if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                call map(bufcontents, 'v:val."\r"')
                              endif
                            
    4              0.000013   let fenc = getbufvar(a:bufnr, '&fileencoding')
    4              0.000018   let enc  = getbufvar(a:bufnr, '&encoding')
    4              0.000007   if fenc !=# enc
    4              0.001166     call map(bufcontents, 'iconv(v:val, "'.enc.'", "'.fenc.'")')
    4              0.000007   endif
                            
    4              0.000016   if getbufvar(a:bufnr, '&bomb')
                                let bufcontents[0]='ï»¿'.bufcontents[0]
                              endif
                            
    4              0.004140   call writefile(bufcontents, a:file)

FUNCTION  <SNR>151_int_compare()
Called 768 times
Total time:   0.002212
 Self time:   0.002212

count  total (s)   self (s)
  768              0.001758   return a:l - a:r

FUNCTION  LSP#position()
Called 424 times
Total time:   0.021299
 Self time:   0.014224

count  total (s)   self (s)
  424   0.020788   0.013714 	return { 'line': LSP#line(), 'character': LSP#character(), }

FUNCTION  <SNR>4_glob()
Called 9 times
Total time:   0.002942
 Self time:   0.002776

count  total (s)   self (s)
    9   0.002939   0.002772   return s:lines(globpath(a:from, a:pattern))

FUNCTION  ale#highlight#BufferHidden()
Called 5 times
Total time:   0.000593
 Self time:   0.000083

count  total (s)   self (s)
                                " Remove highlights right away when buffers are hidden.
                                " They will be restored later when buffers are entered.
    5   0.000564   0.000053     call ale#highlight#RemoveHighlights()

FUNCTION  neosnippet#variables#runtime_dir()
Called 1 time
Total time:   0.000762
 Self time:   0.000762

count  total (s)   self (s)
                              " Set runtime dir.
    1              0.000002   let runtime_dir = []
    1              0.000002   if g:neosnippet#enable_snipmate_compatibility
                                " Load snipMate snippet directories.
                                let runtime_dir += split(globpath(&runtimepath, 'snippets'), '\n')
                                if exists('g:snippets_dir')
                                  let runtime_dir += neosnippet#util#option2list(g:snippets_dir)
                                endif
                              endif
    1              0.000651   let runtime_dir += split(globpath(&runtimepath, 'neosnippets'), '\n')
    1              0.000005   if empty(runtime_dir) && empty(g:neosnippet#disable_runtime_snippets)
                                call neosnippet#util#print_error( 'neosnippet default snippets cannot be loaded.')
                                call neosnippet#util#print_error( 'You must install neosnippet-snippets or disable runtime snippets.')
                              endif
                            
    1              0.000085   return map(runtime_dir, 'substitute(v:val, "[\\\\/]$", "", "")')

FUNCTION  ale#command#StopJobs()
Called 29 times
Total time:   0.004852
 Self time:   0.001875

count  total (s)   self (s)
   29              0.000183     let l:info = get(s:buffer_data, a:buffer, {})
                            
   29              0.000141     if !empty(l:info)
    6              0.000023         let l:new_map = {}
                            
   12              0.000188         for [l:job_id, l:job_type] in items(l:info.jobs)
    6              0.000045             let l:job_id = str2nr(l:job_id)
                            
    6              0.000045             if a:job_type is# 'all' || a:job_type is# l:job_type
    6   0.003247   0.000270                 call ale#job#Stop(l:job_id)
    6              0.000012             else
                                            let l:new_map[l:job_id] = l:job_type
                                        endif
    6              0.000012         endfor
                            
    6              0.000059         let l:info.jobs = l:new_map
    6              0.000009     endif

FUNCTION  vista#SetProvider()
Called 10 times
Total time:   0.000671
 Self time:   0.000380

count  total (s)   self (s)
   10              0.000086   if get(t:vista, 'skip_set_provider', v:false)
                                let t:vista.skip_set_provider = v:false
                                return
                              endif
   10              0.000057   let t:vista.provider = a:provider
   10   0.000453   0.000161   call vista#statusline#Render()

FUNCTION  denite#util#rpcrequest()
Called 2 times
Total time:   0.787626
 Self time:   0.285646

count  total (s)   self (s)
    2   0.000036   0.000022   if !denite#init#_check_channel()
                                return -1
                              endif
                            
    2   0.000068   0.000054   if denite#util#has_yarp()
                                if g:denite#_yarp.job_is_dead
                                  return -1
                                endif
                                if a:is_async
                                  return g:denite#_yarp.notify(a:method, a:args)
                                else
                                  return g:denite#_yarp.request(a:method, a:args)
                                endif
                              else
    2              0.000003     if a:is_async
                                  return rpcnotify(g:denite#_channel_id, a:method, a:args)
                                else
    2   0.787475   0.285523       return rpcrequest(g:denite#_channel_id, a:method, a:args)
                                endif
                              endif

FUNCTION  <SNR>100_load()
Called 5 times
Total time:   0.000068
 Self time:   0.000068

count  total (s)   self (s)
    5              0.000040   if len(a:ns) && !has_key(s:loaded, a:ns) && len(findfile('autoload/' . a:ns . '.vim', escape(&rtp, ' ')))
                                exe 'runtime! autoload/' . a:ns . '.vim'
                                let s:loaded[a:ns] = 1
                              endif

FUNCTION  <SNR>187_BuildSignMap()
Called 17 times
Total time:   0.027662
 Self time:   0.011508

count  total (s)   self (s)
   17   0.000483   0.000185     let l:max_signs = ale#Var(a:buffer, 'max_signs')
                            
   17              0.000030     if l:max_signs is 0
                                    let l:selected_grouped_items = []
                                elseif type(l:max_signs) is v:t_number && l:max_signs > 0
                                    let l:selected_grouped_items = a:grouped_items[:l:max_signs - 1]
                                else
   17              0.000043         let l:selected_grouped_items = a:grouped_items
   17              0.000012     endif
                            
   17              0.000030     let l:sign_map = {}
   17              0.000041     let l:sign_offset = g:ale_sign_offset
                            
  202              0.000349     for [l:line, l:sign_id, l:name] in a:current_sign_list
  185              0.001064         let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
                                    " Increment the sign offset for new signs, by the maximum sign ID.
  185              0.000204         if l:sign_id > l:sign_offset
  185              0.000238             let l:sign_offset = l:sign_id
  185              0.000083         endif
                            
                                    " Remember the sign names and IDs in separate Lists, so they are easy
                                    " to work with.
  185              0.000342         call add(l:sign_info.current_id_list, l:sign_id)
  185              0.000358         call add(l:sign_info.current_name_list, l:name)
                            
  185              0.000349         let l:sign_map[l:line] = l:sign_info
  185              0.000244     endfor
                            
  202              0.000197     for l:group in l:selected_grouped_items
  185              0.000277         let l:line = l:group[0].lnum
  185              0.001482         let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
  185   0.017311   0.001456         let l:sign_info.new_name = ale#sign#GetSignName(l:group)
  185              0.000296         let l:sign_info.items = l:group
                            
  185              0.000538         let l:index = index(   l:sign_info.current_name_list,   l:sign_info.new_name)
                            
  185              0.000196         if l:index >= 0
                                        " We have a sign with this name already, so use the same ID.
  185              0.000347             let l:sign_info.new_id = l:sign_info.current_id_list[l:index]
  185              0.000110         else
                                        " This sign name replaces the previous name, so use a new ID.
                                        let l:sign_info.new_id = l:sign_offset + 1
                                        let l:sign_offset += 1
                                    endif
                            
  185              0.000380         let l:sign_map[l:line] = l:sign_info
  185              0.000096     endfor
                            
   17              0.000023     return l:sign_map

FUNCTION  <SNR>198_get_list()
Called 2 times
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    2              0.000021   if !exists('s:List')
                                let s:List = vital#of('neosnippet').import('Data.List')
                              endif
    2              0.000002   return s:List

FUNCTION  ProjectionistDetect()
Called 5 times
Total time:   0.019082
 Self time:   0.007068

count  total (s)   self (s)
    5              0.000024   let b:projectionist = {}
    5              0.000010   unlet! b:projectionist_file
    5              0.000054   if a:path =~# '^\a[[:alnum:].+-]\+:'
                                let file = substitute(a:path, '[\/]$', '', '')
                              else
    5              0.004135     let file = simplify(fnamemodify(resolve(a:path), ':p:s?[\/]$??'))
    5              0.000012   endif
                            
    5              0.000013   let root = file
    5              0.000054   let ns = matchstr(file, '^\a\a\+\ze:')
    5              0.000021   if len(ns) && get(g:, 'projectionist_ignore_' . ns)
                                return
                              endif
    5   0.000195   0.000127   call s:load(ns)
    5              0.000009   let previous = ""
   54              0.000201   while root !=# previous && root !=# '.'
   49   0.002952   0.000376     if s:nscall(ns, 'filereadable', root . '/.projections.json')
                                  try
                                    let value = projectionist#json_parse(projectionist#readfile(root . '/.projections.json'))
                                    call projectionist#append(root, value)
                                  catch /^invalid JSON:/
                                  endtry
                                endif
   49              0.000154     for [key, value] in items(g:projectionist_heuristics)
                                  for test in split(key, '|')
                                    if s:has(ns, root, test)
                                      call projectionist#append(root, value)
                                      break
                                    endif
                                  endfor
                                endfor
   49              0.000081     let previous = root
   49              0.000160     let root = fnamemodify(root, ':h')
   49              0.000131   endwhile
                            
    5              0.000035   if exists('#User#ProjectionistDetect')
    5              0.000016     if v:version >= 704 || (v:version == 703 && has('patch442'))
    5              0.000004       try
    5              0.000030         let g:projectionist_file = file
    5   0.009648   0.000277         doautocmd <nomodeline> User ProjectionistDetect
    5              0.000008       finally
    5              0.000012         unlet! g:projectionist_file
    5              0.000004       endtry
    5              0.000003     else
                                  let modelines = &modelines
                                  try
                                    set modelines=0
                                    let g:projectionist_file = file
                                    doautocmd User ProjectionistDetect
                                  finally
                                    let &modelines = modelines
                                    unlet! g:projectionist_file
                                  endtry
                                endif
    5              0.000002   endif
                            
    5              0.000023   if !empty(b:projectionist)
                                let b:projectionist_file = file
                                call projectionist#activate()
                              endif

FUNCTION  ale#semver#RunWithVersionCheck()
Called 23 times
Total time:   0.004409
 Self time:   0.000856

count  total (s)   self (s)
   23              0.000089     if empty(a:executable)
                                    return ''
                                endif
                            
   23              0.000123     let l:cache = s:version_cache
                            
   23              0.000092     if has_key(s:version_cache, a:executable)
   23   0.003991   0.000438         return a:Callback(a:buffer, s:version_cache[a:executable])
                                endif
                            
                                return ale#command#Run(   a:buffer,   a:command,   {_, output -> a:Callback(a:buffer, s:GetVersion(a:executable, output))},   {'output_stream': 'both', 'executable': a:executable})

FUNCTION  projectionist#query_raw()
Called 3 times
Total time:   0.000383
 Self time:   0.000238

count  total (s)   self (s)
    3              0.000007   let candidates = []
    3              0.000016   let file = a:0 ? a:1 : get(b:, 'projectionist_file', expand('%:p'))
    3   0.000198   0.000054   for [path, projections] in s:all()
                                let pre = path . projectionist#slash()
                                let attrs = {'project': path, 'file': file}
                                let name = file[strlen(path)+1:-1]
                                if strpart(file, 0, len(path)) !=# path
                                  let name = ''
                                endif
                                if has_key(projections, name) && has_key(projections[name], a:key)
                                  call add(candidates, [projections[name][a:key], attrs])
                                endif
                                for pattern in reverse(sort(filter(keys(projections), 'v:val =~# s:valid_key && v:val =~# "\\*"'), function('projectionist#lencmp')))
                                  let match = s:match(name, pattern)
                                  if (!empty(match) || pattern ==# '*') && has_key(projections[pattern], a:key)
                                    let expansions = extend({'match': match}, attrs)
                                    call add(candidates, [projections[pattern][a:key], expansions])
                                  endif
                                endfor
                              endfor
    3              0.000004   return candidates

FUNCTION  <lambda>50()
Called 1 time
Total time:   0.006549
 Self time:   0.000026

count  total (s)   self (s)
    1   0.006548   0.000025 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <SNR>207_flatten()
Called 2 times
Total time:   0.000146
 Self time:   0.000089

count  total (s)   self (s)
    2              0.000006   let limit = a:0 > 0 ? a:1 : -1
    2              0.000002   let memo = []
    2              0.000002   if limit == 0
                                return a:list
                              endif
    2              0.000002   let limit -= 1
    9              0.000009   for Value in a:list
    7              0.000035     let memo += type(Value) == type([]) ?   s:flatten(Value, limit) :   [Value]
    7              0.000007     unlet! Value
    7              0.000004   endfor
    2              0.000002   return memo

FUNCTION  <SNR>145_StopCurrentJobs()
Called 23 times
Total time:   0.006105
 Self time:   0.001253

count  total (s)   self (s)
   23              0.000239     let l:info = get(g:ale_buffer_info, a:buffer, {})
   23   0.005065   0.000358     call ale#command#StopJobs(a:buffer, 'linter')
                            
                                " Update the active linter list, clearing out anything not running.
   23              0.000046     if a:clear_lint_file_jobs
    6   0.000198   0.000053         call ale#command#StopJobs(a:buffer, 'file_linter')
    6              0.000034         let l:info.active_linter_list = []
    6              0.000005     else
                                    " Keep jobs for linting files when we're only linting buffers.
   17              0.000194         call filter(l:info.active_linter_list, 'get(v:val, ''lint_file'')')
   17              0.000019     endif

FUNCTION  <SNR>150_convert()
Called 203 times
Total time:   0.584913
 Self time:   0.008627

count  total (s)   self (s)
  203              0.002344   if has_key(s:lightline.component_expand, a:name)
   42              0.000264     let type = get(s:lightline.component_type, a:name, a:index)
   42              0.000290     let is_raw = get(s:lightline.component_raw, a:name) || type ==# 'raw'
   42   0.578195   0.001910     return filter(s:map(s:evaluate_expand(s:lightline.component_expand[a:name]), '[v:val, 1 + ' . is_raw . ', v:key == 1 && ' . (type !=# 'raw') . ' ? "' . type . '" : "' . a:index . '", "' . a:index . '"]'), 'v:val[0] != []')
                              else
  161              0.000972     return [[[a:name], 0, a:index, a:index]]
                              endif

FUNCTION  lightline#update_once()
Called 499 times
Total time:   0.010277
 Self time:   0.010277

count  total (s)   self (s)
  499              0.005581   if !exists('w:lightline') || w:lightline
                                call lightline#update()
                              endif

FUNCTION  <SNR>236_ShouldUseMarkdownExtension()
Called 2 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    2              0.000007   if a:source_filetype ==# 'markdown'
    2              0.000003     return v:true
                              " vimwiki can reuse the markdown extension.
                              elseif a:source_filetype ==# 'vimwiki' && vista#GetExplicitExecutive(a:source_filetype) ==# 'markdown'
                                return v:true
                              else
                                return v:false
                              endif

FUNCTION  <SNR>236_AutoUpdate()
Called 2 times
Total time:   0.000281
 Self time:   0.000216

count  total (s)   self (s)
    2   0.000054   0.000038   let source_filetype = t:vista.source.filetype()
    2   0.000125   0.000112   if s:ShouldUseMarkdownExtension(source_filetype)
    2   0.000080   0.000044     call s:ApplyAutoUpdate()
    2              0.000003   elseif source_filetype ==# 'rst'
                                call vista#extension#rst#AutoUpdate(a:fpath)
                              else
                                call vista#executive#ctags#AutoUpdate(a:fpath)
                              endif

FUNCTION  <SNR>161_AutoUpdate()
Called 12 times
Total time:   0.067782
 Self time:   0.004704

count  total (s)   self (s)
   12   0.000394   0.000238   if t:vista.source.filetype() ==# 'markdown' && get(g:, 'vista_enable'.&filetype.'_extension', 1)
    2   0.003697   0.001992     call vista#extension#{&ft}#AutoUpdate(a:fpath)
    2              0.000002   else
   10   0.007106   0.000675     call vista#OnExecute(s:provider, function('s:AutoUpdate'))
   10              0.000065     let s:reload_only = v:true
   10   0.056325   0.001539     call s:ApplyExecute(v:false, a:fpath)
   10              0.000022   endif

FUNCTION  <SNR>147_FindHistoryItem()
Called 34 times
Total time:   0.001252
 Self time:   0.000695

count  total (s)   self (s)
                                " Search backwards to find a matching job ID. IDs might be recycled,
                                " so finding the last one should be good enough.
   34   0.000903   0.000346     for l:obj in reverse(ale#history#Get(a:buffer))
   34              0.000080         if l:obj.job_id == a:job_id
   34              0.000050             return l:obj
                                    endif
                                endfor
                            
                                return {}

FUNCTION  ale#command#CreateTempFile()
Called 23 times
Total time:   0.019683
 Self time:   0.008499

count  total (s)   self (s)
   23              0.000075     if empty(a:temporary_file)
                                    " There is no file, so we didn't create anything.
                                    return 0
                                endif
                            
                                " Use an existing list of lines of input if we have it, or get the lines
                                " from the file.
   23              0.000893     let l:lines = a:input isnot v:null ? a:input : getbufline(a:buffer, 1, '$')
                            
   23              0.000621     let l:temporary_directory = fnamemodify(a:temporary_file, ':h')
                                " Create the temporary directory for the file, unreadable by 'other'
                                " users.
   23              0.005025     call mkdir(l:temporary_directory, '', 0750)
                                " Automatically delete the directory later.
   23   0.002247   0.000797     call ale#command#ManageDirectory(a:buffer, l:temporary_directory)
                                " Write the buffer out to a file.
   23   0.010337   0.000603     call ale#util#Writefile(a:buffer, l:lines, a:temporary_file)
                            
   23              0.000104     return 1

FUNCTION  neosnippet#helpers#get_snippets_files()
Called 1 time
Total time:   0.005354
 Self time:   0.004140

count  total (s)   self (s)
    1   0.001084   0.000081   let path = join(neosnippet#helpers#get_snippets_directory(), ',')
    1              0.000001   let snippets_files = []
    7   0.000276   0.000165   for glob in s:get_list().flatten( map(split(get(g:neosnippet#scope_aliases,   a:filetype, a:filetype), '\s*,\s*'), "   [v:val.'.snip', v:val.'.snippets',    v:val.'/**/*.snip', v:val.'/**/*.snippets'] + (a:filetype !=# '_' &&    !has_key(g:neosnippet#scope_aliases, a:filetype) ?    [v:val . '_*.snip', v:val . '_*.snippets'] : [])"))
    6              0.003770     let snippets_files += split(globpath(path, glob), '\n')
    6              0.000048   endfor
    1   0.000154   0.000054   return s:get_list().uniq(snippets_files)

FUNCTION  neosnippet#parser#_initialize_snippet()
Called 16 times
Total time:   0.000987
 Self time:   0.000987

count  total (s)   self (s)
   16              0.000236   let a:dict.word = substitute(a:dict.word, '\n\+$', '', '')
                            
   16              0.000059   if !has_key(a:dict, 'abbr') || a:dict.abbr ==# ''
                                " Set default abbr.
                                let abbr = ''
                                let a:dict.abbr = a:dict.name
                              else
   16              0.000026     let abbr = a:dict.abbr
   16              0.000009   endif
                            
   16              0.000169   let snippet = { 'word': a:dict.name, 'snip': a:dict.word, 'description': a:dict.word, 'menu_template': abbr, 'menu_abbr': abbr, 'options': a:dict.options, 'real_name': a:name, 'action__path': a:path, 'action__line': a:line, 'action__pattern': a:pattern,}
                            
   16              0.000049   if exists('*json_encode')
   16              0.000195     let snippet.user_data = json_encode({   'snippet': a:dict.word,   'snippet_trigger': a:dict.name, })
   16              0.000011   endif
                            
   16              0.000037   if has_key(a:dict, 'regexp')
                                let snippet.regexp = a:dict.regexp
                              endif
                            
   16              0.000021   return snippet

FUNCTION  ale#engine#HandleLoclist()
Called 17 times
Total time:   0.330505
 Self time:   0.006056

count  total (s)   self (s)
   17              0.000106     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
   17              0.000050     if empty(l:info)
                                    return
                                endif
                            
   17              0.000024     if !a:from_other_source
                                    " Remove this linter from the list of active linters.
                                    " This may have already been done when the job exits.
   17              0.000081         call filter(l:info.active_linter_list, 'v:val.name isnot# a:linter_name')
   17              0.000012     endif
                            
                                " Make some adjustments to the loclists to fix common problems, and also
                                " to set default values for loclist items.
   17   0.079881   0.000270     let l:linter_loclist = ale#engine#FixLocList(   a:buffer,   a:linter_name,   a:from_other_source,   a:loclist,)
                            
                                " Remove previous items for this linter.
   17              0.000870     call filter(l:info.loclist, 'v:val.linter_name isnot# a:linter_name')
                            
                                " We don't need to add items or sort the list when this list is empty.
   17              0.000043     if !empty(l:linter_loclist)
                                    " Add the new items.
    8              0.000131         call extend(l:info.loclist, l:linter_loclist)
                            
                                    " Sort the loclist again.
                                    " We need a sorted list so we can run a binary search against it
                                    " for efficient lookup of the messages in the cursor handler.
    8   0.022315   0.003727         call sort(l:info.loclist, 'ale#util#LocItemCompare')
    8              0.000007     endif
                            
   17   0.002567   0.000119     if ale#ShouldDoNothing(a:buffer)
                                    return
                                endif
                            
   17   0.224067   0.000266     call ale#engine#SetResults(a:buffer, l:info.loclist)

FUNCTION  <SNR>175_try_cmd()
Called 6 times
Total time:   0.332056
 Self time:   0.011260

count  total (s)   self (s)
    6              0.000105   let argv = split(a:cmd, " ")
    6   0.331591   0.010796   let out = systemlist(argv, (a:0 ? a:1 : ['']), 1)
    6              0.000098   if v:shell_error
                                if !exists('s:did_error_try_cmd')
                                  echohl WarningMsg
                                  echomsg "clipboard: error: ".(len(out) ? out[0] : v:shell_error)
                                  echohl None
                                  let s:did_error_try_cmd = 1
                                endif
                                return 0
                              endif
    6              0.000019   return out

FUNCTION  <SNR>189_matchaddpos()
Called 1212 times
Total time:   0.096514
 Self time:   0.078916

count  total (s)   self (s)
 1212              0.001980     if s:has_nvim_highlight
 2424              0.004377         for l:pos in a:pos_list
 1212              0.005045             let l:line = type(l:pos) == v:t_number   ? l:pos - 1   : l:pos[0] - 1
                            
 1212              0.004121             if type(l:pos) == v:t_number || len(l:pos) == 1
                                            let l:col_start = 0
                                            let l:col_end = s:MAX_COL_SIZE
                                        else
 1212              0.002354                 let l:col_start = l:pos[1] - 1
 1212              0.003716                 let l:col_end = l:col_start + get(l:pos, 2, 1)
 1212              0.000762             endif
                            
 1212   0.030855   0.013257             call ale#highlight#nvim_buf_add_highlight(   bufnr(''),   s:ns_id,   a:group,   l:line,   l:col_start,   l:col_end,)
 1212              0.005242         endfor
 1212              0.000832     else
                                    call matchaddpos(a:group, a:pos_list)
                                endif

FUNCTION  deoplete#custom#_init_buffer()
Called 3 times
Total time:   0.000125
 Self time:   0.000125

count  total (s)   self (s)
    3              0.000058   let b:custom = {}
    3              0.000023   let b:custom.option = {}
    3              0.000013   let b:custom.source_vars = {}
    3              0.000010   let b:custom.filter = {}

FUNCTION  test#elixir#exunit#test_file()
Called 6 times
Total time:   0.000071
 Self time:   0.000071

count  total (s)   self (s)
    6              0.000065   return a:file =~# g:test#elixir#exunit#file_pattern

FUNCTION  neosnippet#get_sync_placeholder_marker_pattern()
Called 10 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
   10              0.000021   return '<{\d\+\%(:.\{-}\)\?\\\@<!}>'

FUNCTION  ale#highlight#SetHighlights()
Called 17 times
Total time:   0.073108
 Self time:   0.002680

count  total (s)   self (s)
   17              0.000942     let l:new_list = getbufvar(a:buffer, 'ale_enabled', 1) && g:ale_enabled   ? filter(copy(a:loclist), 'v:val.bufnr == a:buffer && v:val.col > 0')   : []
                            
                                " Set the list in the buffer variable.
   17              0.001292     call setbufvar(str2nr(a:buffer), 'ale_highlight_items', l:new_list)
                            
                                " Update highlights for the current buffer, which may or may not
                                " be the buffer we just set highlights for.
   17   0.070803   0.000374     call ale#highlight#UpdateHighlights()

FUNCTION  vista#OnExecute()
Called 10 times
Total time:   0.006431
 Self time:   0.000496

count  total (s)   self (s)
   10   0.000827   0.000156   call vista#SetProvider(a:provider)
   10   0.005582   0.000318   call vista#autocmd#Init('Vista'.vista#util#ToCamelCase(a:provider), a:AUF)

FUNCTION  ale#Set()
Called 12 times
Total time:   0.000435
 Self time:   0.000435

count  total (s)   self (s)
   12              0.000284     let l:full_name = 'ale_' . a:variable_name
                            
   12              0.000051     if !has_key(g:, l:full_name)
   12              0.000064         let g:[l:full_name] = a:default
   12              0.000010     endif

FUNCTION  ale#history#Get()
Called 34 times
Total time:   0.000557
 Self time:   0.000557

count  total (s)   self (s)
   34              0.000513     return copy(getbufvar(a:buffer, 'ale_history', []))

FUNCTION  neosnippet#get_mirror_placeholder_marker_pattern()
Called 10 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
   10              0.000020   return '<|\d\+|>'

FUNCTION  <SNR>228_MapNotHasmapto()
Called 8 times
Total time:   0.000238
 Self time:   0.000238

count  total (s)   self (s)
    8              0.000213     if !hasmapto('<Plug>' . a:rhs)
                                    execute 'nmap <buffer>' . a:lhs . ' <Plug>' . a:rhs
                                    execute 'vmap <buffer>' . a:lhs . ' <Plug>' . a:rhs
                                endif

FUNCTION  <SNR>216_RestorePosn()
Called 1 time
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
                            "  call Dfunc("s:RestorePosn(posndict) curbuf#".bufnr("%")."<".bufname("%").">")
    1              0.000022   if has_key(a:posndict,bufnr("%"))
                               call winrestview(a:posndict[bufnr("%")])
                            "   call Decho("restoring posn: posndict[".bufnr("%")."]=".string(a:posndict[bufnr("%")]),'~'.expand("<slnum>"))
                              endif
                            "  call Dret("s:RestorePosn")

FUNCTION  htmlcomplete#DetectOmniFlavor()
Called 3 times
Total time:   0.000486
 Self time:   0.000486

count  total (s)   self (s)
    3              0.000017   if &filetype == 'xhtml'
                                let b:html_omni_flavor = 'xhtml10s'
                              else
    3              0.000008     let b:html_omni_flavor = 'html401t'
    3              0.000002   endif
    3              0.000004   let i = 1
    3              0.000004   let line = ""
   30              0.000074   while i < 10 && i < line("$")
   27              0.000060     let line = getline(i)
   27              0.000108     if line =~ '<!DOCTYPE.*\<DTD '
                                  break
                                endif
   27              0.000025     let i += 1
   27              0.000030   endwhile
    3              0.000013   if line =~ '<!DOCTYPE.*\<DTD '  " doctype line found above
                                if line =~ ' HTML 3\.2'
                                  let b:html_omni_flavor = 'html32'
                                elseif line =~ ' XHTML 1\.1'
                                  let b:html_omni_flavor = 'xhtml11'
                                else    " two-step detection with strict/frameset/transitional
                                  if line =~ ' XHTML 1\.0'
                            	let b:html_omni_flavor = 'xhtml10'
                                  elseif line =~ ' HTML 4\.01'
                            	let b:html_omni_flavor = 'html401'
                                  elseif line =~ ' HTML 4.0\>'
                            	let b:html_omni_flavor = 'html40'
                                  endif
                                  if line =~ '\<Transitional\>'
                            	let b:html_omni_flavor .= 't'
                                  elseif line =~ '\<Frameset\>'
                            	let b:html_omni_flavor .= 'f'
                                  else
                            	let b:html_omni_flavor .= 's'
                                  endif
                                endif
                              endif

FUNCTION  ale#util#GetMatches()
Called 17 times
Total time:   0.180630
 Self time:   0.180630

count  total (s)   self (s)
   17              0.000054     let l:matches = []
   17              0.000075     let l:lines = type(a:lines) is v:t_list ? a:lines : [a:lines]
   17              0.000081     let l:patterns = type(a:patterns) is v:t_list ? a:patterns : [a:patterns]
                            
  625              0.000959     for l:line in l:lines
  608              0.001117         for l:pattern in l:patterns
  608              0.170902             let l:match = matchlist(l:line, l:pattern)
                            
  608              0.001881             if !empty(l:match)
  608              0.001557                 call add(l:matches, l:match)
  608              0.000741                 break
                                        endif
                                    endfor
  608              0.001556     endfor
                            
   17              0.000026     return l:matches

FUNCTION  neosnippet#variables#snippets()
Called 50 times
Total time:   0.000449
 Self time:   0.000449

count  total (s)   self (s)
   50              0.000205   if !exists('s:snippets')
                                let s:snippets= {}
                              endif
                            
   50              0.000073   return s:snippets

FUNCTION  vista#ShouldSkip()
Called 13 times
Total time:   0.000312
 Self time:   0.000312

count  total (s)   self (s)
   13              0.000256   return !empty(&buftype) || empty(&filetype) || index(s:ignore_list, &filetype) > -1

FUNCTION  denite#get_status()
Called 1836 times
Total time:   0.033618
 Self time:   0.033618

count  total (s)   self (s)
 1836              0.031063   return !exists('b:denite_statusline') ? '' : get(b:denite_statusline, a:name, '')

FUNCTION  neosnippet#parser#_initialize_snippet_options()
Called 16 times
Total time:   0.000178
 Self time:   0.000178

count  total (s)   self (s)
   16              0.000169   return { 'head' : 0, 'word' :   g:neosnippet#expand_word_boundary, 'indent' : 0, 'oneshot' : 0, 'lspitem' : 0, }

FUNCTION  sy#repo#detect()
Called 3 times
Total time:   0.027781
 Self time:   0.000656

count  total (s)   self (s)
    3              0.000012   let sy = getbufvar(a:bufnr, 'sy')
    9              0.000054   for vcs in s:vcs_list
    6              0.000029     let sy.detecting += 1
    6   0.027588   0.000463     call sy#repo#get_diff(a:bufnr, vcs, function('sy#sign#set_signs'))
    6              0.000026   endfor

FUNCTION  vista#util#ToCamelCase()
Called 10 times
Total time:   0.001478
 Self time:   0.001478

count  total (s)   self (s)
   10              0.001447   return substitute(a:s, '\(^\l\+\)\|_\(\l\+\)', '\u\1\2', 'g')

FUNCTION  <SNR>23_LoadIndent()
Called 7 times
Total time:   0.012334
 Self time:   0.010110

count  total (s)   self (s)
    7              0.000042     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
                                endif
    7              0.000037     let s = expand("<amatch>")
    7              0.000014     if s != ""
    7              0.000017       if exists("b:did_indent")
    2              0.000003 	unlet b:did_indent
    2              0.000001       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
   14              0.000076       for name in split(s, '\.')
    7   0.011998   0.009774 	exe 'runtime! indent/' . name . '.vim'
    7              0.000018       endfor
    7              0.000007     endif

FUNCTION  <SNR>158_check_diff_svn()
Called 3 times
Total time:   0.000108
 Self time:   0.000108

count  total (s)   self (s)
    3              0.000093   return a:exitval ? [0, []] : [1, a:diff]

FUNCTION  xray#mode#IsVisualOrSelectMode()
Called 5735 times
Total time:   0.114623
 Self time:   0.114623

count  total (s)   self (s)
 5735              0.039386   let l:mode = mode(1)
 5735              0.038644   if l:mode ==? 'v' || l:mode ==? '' || l:mode ==? 's' || l:mode ==? ''
    5              0.000007     return v:true
                              else
 5730              0.009073     return v:false
                              endif

FUNCTION  test#test_file()
Called 6 times
Total time:   0.056010
 Self time:   0.000173

count  total (s)   self (s)
    6   0.056000   0.000164   return !empty(test#determine_runner(a:file))

FUNCTION  <SNR>172_InsideCommentOrString()
Called 69 times
Total time:   0.246508
 Self time:   0.246508

count  total (s)   self (s)
                              " Has to be col('.') -1 because col('.') doesn't exist at this point. We are
                              " in insert mode when this func is called.
   69              0.245086   let syntax_group = synIDattr( synIDtrans( synID( line( '.' ), col( '.' ) - 1, 1 ) ), 'name')
                            
   69              0.000612   if stridx(syntax_group, 'Comment') > -1
   49              0.000116     return 1
                              endif
                            
   20              0.000095   if stridx(syntax_group, 'String') > -1
                                return 2
                              endif
                            
   20              0.000034   return 0

FUNCTION  youcompleteme#CompleteFunc()
Called 28 times
Total time:   0.000621
 Self time:   0.000621

count  total (s)   self (s)
   28              0.000273   if a:findstart
   14              0.000069     return s:completion.start_column - 1
                              endif
   14              0.000061   return s:completion.candidates

FUNCTION  ale#path#IsTempName()
Called 608 times
Total time:   0.020179
 Self time:   0.006683

count  total (s)   self (s)
  608   0.019912   0.006416     return ale#path#Simplify(a:filename)[:len(s:temp_dir) - 1] is# s:temp_dir

FUNCTION  ale#linter#PreProcess()
Called 10 times
Total time:   0.008298
 Self time:   0.008119

count  total (s)   self (s)
   10              0.000057     if type(a:linter) isnot v:t_dict
                                    throw 'The linter object must be a Dictionary'
                                endif
                            
   10              0.000095     let l:obj = {   'name': get(a:linter, 'name'),   'lsp': get(a:linter, 'lsp', ''),}
                            
   10              0.000036     if type(l:obj.name) isnot v:t_string
                                    throw '`name` must be defined to name the linter'
                                endif
                            
   10              0.000032     let l:needs_address = l:obj.lsp is# 'socket'
   10              0.000028     let l:needs_executable = l:obj.lsp isnot# 'socket'
   10              0.000023     let l:needs_command = l:obj.lsp isnot# 'socket'
   10              0.000038     let l:needs_lsp_details = !empty(l:obj.lsp)
                            
   10              0.000022     if empty(l:obj.lsp)
   10              0.000042         let l:obj.callback = get(a:linter, 'callback')
                            
   10   0.000269   0.000190         if !s:IsCallback(l:obj.callback)
                                        throw '`callback` must be defined with a callback to accept output'
                                    endif
   10              0.000006     endif
                            
   10              0.000132     if index(['', 'socket', 'stdio', 'tsserver'], l:obj.lsp) < 0
                                    throw '`lsp` must be either `''lsp''`, `''stdio''`, `''socket''` or `''tsserver''` if defined'
                                endif
                            
   10              0.000015     if !l:needs_executable
                                    if has_key(a:linter, 'executable')|| has_key(a:linter, 'executable_callback')
                                        throw '`executable` and `executable_callback` cannot be used when lsp == ''socket'''
                                    endif
                                elseif has_key(a:linter, 'executable_callback')
                                    let l:obj.executable_callback = a:linter.executable_callback
                            
                                    if !s:IsCallback(l:obj.executable_callback)
                                        throw '`executable_callback` must be a callback if defined'
                                    endif
                                elseif has_key(a:linter, 'executable')
   10              0.000037         let l:obj.executable = a:linter.executable
                            
   10              0.000051         if type(l:obj.executable) isnot v:t_string&& type(l:obj.executable) isnot v:t_func
                                        throw '`executable` must be a String or Function if defined'
                                    endif
   10              0.000006     else
                                    throw 'Either `executable` or `executable_callback` must be defined'
                                endif
                            
   10              0.000012     if !l:needs_command
                                    if has_key(a:linter, 'command')|| has_key(a:linter, 'command_callback')|| has_key(a:linter, 'command_chain')
                                        throw '`command` and `command_callback` and `command_chain` cannot be used when lsp == ''socket'''
                                    endif
                                elseif has_key(a:linter, 'command_chain')
                                    let l:obj.command_chain = a:linter.command_chain
                            
                                    if type(l:obj.command_chain) isnot v:t_list
                                        throw '`command_chain` must be a List'
                                    endif
                            
                                    if empty(l:obj.command_chain)
                                        throw '`command_chain` must contain at least one item'
                                    endif
                            
                                    let l:link_index = 0
                            
                                    for l:link in l:obj.command_chain
                                        let l:err_prefix = 'The `command_chain` item ' . l:link_index . ' '
                            
                                        if !s:IsCallback(get(l:link, 'callback'))
                                            throw l:err_prefix . 'must define a `callback` function'
                                        endif
                            
                                        if has_key(l:link, 'output_stream')
                                            if type(l:link.output_stream) isnot v:t_string|| index(['stdout', 'stderr', 'both'], l:link.output_stream) < 0
                                                throw l:err_prefix . '`output_stream` flag must be '   . "'stdout', 'stderr', or 'both'"
                                            endif
                                        endif
                            
                                        if has_key(l:link, 'read_buffer') && !s:IsBoolean(l:link.read_buffer)
                                            throw l:err_prefix . 'value for `read_buffer` must be `0` or `1`'
                                        endif
                            
                                        let l:link_index += 1
                                    endfor
                                elseif has_key(a:linter, 'command_callback')
                                    let l:obj.command_callback = a:linter.command_callback
                            
                                    if !s:IsCallback(l:obj.command_callback)
                                        throw '`command_callback` must be a callback if defined'
                                    endif
                                elseif has_key(a:linter, 'command')
   10              0.000027         let l:obj.command = a:linter.command
                            
   10              0.000224         if type(l:obj.command) isnot v:t_string&& type(l:obj.command) isnot v:t_func
                                        throw '`command` must be a String or Function if defined'
                                    endif
   10              0.000005     else
                                    throw 'Either `command`, `executable_callback`, `command_chain` '   . 'must be defined'
                                endif
                            
   10              0.000061     if (   has_key(a:linter, 'command')   + has_key(a:linter, 'command_chain')   + has_key(a:linter, 'command_callback')) > 1
                                    throw 'Only one of `command`, `command_callback`, or `command_chain` '   . 'should be set'
                                endif
                            
   10              0.000012     if !l:needs_address
   10              0.000040         if has_key(a:linter, 'address') || has_key(a:linter, 'address_callback')
                                        throw '`address` or `address_callback` cannot be used when lsp != ''socket'''
                                    endif
   10              0.000025     elseif has_key(a:linter, 'address')
                                    if type(a:linter.address) isnot v:t_string&& type(a:linter.address) isnot v:t_func
                                        throw '`address` must be a String or Function if defined'
                                    endif
                            
                                    let l:obj.address = a:linter.address
                                elseif has_key(a:linter, 'address_callback')
                                    let l:obj.address_callback = a:linter.address_callback
                            
                                    if !s:IsCallback(l:obj.address_callback)
                                        throw '`address_callback` must be a callback if defined'
                                    endif
                                else
                                    throw '`address` or `address_callback` must be defined for getting the LSP address'
                                endif
                            
   10              0.000012     if l:needs_lsp_details
                                    if has_key(a:linter, 'language_callback')
                                        if has_key(a:linter, 'language')
                                            throw 'Only one of `language` or `language_callback` '   . 'should be set'
                                        endif
                            
                                        let l:obj.language_callback = get(a:linter, 'language_callback')
                            
                                        if !s:IsCallback(l:obj.language_callback)
                                            throw '`language_callback` must be a callback for LSP linters'
                                        endif
                                    else
                                        " Default to using the filetype as the language.
                                        let l:Language = get(a:linter, 'language', a:filetype)
                            
                                        if type(l:Language) is v:t_string
                                            " Make 'language_callback' return the 'language' value.
                                            let l:obj.language = l:Language
                                            let l:obj.language_callback = function('s:LanguageGetter')
                                        elseif type(l:Language) is v:t_func
                                            let l:obj.language_callback = l:Language
                                        else
                                            throw '`language` must be a String or Funcref'
                                        endif
                                    endif
                            
                                    if has_key(a:linter, 'project_root')
                                        let l:obj.project_root = a:linter.project_root
                            
                                        if type(l:obj.project_root) isnot v:t_string&& type(l:obj.project_root) isnot v:t_func
                                            throw '`project_root` must be a String or Function if defined'
                                        endif
                                    elseif has_key(a:linter, 'project_root_callback')
                                        let l:obj.project_root_callback = a:linter.project_root_callback
                            
                                        if !s:IsCallback(l:obj.project_root_callback)
                                            throw '`project_root_callback` must be a callback if defined'
                                        endif
                                    else
                                        throw '`project_root` or `project_root_callback` must be defined for LSP linters'
                                    endif
                            
                                    if has_key(a:linter, 'completion_filter')
                                        let l:obj.completion_filter = a:linter.completion_filter
                            
                                        if !s:IsCallback(l:obj.completion_filter)
                                            throw '`completion_filter` must be a callback'
                                        endif
                                    endif
                            
                                    if has_key(a:linter, 'initialization_options_callback')
                                        if has_key(a:linter, 'initialization_options')
                                            throw 'Only one of `initialization_options` or '   . '`initialization_options_callback` should be set'
                                        endif
                            
                                        let l:obj.initialization_options_callback = a:linter.initialization_options_callback
                            
                                        if !s:IsCallback(l:obj.initialization_options_callback)
                                            throw '`initialization_options_callback` must be a callback if defined'
                                        endif
                                    elseif has_key(a:linter, 'initialization_options')
                                        let l:obj.initialization_options = a:linter.initialization_options
                            
                                        if type(l:obj.initialization_options) isnot v:t_dict&& type(l:obj.initialization_options) isnot v:t_func
                                            throw '`initialization_options` must be a String or Function if defined'
                                        endif
                                    endif
                            
                                    if has_key(a:linter, 'lsp_config_callback')
                                        if has_key(a:linter, 'lsp_config')
                                            throw 'Only one of `lsp_config` or `lsp_config_callback` should be set'
                                        endif
                            
                                        let l:obj.lsp_config_callback = a:linter.lsp_config_callback
                            
                                        if !s:IsCallback(l:obj.lsp_config_callback)
                                            throw '`lsp_config_callback` must be a callback if defined'
                                        endif
                                    elseif has_key(a:linter, 'lsp_config')
                                        if type(a:linter.lsp_config) isnot v:t_dict&& type(a:linter.lsp_config) isnot v:t_func
                                            throw '`lsp_config` must be a Dictionary or Function if defined'
                                        endif
                            
                                        let l:obj.lsp_config = a:linter.lsp_config
                                    endif
                                endif
                            
   10              0.000044     let l:obj.output_stream = get(a:linter, 'output_stream', 'stdout')
                            
   10              0.001868     if type(l:obj.output_stream) isnot v:t_string|| index(['stdout', 'stderr', 'both'], l:obj.output_stream) < 0
                                    throw "`output_stream` must be 'stdout', 'stderr', or 'both'"
                                endif
                            
                                " An option indicating that this linter should only be run against the
                                " file on disk.
   10              0.000038     let l:obj.lint_file = get(a:linter, 'lint_file', 0)
                            
   10   0.000163   0.000106     if !s:IsBoolean(l:obj.lint_file)
                                    throw '`lint_file` must be `0` or `1`'
                                endif
                            
                                " An option indicating that the buffer should be read.
   10              0.000040     let l:obj.read_buffer = get(a:linter, 'read_buffer', !l:obj.lint_file)
                            
   10   0.000273   0.000231     if !s:IsBoolean(l:obj.read_buffer)
                                    throw '`read_buffer` must be `0` or `1`'
                                endif
                            
   10              0.000015     if l:obj.lint_file && l:obj.read_buffer
                                    throw 'Only one of `lint_file` or `read_buffer` can be `1`'
                                endif
                            
   10              0.000033     let l:obj.aliases = get(a:linter, 'aliases', [])
                            
   10              0.000082     if type(l:obj.aliases) isnot v:t_list|| len(filter(copy(l:obj.aliases), 'type(v:val) isnot v:t_string')) > 0
                                    throw '`aliases` must be a List of String values'
                                endif
                            
   10              0.000211     for l:key in filter(keys(a:linter), 'v:val[-9:] is# ''_callback'' || v:val is# ''command_chain''')
                                    if !get(g:, 'ale_ignore_2_4_warnings')
                                        execute 'echom l:key . '' is deprecated. Use `let g:ale_ignore_2_4_warnings = 1` to disable this message.'''
                                    endif
                            
                                    break
                                endfor
                            
   10              0.000017     return l:obj

FUNCTION  <SNR>145_HandleExit()
Called 17 times
Total time:   0.879664
 Self time:   0.002145

count  total (s)   self (s)
   17              0.000141     let l:buffer_info = get(g:ale_buffer_info, a:buffer)
                            
   17              0.000041     if empty(l:buffer_info)
                                    return
                                endif
                            
   17              0.000039     let l:linter = a:job_info.linter
   17              0.000038     let l:executable = a:job_info.executable
   17              0.000036     let l:next_chain_index = a:job_info.next_chain_index
                            
                                " Remove this job from the list.
   17   0.000444   0.000231     call ale#engine#MarkLinterInactive(l:buffer_info, l:linter.name)
                            
                                " Stop here if we land in the handle for a job completing if we're in
                                " a sandbox.
   17   0.000423   0.000102     if ale#util#InSandbox()
                                    return
                                endif
                            
   17              0.000125     if has('nvim') && !empty(a:output) && empty(a:output[-1])
                                    call remove(a:output, -1)
                                endif
                            
   17              0.000083     if l:next_chain_index < len(get(l:linter, 'command_chain', []))
                                    let [l:command, l:options] = ale#engine#ProcessChain(   a:buffer,   l:executable,   l:linter,   l:next_chain_index,   a:output,)
                            
                                    call s:RunJob(l:command, l:options)
                            
                                    return
                                endif
                            
   17              0.000012     try
   17   0.546746   0.000266         let l:loclist = ale#util#GetFunction(l:linter.callback)(a:buffer, a:output)
                                " Handle the function being unknown, or being deleted.
   17              0.000021     catch /E700/
                                    let l:loclist = []
                                endtry
                            
   17   0.330975   0.000470     call ale#engine#HandleLoclist(l:linter.name, a:buffer, l:loclist, 0)

FUNCTION  <SNR>158_get_vcs_path()
Called 13 times
Total time:   0.001436
 Self time:   0.001436

count  total (s)   self (s)
   13              0.001369   return (a:vcs =~# '\v(git|cvs|accurev|tfs|yadm)') ? getbufvar(a:bufnr, 'sy').info.file : getbufvar(a:bufnr, 'sy').info.path

FUNCTION  <SNR>205_writefile()
Called 1 time
Total time:   0.000910
 Self time:   0.000691

count  total (s)   self (s)
    1   0.000265   0.000046   let cache_name = s:_encode_name(a:cache_dir, a:filename)
                            
    1              0.000641   call writefile(a:list, cache_name)

FUNCTION  deoplete#util#has_yarp()
Called 14 times
Total time:   0.000568
 Self time:   0.000385

count  total (s)   self (s)
   14   0.000523   0.000341   return !has('nvim') || deoplete#custom#_get_option('yarp')

FUNCTION  ale#history#Add()
Called 23 times
Total time:   0.002481
 Self time:   0.002481

count  total (s)   self (s)
   23              0.000125     if g:ale_max_buffer_history_size <= 0
                                    " Don't save anything if the history isn't a positive number.
                                    call setbufvar(a:buffer, 'ale_history', [])
                            
                                    return
                                endif
                            
   23              0.000220     let l:history = getbufvar(a:buffer, 'ale_history', [])
                            
                                " Remove the first item if we hit the max history size.
   23              0.000110     if len(l:history) >= g:ale_max_buffer_history_size
    6              0.000402         let l:history = l:history[1:]
    6              0.000013     endif
                            
   23              0.000262     call add(l:history, {   'status': a:status,   'job_id': a:job_id,   'command': a:command,})
                            
   23              0.000884     call setbufvar(a:buffer, 'ale_history', l:history)

FUNCTION  lightline#highlight()
Called 1 time
Total time:   0.002110
 Self time:   0.002074

count  total (s)   self (s)
    1              0.000009   let [c, f] = [s:lightline.palette, s:lightline.mode_fallback]
    1              0.000010   let [s:lightline.llen, s:lightline.rlen] = [len(c.normal.left), len(c.normal.right)]
    1              0.000016   let [s:lightline.tab_llen, s:lightline.tab_rlen] = [len(has_key(get(c, 'tabline', {}), 'left') ? c.tabline.left : c.normal.left), len(has_key(get(c, 'tabline', {}), 'right') ? c.tabline.right : c.normal.right)]
    1              0.000025   let types = map(s:uniq(sort(filter(values(s:lightline.component_type), 'v:val !=# "raw"'))), '[v:val, 1]')
    1              0.000005   let modes = a:0 ? [a:1] : extend(['normal', 'insert', 'replace', 'visual', 'inactive', 'command', 'select', 'tabline'], exists(':terminal') == 2 ? ['terminal'] : [])
    2              0.000004   for mode in modes
    1              0.000003     let s:highlight[mode] = 1
    1              0.000005     let d = has_key(c, mode) ? mode : has_key(f, mode) && has_key(c, f[mode]) ? f[mode] : 'normal'
    1              0.000008     let left = d ==# 'tabline' ? s:lightline.tabline.left : d ==# 'inactive' ? s:lightline.inactive.left : s:lightline.active.left
    1              0.000004     let right = d ==# 'tabline' ? s:lightline.tabline.right : d ==# 'inactive' ? s:lightline.inactive.right : s:lightline.active.right
    1              0.000009     let ls = has_key(get(c, d, {}), 'left') ? c[d].left : has_key(f, d) && has_key(get(c, f[d], {}), 'left') ? c[f[d]].left : c.normal.left
    1              0.000009     let ms = has_key(get(c, d, {}), 'middle') ? c[d].middle[0] : has_key(f, d) && has_key(get(c, f[d], {}), 'middle') ? c[f[d]].middle[0] : c.normal.middle[0]
    1              0.000007     let rs = has_key(get(c, d, {}), 'right') ? c[d].right : has_key(f, d) && has_key(get(c, f[d], {}), 'right') ? c[f[d]].right : c.normal.right
    3              0.000011     for [p, l, zs] in [['Left', len(left), ls], ['Right', len(right), rs]]
   11              0.000032       for [i, t] in map(range(0, l), '[v:val, 0]') + types
    9              0.000012         if i < l || i < 1
    7              0.000054           let r = t ? (has_key(get(c, d, []), i) ? c[d][i][0] : has_key(get(c, 'tabline', {}), i) ? c.tabline[i][0] : get(c.normal, i, zs)[0]) : get(zs, i, ms)
    7   0.000502   0.000469           exec printf('hi Lightline%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', p, mode, i, r[0], r[1], r[2], r[3], s:term(r))
    7              0.000007         endif
   50              0.000145         for [j, s] in map(range(0, l), '[v:val, 0]') + types
   41              0.000066           if i + 1 == j || t || s && i != l
   19              0.000165             let q = s ? (has_key(get(c, d, []), j) ? c[d][j][0] : has_key(get(c, 'tabline', {}), j) ? c.tabline[j][0] : get(c.normal, j, zs)[0]) : (j != l ? get(zs, j, ms) :ms)
   19              0.000431             exec printf('hi Lightline%s_%s_%s_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s', p, mode, i, j, r[1], q[1], r[3], q[3])
   19              0.000013           endif
   41              0.000049         endfor
    9              0.000004       endfor
    2              0.000001     endfor
    1   0.000024   0.000021     exec printf('hi LightlineMiddle_%s guifg=%s guibg=%s ctermfg=%s ctermbg=%s %s', mode, ms[0], ms[1], ms[2], ms[3], s:term(ms))
    1              0.000001   endfor

FUNCTION  <SNR>198_get_sources_filetypes()
Called 11 times
Total time:   0.002220
 Self time:   0.000595

count  total (s)   self (s)
   11              0.000265   let filetypes = exists('*context_filetype#get_filetypes') ?   context_filetype#get_filetypes(a:filetype) : split(((a:filetype ==# '') ? 'nothing' : a:filetype), '\.')
   11   0.001912   0.000288   return neosnippet#util#uniq(['_'] + filetypes + [a:filetype])

FUNCTION  <SNR>216_NetrwOptionRestore()
Called 1 time
Total time:   0.000364
 Self time:   0.000318

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwOptionRestore(vt<".a:vt.">) win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> winnr($)=".winnr("$"))
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))
    1              0.000032   if !exists("{a:vt}netrw_optionsave")
    1   0.000310   0.000263    call s:RestorePosn(s:netrw_nbcd)
                            "   call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))
                            "   call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                            "   call Dret("s:NetrwOptionRestore : ".a:vt."netrw_optionsave doesn't exist")
    1              0.000004    return
                              endif
                              unlet {a:vt}netrw_optionsave
                            
                              if exists("+acd")
                               if exists("{a:vt}netrw_acdkeep")
                            "    call Decho("g:netrw_keepdir=".g:netrw_keepdir.": getcwd<".getcwd()."> acd=".&acd,'~'.expand("<slnum>"))
                                let curdir = getcwd()
                                let &l:acd = {a:vt}netrw_acdkeep
                                unlet {a:vt}netrw_acdkeep
                                if &l:acd
                                 call s:NetrwLcd(curdir)
                                endif
                               endif
                              endif
                              if exists("{a:vt}netrw_aikeep")   |let &l:ai     = {a:vt}netrw_aikeep      |unlet {a:vt}netrw_aikeep   |endif
                              if exists("{a:vt}netrw_awkeep")   |let &l:aw     = {a:vt}netrw_awkeep      |unlet {a:vt}netrw_awkeep   |endif
                              if exists("{a:vt}netrw_blkeep")   |let &l:bl     = {a:vt}netrw_blkeep      |unlet {a:vt}netrw_blkeep   |endif
                              if exists("{a:vt}netrw_btkeep")   |let &l:bt     = {a:vt}netrw_btkeep      |unlet {a:vt}netrw_btkeep   |endif
                              if exists("{a:vt}netrw_bombkeep") |let &l:bomb   = {a:vt}netrw_bombkeep    |unlet {a:vt}netrw_bombkeep |endif
                              if exists("{a:vt}netrw_cedit")    |let &cedit    = {a:vt}netrw_cedit       |unlet {a:vt}netrw_cedit    |endif
                              if exists("{a:vt}netrw_cikeep")   |let &l:ci     = {a:vt}netrw_cikeep      |unlet {a:vt}netrw_cikeep   |endif
                              if exists("{a:vt}netrw_cinkeep")  |let &l:cin    = {a:vt}netrw_cinkeep     |unlet {a:vt}netrw_cinkeep  |endif
                              if exists("{a:vt}netrw_cinokeep") |let &l:cino   = {a:vt}netrw_cinokeep    |unlet {a:vt}netrw_cinokeep |endif
                              if exists("{a:vt}netrw_comkeep")  |let &l:com    = {a:vt}netrw_comkeep     |unlet {a:vt}netrw_comkeep  |endif
                              if exists("{a:vt}netrw_cpokeep")  |let &l:cpo    = {a:vt}netrw_cpokeep     |unlet {a:vt}netrw_cpokeep  |endif
                              if exists("{a:vt}netrw_diffkeep") |let &l:diff   = {a:vt}netrw_diffkeep    |unlet {a:vt}netrw_diffkeep |endif
                              if exists("{a:vt}netrw_fenkeep")  |let &l:fen    = {a:vt}netrw_fenkeep     |unlet {a:vt}netrw_fenkeep  |endif
                              if exists("g:netrw_ffkep") && g:netrw_ffkeep
                               if exists("{a:vt}netrw_ffkeep")   |let &l:ff     = {a:vt}netrw_ffkeep      |unlet {a:vt}netrw_ffkeep   |endif
                              endif
                              if exists("{a:vt}netrw_fokeep")   |let &l:fo     = {a:vt}netrw_fokeep      |unlet {a:vt}netrw_fokeep   |endif
                              if exists("{a:vt}netrw_gdkeep")   |let &l:gd     = {a:vt}netrw_gdkeep      |unlet {a:vt}netrw_gdkeep   |endif
                              if exists("{a:vt}netrw_hidkeep")  |let &l:hidden = {a:vt}netrw_hidkeep     |unlet {a:vt}netrw_hidkeep  |endif
                              if exists("{a:vt}netrw_imkeep")   |let &l:im     = {a:vt}netrw_imkeep      |unlet {a:vt}netrw_imkeep   |endif
                              if exists("{a:vt}netrw_iskkeep")  |let &l:isk    = {a:vt}netrw_iskkeep     |unlet {a:vt}netrw_iskkeep  |endif
                              if exists("{a:vt}netrw_lskeep")   |let &l:ls     = {a:vt}netrw_lskeep      |unlet {a:vt}netrw_lskeep   |endif
                              if exists("{a:vt}netrw_makeep")   |let &l:ma     = {a:vt}netrw_makeep      |unlet {a:vt}netrw_makeep   |endif
                              if exists("{a:vt}netrw_magickeep")|let &l:magic  = {a:vt}netrw_magickeep   |unlet {a:vt}netrw_magickeep|endif
                              if exists("{a:vt}netrw_modkeep")  |let &l:mod    = {a:vt}netrw_modkeep     |unlet {a:vt}netrw_modkeep  |endif
                              if exists("{a:vt}netrw_nukeep")   |let &l:nu     = {a:vt}netrw_nukeep      |unlet {a:vt}netrw_nukeep   |endif
                              if exists("{a:vt}netrw_rnukeep")  |let &l:rnu    = {a:vt}netrw_rnukeep     |unlet {a:vt}netrw_rnukeep  |endif
                              if exists("{a:vt}netrw_repkeep")  |let &l:report = {a:vt}netrw_repkeep     |unlet {a:vt}netrw_repkeep  |endif
                              if exists("{a:vt}netrw_rokeep")   |let &l:ro     = {a:vt}netrw_rokeep      |unlet {a:vt}netrw_rokeep   |endif
                              if exists("{a:vt}netrw_selkeep")  |let &l:sel    = {a:vt}netrw_selkeep     |unlet {a:vt}netrw_selkeep  |endif
                              if exists("{a:vt}netrw_spellkeep")|let &l:spell  = {a:vt}netrw_spellkeep   |unlet {a:vt}netrw_spellkeep|endif
                              if has("clipboard")
                               if exists("{a:vt}netrw_starkeep") |let @*        = {a:vt}netrw_starkeep    |unlet {a:vt}netrw_starkeep |endif
                              endif
                              " Problem: start with liststyle=0; press <i> : result, following line resets l:ts.
                            "  if exists("{a:vt}netrw_tskeep")   |let &l:ts     = {a:vt}netrw_tskeep      |unlet {a:vt}netrw_tskeep   |endif
                              if exists("{a:vt}netrw_twkeep")   |let &l:tw     = {a:vt}netrw_twkeep      |unlet {a:vt}netrw_twkeep   |endif
                              if exists("{a:vt}netrw_wigkeep")  |let &l:wig    = {a:vt}netrw_wigkeep     |unlet {a:vt}netrw_wigkeep  |endif
                              if exists("{a:vt}netrw_wrapkeep") |let &l:wrap   = {a:vt}netrw_wrapkeep    |unlet {a:vt}netrw_wrapkeep |endif
                              if exists("{a:vt}netrw_writekeep")|let &l:write  = {a:vt}netrw_writekeep   |unlet {a:vt}netrw_writekeep|endif
                              if exists("s:yykeep")             |let  @@       = s:yykeep                |unlet s:yykeep             |endif
                              if exists("{a:vt}netrw_swfkeep")
                               if &directory == ""
                                " user hasn't specified a swapfile directory;
                                " netrw will temporarily set the swapfile directory
                                " to the current directory as returned by getcwd().
                                let &l:directory= getcwd()
                                sil! let &l:swf = {a:vt}netrw_swfkeep
                                setl directory=
                                unlet {a:vt}netrw_swfkeep
                               elseif &l:swf != {a:vt}netrw_swfkeep
                                if !g:netrw_use_noswf
                                 " following line causes a Press ENTER in windows -- can't seem to work around it!!!
                                 sil! let &l:swf= {a:vt}netrw_swfkeep
                                endif
                                unlet {a:vt}netrw_swfkeep
                               endif
                              endif
                              if exists("{a:vt}netrw_dirkeep") && isdirectory(s:NetrwFile({a:vt}netrw_dirkeep)) && g:netrw_keepdir
                               let dirkeep = substitute({a:vt}netrw_dirkeep,'\\','/','g')
                               if exists("{a:vt}netrw_dirkeep")
                                call s:NetrwLcd(dirkeep)
                                unlet {a:vt}netrw_dirkeep
                               endif
                              endif
                              if has("clipboard")
                               if exists("{a:vt}netrw_regstar") |sil! let @*= {a:vt}netrw_regstar |unlet {a:vt}netrw_regstar |endif
                              endif
                              if exists("{a:vt}netrw_regslash")|sil! let @/= {a:vt}netrw_regslash|unlet {a:vt}netrw_regslash|endif
                              call s:RestorePosn(s:netrw_nbcd)
                            
                            "  call Decho("g:netrw_keepdir=".g:netrw_keepdir.": getcwd<".getcwd()."> acd=".&acd,'~'.expand("<slnum>"))
                            "  call Decho("fo=".&fo.(exists("+acd")? " acd=".&acd : " acd doesn't exist"),'~'.expand("<slnum>"))
                            "  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)",'~'.expand("<slnum>"))
                            "  call Decho("diff=".&l:diff." win#".winnr()." w:netrw_diffkeep=".(exists("w:netrw_diffkeep")? w:netrw_diffkeep : "doesn't exist"),'~'.expand("<slnum>"))
                            "  call Decho("ts=".&l:ts,'~'.expand("<slnum>"))
                              " Moved the filetype detect here from NetrwGetFile() because remote files
                              " were having their filetype detect-generated settings overwritten by
                              " NetrwOptionRestore.
                              if &ft != "netrw"
                            "   call Decho("filetype detect  (ft=".&ft.")",'~'.expand("<slnum>"))
                               filetype detect
                              endif
                            "  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo." a:vt=".a:vt,'~'.expand("<slnum>"))
                            "  call Dret("s:NetrwOptionRestore : tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> modified=".&modified." modifiable=".&modifiable." readonly=".&readonly)

FUNCTION  <SNR>221_start()
Called 1 time
Total time:   0.399153
 Self time:   0.000346

count  total (s)   self (s)
    1   0.000147   0.000023   if denite#initialize()
                                return
                              endif
                            
                              " Add current position to the jumplist.
    1              0.000004   let pos = getpos('.')
    1              0.000007   execute line('.')
    1              0.000003   call setpos('.', pos)
                            
    1              0.000003   let args = [a:sources, a:user_context]
    1   0.398984   0.000301   return denite#util#rpcrequest('_denite_start', args, v:false)

FUNCTION  <SNR>139_is_sudo()
Called 14 times
Total time:   0.000214
 Self time:   0.000214

count  total (s)   self (s)
   14              0.000200   return $SUDO_USER != '' && $USER !=# $SUDO_USER && $HOME !=# expand('~'.$USER) && $HOME ==# expand('~'.$SUDO_USER)

FUNCTION  <SNR>168_vimoption2python()
Called 9 times
Total time:   0.009468
 Self time:   0.007237

count  total (s)   self (s)
    9              0.000046   let has_dash = 0
    9              0.000025   let patterns = []
  122              0.000395   for pattern in split(a:option, ',')
  113              0.001462     if pattern =~# '\d\+'
   11              0.000583       let pattern = substitute(pattern, '\d\+', '\=nr2char(submatch(0))', 'g')
   11              0.000016     endif
                            
  113              0.000190     if pattern ==# ''
                                  " ,
   14              0.000043       call add(patterns, ',')
   14              0.000013     elseif pattern ==# '\'
                                  call add(patterns, '\\')
                                elseif pattern ==# '-'
    8              0.000012       let has_dash = 1
    8              0.000006     else
                                  " Avoid ambiguous Python 3 RE syntax for nested sets
   91              0.000466       if pattern =~# '^--'
                                    let pattern = '\' . pattern
                                  elseif pattern =~# '--$'
                                    let pattern = split(pattern, '-')[0] . '-\-'
                                  endif
                            
   91              0.000309       call add(patterns, pattern)
   91              0.000055     endif
  113              0.000203   endfor
                            
                              " Dash must be last.
    9              0.000012   if has_dash
    8              0.000021     call add(patterns, '-')
    8              0.000006   endif
                            
    9   0.002908   0.000677   return join(deoplete#util#uniq(patterns), '')

FUNCTION  <lambda>35()
Called 1 time
Total time:   0.792358
 Self time:   0.000064

count  total (s)   self (s)
    1   0.792357   0.000063 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>36()
Called 1 time
Total time:   0.010911
 Self time:   0.000035

count  total (s)   self (s)
    1   0.010909   0.000033 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>37()
Called 1 time
Total time:   0.000065
 Self time:   0.000041

count  total (s)   self (s)
    1   0.000063   0.000040 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <SNR>216_NetrwHome()
Called 1 time
Total time:   0.001133
 Self time:   0.000953

count  total (s)   self (s)
    1              0.000018   if exists("g:netrw_home")
    1              0.000008    let home= g:netrw_home
    1              0.000002   else
                               " go to vim plugin home
                               for home in split(&rtp,',') + ['']
                                if isdirectory(s:NetrwFile(home)) && filewritable(s:NetrwFile(home)) | break | endif
                                 let basehome= substitute(home,'[/\\]\.vim$','','')
                                 if isdirectory(s:NetrwFile(basehome)) && filewritable(s:NetrwFile(basehome))
                                 let home= basehome."/.vim"
                                 break
                                endif
                               endfor
                               if home == ""
                                " just pick the first directory
                                let home= substitute(&rtp,',.*$','','')
                               endif
                               if (has("win32") || has("win95") || has("win64") || has("win16"))
                                let home= substitute(home,'/','\\','g')
                               endif
                              endif
                              " insure that the home directory exists
    1   0.000866   0.000686   if g:netrw_dirhistmax > 0 && !isdirectory(s:NetrwFile(home))
                               if exists("g:netrw_mkdir")
                                call system(g:netrw_mkdir." ".s:ShellEscape(s:NetrwFile(home)))
                               else
                                call mkdir(home)
                               endif
                              endif
    1              0.000010   let g:netrw_home= home
    1              0.000005   return home

FUNCTION  ale#linter#GetExecutable()
Called 23 times
Total time:   0.002114
 Self time:   0.000883

count  total (s)   self (s)
   23              0.000310     let l:Executable = has_key(a:linter, 'executable_callback')   ? function(a:linter.executable_callback)   : a:linter.executable
                            
   23   0.001746   0.000515     return type(l:Executable) is v:t_func   ? l:Executable(a:buffer)   : l:Executable

FUNCTION  deoplete#init#_channel_initialized()
Called 14 times
Total time:   0.000177
 Self time:   0.000177

count  total (s)   self (s)
   14              0.000135   return get(g:, 'deoplete#_initialized', v:false)

FUNCTION  xray#settings#ShouldIgnoreFiletype()
Called 5735 times
Total time:   0.715896
 Self time:   0.583292

count  total (s)   self (s)
 5735   0.167902   0.109356   if len(xray#settings#GetAllowedFiletypes()) > 0
                                if count(xray#settings#GetAllowedFiletypes(), &l:filetype) > 0
                                  return v:false
                                else
                                  return v:true
                                endif
                              else
 5735   0.396215   0.322158     if count(xray#settings#GetIgnoredFiletypes(), &l:filetype) > 0
                                  return v:true
                                else
 5735              0.015861       return v:false
                                endif
                              endif

FUNCTION  <SNR>216_NetrwEnew()
Called 1 time
Total time:   0.126048
 Self time:   0.003542

count  total (s)   self (s)
                            "  call Dfunc("s:NetrwEnew() a:0=".a:0." bufnr($)=".bufnr("$"))
                            "  call Decho("curdir<".((a:0>0)? a:1 : "")."> buf#".bufnr("%")."<".bufname("%").">",'~'.expand("<slnum>"))
                            
                              " grab a function-local-variable copy of buffer variables
                            "  call Decho("make function-local copy of netrw variables",'~'.expand("<slnum>"))
    1              0.000038   if exists("b:netrw_bannercnt")      |let netrw_bannercnt       = b:netrw_bannercnt      |endif
    1              0.000015   if exists("b:netrw_browser_active") |let netrw_browser_active  = b:netrw_browser_active |endif
    1              0.000015   if exists("b:netrw_cpf")            |let netrw_cpf             = b:netrw_cpf            |endif
    1              0.000020   if exists("b:netrw_curdir")         |let netrw_curdir          = b:netrw_curdir         |endif
    1              0.000014   if exists("b:netrw_explore_bufnr")  |let netrw_explore_bufnr   = b:netrw_explore_bufnr  |endif
    1              0.000011   if exists("b:netrw_explore_indx")   |let netrw_explore_indx    = b:netrw_explore_indx   |endif
    1              0.000011   if exists("b:netrw_explore_line")   |let netrw_explore_line    = b:netrw_explore_line   |endif
    1              0.000011   if exists("b:netrw_explore_list")   |let netrw_explore_list    = b:netrw_explore_list   |endif
    1              0.000012   if exists("b:netrw_explore_listlen")|let netrw_explore_listlen = b:netrw_explore_listlen|endif
    1              0.000012   if exists("b:netrw_explore_mtchcnt")|let netrw_explore_mtchcnt = b:netrw_explore_mtchcnt|endif
    1              0.000011   if exists("b:netrw_fname")          |let netrw_fname           = b:netrw_fname          |endif
    1              0.000011   if exists("b:netrw_lastfile")       |let netrw_lastfile        = b:netrw_lastfile       |endif
    1              0.000010   if exists("b:netrw_liststyle")      |let netrw_liststyle       = b:netrw_liststyle      |endif
    1              0.000011   if exists("b:netrw_method")         |let netrw_method          = b:netrw_method         |endif
    1              0.000010   if exists("b:netrw_option")         |let netrw_option          = b:netrw_option         |endif
    1              0.000010   if exists("b:netrw_prvdir")         |let netrw_prvdir          = b:netrw_prvdir         |endif
                            
    1   0.002175   0.001811   NetrwKeepj call s:NetrwOptionRestore("w:")
                            "  call Decho("generate a buffer with NetrwKeepj keepalt enew!",'~'.expand("<slnum>"))
                              " when tree listing uses file TreeListing... a new buffer is made.
                              " Want the old buffer to be unlisted.
                              " COMBAK: this causes a problem, see P43
                            "  setl nobl
    1              0.000012   let netrw_keepdiff= &l:diff
    1              0.000382   noswapfile NetrwKeepj keepalt enew!
    1              0.000021   let &l:diff= netrw_keepdiff
                            "  call Decho("bufnr($)=".bufnr("$")."<".bufname(bufnr("$"))."> winnr($)=".winnr("$"),'~'.expand("<slnum>"))
    1   0.122870   0.000728   NetrwKeepj call s:NetrwOptionSave("w:")
                            
                              " copy function-local-variables to buffer variable equivalents
                            "  call Decho("copy function-local variables back to buffer netrw variables",'~'.expand("<slnum>"))
    1              0.000021   if exists("netrw_bannercnt")      |let b:netrw_bannercnt       = netrw_bannercnt      |endif
    1              0.000013   if exists("netrw_browser_active") |let b:netrw_browser_active  = netrw_browser_active |endif
    1              0.000010   if exists("netrw_cpf")            |let b:netrw_cpf             = netrw_cpf            |endif
    1              0.000016   if exists("netrw_curdir")         |let b:netrw_curdir          = netrw_curdir         |endif
    1              0.000013   if exists("netrw_explore_bufnr")  |let b:netrw_explore_bufnr   = netrw_explore_bufnr  |endif
    1              0.000012   if exists("netrw_explore_indx")   |let b:netrw_explore_indx    = netrw_explore_indx   |endif
    1              0.000011   if exists("netrw_explore_line")   |let b:netrw_explore_line    = netrw_explore_line   |endif
    1              0.000011   if exists("netrw_explore_list")   |let b:netrw_explore_list    = netrw_explore_list   |endif
    1              0.000012   if exists("netrw_explore_listlen")|let b:netrw_explore_listlen = netrw_explore_listlen|endif
    1              0.000011   if exists("netrw_explore_mtchcnt")|let b:netrw_explore_mtchcnt = netrw_explore_mtchcnt|endif
    1              0.000010   if exists("netrw_fname")          |let b:netrw_fname           = netrw_fname          |endif
    1              0.000010   if exists("netrw_lastfile")       |let b:netrw_lastfile        = netrw_lastfile       |endif
    1              0.000011   if exists("netrw_liststyle")      |let b:netrw_liststyle       = netrw_liststyle      |endif
    1              0.000010   if exists("netrw_method")         |let b:netrw_method          = netrw_method         |endif
    1              0.000010   if exists("netrw_option")         |let b:netrw_option          = netrw_option         |endif
    1              0.000010   if exists("netrw_prvdir")         |let b:netrw_prvdir          = netrw_prvdir         |endif
                            
    1              0.000005   if a:0 > 0
                               let b:netrw_curdir= a:1
                               if b:netrw_curdir =~ '/$'
                                if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
                                 setl nobl
                                 file NetrwTreeListing
                                 setl nobl bt=nowrite bh=hide
                                 nno <silent> <buffer> [	:sil call <SID>TreeListMove('[')<cr>
                                 nno <silent> <buffer> ]	:sil call <SID>TreeListMove(']')<cr>
                                else
                                 exe "sil! keepalt file ".fnameescape(b:netrw_curdir)
                                endif
                               endif
                              endif
                            
                            "  call Dret("s:NetrwEnew : buf#".bufnr("%")."<".bufname("%")."> expand(%)<".expand("%")."> expand(#)<".expand("#")."> bh=".&bh." win#".winnr()." winnr($)#".winnr("$"))

FUNCTION  LanguageClient#handleTextChanged()
Called 82 times
Total time:   0.035865
 Self time:   0.004971

count  total (s)   self (s)
   82              0.001035     if &buftype !=# '' || &filetype ==# '' || expand('%') ==# ''
    1              0.000002         return
                                endif
                            
   81              0.000085     try
                                    " Note: do not add 'text' as it might be huge.
   81   0.033298   0.002404         call LanguageClient#Notify('languageClient/handleTextChanged', { 'filename': LSP#filename(), })
   81              0.000154     catch
                                    call s:Debug('LanguageClient caught exception: ' . string(v:exception))
                                endtry

FUNCTION  ale#util#GetFunction()
Called 73 times
Total time:   0.000954
 Self time:   0.000954

count  total (s)   self (s)
   73              0.000386     if type(a:string_or_ref) is v:t_string
   17              0.000060         return function(a:string_or_ref)
                                endif
                            
   56              0.000097     return a:string_or_ref

FUNCTION  deoplete#util#vimoption2python_not()
Called 7 times
Total time:   0.008455
 Self time:   0.000308

count  total (s)   self (s)
    7   0.008422   0.000275   return '[^\w' . s:vimoption2python(a:option) . ']'

FUNCTION  <SNR>118_Highlight_Matching_Pair()
Called 647 times
Total time:   0.392950
 Self time:   0.392950

count  total (s)   self (s)
                              " Remove any previous match.
  647              0.006509   if exists('w:paren_hl_on') && w:paren_hl_on
   16              0.000088     silent! call matchdelete(3)
   16              0.000046     let w:paren_hl_on = 0
   16              0.000015   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  647              0.005147   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  647              0.003424   let c_lnum = line('.')
  647              0.002471   let c_col = col('.')
  647              0.001130   let before = 0
                            
  647              0.003813   let text = getline(c_lnum)
  647              0.073984   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
  647              0.003124   if empty(matches)
                                let [c_before, c] = ['', '']
                              else
  647              0.004895     let [c_before, c] = matches[1:2]
  647              0.000889   endif
  647              0.089035   let plist = split(&matchpairs, '.\zs[:,]')
  647              0.006501   let i = index(plist, c)
  647              0.001506   if i < 0
                                " not found, in Insert mode try character before the cursor
  632              0.003994     if c_col > 1 && (mode() == 'i' || mode() == 'R')
  144              0.000893       let before = strlen(c_before)
  144              0.000270       let c = c_before
  144              0.000444       let i = index(plist, c)
  144              0.000235     endif
  632              0.000867     if i < 0
                                  " not found, nothing to do
  632              0.001045       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
   15              0.000020   if i % 2 == 0
   14              0.000022     let s_flags = 'nW'
   14              0.000035     let c2 = plist[i + 1]
   14              0.000010   else
    1              0.000002     let s_flags = 'nbW'
    1              0.000002     let c2 = c
    1              0.000003     let c = plist[i - 1]
    1              0.000001   endif
   15              0.000031   if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
   15              0.000018   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
   15              0.000100   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
   15              0.000079     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
   15              0.000027     try
   15              0.032751       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
   15              0.000039     catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
   15              0.000011   endif
                            
                              " Limit the search to lines visible in the window.
   15              0.000161   let stoplinebottom = line('w$')
   15              0.000079   let stoplinetop = line('w0')
   15              0.000039   if i % 2 == 0
   14              0.000070     let stopline = stoplinebottom
   14              0.000014   else
    1              0.000004     let stopline = stoplinetop
    1              0.000001   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
   15              0.000076   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
   15              0.000090     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
   15              0.000010   endif
   15              0.000014   try
   15              0.118330     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
   15              0.000068   catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
   15              0.000036   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
   15              0.000074   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
   15              0.000072     if exists('*matchaddpos')
   15              0.001364       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
   15              0.000024     else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
   15              0.000081     let w:paren_hl_on = 1
   15              0.000013   endif

FUNCTION  ale#util#Tempname()
Called 23 times
Total time:   0.000874
 Self time:   0.000874

count  total (s)   self (s)
   23              0.000062     let l:clear_tempdir = 0
                            
   23              0.000146     if exists('$TMPDIR') && empty($TMPDIR)
                                    let l:clear_tempdir = 1
                                    let $TMPDIR = '/tmp'
                                endif
                            
   23              0.000023     try
   23              0.000196         let l:name = tempname() " no-custom-checks
   23              0.000040     finally
   23              0.000038         if l:clear_tempdir
                                        let $TMPDIR = ''
                                    endif
   23              0.000024     endtry
                            
   23              0.000040     return l:name

FUNCTION  <lambda>41()
Called 1 time
Total time:   0.002571
 Self time:   0.000047

count  total (s)   self (s)
    1   0.002569   0.000045 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>45()
Called 1 time
Total time:   0.002905
 Self time:   0.000047

count  total (s)   self (s)
    1   0.002903   0.000044 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>46()
Called 1 time
Total time:   0.003076
 Self time:   0.000029

count  total (s)   self (s)
    1   0.003075   0.000028 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>47()
Called 1 time
Total time:   0.002099
 Self time:   0.000027

count  total (s)   self (s)
    1   0.002098   0.000025 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <SNR>236_ApplyAutoUpdate()
Called 2 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    2              0.000010   if has_key(t:vista, 'bufnr') && t:vista.winnr() != -1
                                call vista#SetProvider(s:provider)
                                let rendered = vista#renderer#markdown_like#MD(s:GatherHeaderMetadata())
                                call vista#util#SetBufline(t:vista.bufnr, rendered)
                              endif

FUNCTION  <SNR>172_OnInsertLeave()
Called 7 times
Total time:   0.194227
 Self time:   0.086504

count  total (s)   self (s)
    7   0.000306   0.000123   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
    7              0.000064   call timer_stop( s:pollers.completion.id )
    7              0.000045   let s:force_semantic = 0
    7              0.000132   let s:completion = s:default_completion
                            
    7   0.107659   0.000120   call s:OnFileReadyToParse()
    7              0.085759   exec s:python_command "ycm_state.OnInsertLeave()"
    7              0.000087   if g:ycm_autoclose_preview_window_after_completion || g:ycm_autoclose_preview_window_after_insertion
                                call s:ClosePreviewWindowIfNeeded()
                              endif

FUNCTION  <SNR>57_denite_my_settings()
Called 2 times
Total time:   0.000126
 Self time:   0.000126

count  total (s)   self (s)
    2              0.000069 		nnoremap <silent><buffer><expr> <CR> denite#do_map('do_action')
                            		" nnoremap <silent><buffer><expr> d
                            		" \ denite#do_map('do_action', 'delete')
                            		" nnoremap <silent><buffer><expr> p
                            		" \ denite#do_map('do_action', 'preview')
    2              0.000018 		nnoremap <silent><buffer><expr> q denite#do_map('quit')
    2              0.000017 		nnoremap <silent><buffer><expr> i denite#do_map('open_filter_buffer')
    2              0.000016 		nnoremap <silent><buffer><expr> <Space> denite#do_map('toggle_select').'j'

FUNCTION  denite#init#_user_options()
Called 6 times
Total time:   0.000480
 Self time:   0.000480

count  total (s)   self (s)
    6              0.000462   return { 'auto_action': '', 'auto_resize': v:false, 'auto_resume': v:false, 'buffer_name': 'default', 'cursor_pos': '', 'cursorline': v:true, 'default_action': 'default', 'direction': 'botright', 'do': '', 'empty': v:true, 'expand': v:false, 'filter_split_direction': 'botright', 'filter_updatetime': 100, 'highlight_filter_background': 'NormalFloat', 'highlight_matched_range': 'Underlined', 'highlight_matched_char': 'Search', 'highlight_preview_line': 'Search', 'highlight_prompt': 'Special', 'highlight_window_background': 'NormalFloat', 'ignorecase': v:true, 'immediately': v:false, 'immediately_1': v:false, 'input': '', 'matchers': '', 'max_candidate_width': 200, 'max_dynamic_update_candidates': 20000, 'path': getcwd(), 'previewheight': &previewheight, 'prompt': '', 'post_action': 'none', 'quick_move': '', 'refresh': v:false, 'resume': v:false, 'reversed': v:false, 'root_markers': '', 'search': v:false, 'smartcase': v:false, 'sorters': '', 'split': 'horizontal', 'source_names': '', 'start_filter': v:false, 'statusline': v:true, 'unique': v:false, 'vertical_preview': v:false, 'wincol': &columns / 4, 'winheight': 20, 'winrow': &lines / 2 - 10, 'winwidth': &columns / 2, 'winminheight': -1,}

FUNCTION  <SNR>171_on_complete_done()
Called 14 times
Total time:   0.011650
 Self time:   0.003375

count  total (s)   self (s)
   14              0.000177   if get(v:completed_item, 'word', '') ==# ''
    5              0.000018     return
                              endif
    9   0.011175   0.002900   call deoplete#handler#_skip_next_completion()
                            
    9              0.000079   if get(v:completed_item, 'user_data', '') !=# ''
                                try
                                  if type(v:completed_item.user_data) == type('')
                                    call s:substitute_suffix(json_decode(v:completed_item.user_data))
                                  endif
                                catch /.*/
                                endtry
                              endif

FUNCTION  projectionist#query_file()
Called 3 times
Total time:   0.001086
 Self time:   0.000158

count  total (s)   self (s)
    3              0.000010   let files = []
    3              0.000006   let _ = {}
    3   0.000910   0.000059   for [root, _.match] in projectionist#query(a:key, a:0 ? a:1 : {})
                                call extend(files, map(filter(type(_.match) == type([]) ? copy(_.match) : [_.match], 'len(v:val)'), 's:absolute(v:val, root)'))
                              endfor
    3   0.000121   0.000045   return s:uniq(files)

FUNCTION  <SNR>139_uniq()
Called 14 times
Total time:   0.009400
 Self time:   0.000272

count  total (s)   self (s)
   14   0.009390   0.000262   return s:uniq_by(a:list, 'tolower(v:val)')

FUNCTION  lightline#buffer#bufferline()
Called 56 times
Total time:   0.713665
 Self time:   0.017385

count  total (s)   self (s)
   56              0.000588   let l:current_bufnr = bufnr('%')
                              " check for special cases like help files
   56              0.000317   if !bufexists(l:current_bufnr) || !buflisted(l:current_bufnr)
    4              0.000007     return ''
                              endif
                              " lazy recalc
                              "if g:last_current_bufnr == l:current_bufnr
                              "  return g:lightline_buffer_status_info.before .
                              "      \ '[' . g:lightline_buffer_status_info.current . ']' .
                              "      \ g:lightline_buffer_status_info.after
                              "endif
                            
   52   0.549029   0.001774   let l:names = s:generate_buffer_names()
                            
                              " debug only
                              "let l:flensum = 0
                              "for nr in range(1, bufnr('$'))
                              "  if bufexists(nr) && buflisted(nr)
                              "    let l:fname = bufname(nr)
                              "    if nr < l:current_bufnr
                              "      let l:before_str .= g:lightline_buffer_separator_left_icon . nr .
                              "          \ ' ' . l:fname . g:lightline_buffer_separator_right_icon
                              "    elseif nr > l:current_bufnr
                              "      let l:after_str .= g:lightline_buffer_separator_left_icon . nr .
                              "          \ ' ' . l:fname . g:lightline_buffer_separator_right_icon
                              "    else
                              "      let l:current_str .= g:lightline_buffer_separator_left_icon .
                              "          \ g:lightline_buffer_active_buffer_left_icon . nr .
                              "          \ ' ' . l:fname . g:lightline_buffer_active_buffer_right_icon .
                              "          \ g:lightline_buffer_separator_right_icon
                              "    endif
                              "
                              "    " add number, space and separator
                              "    let l:flensum += g:lightline_buffer_separator_left_icon_len +
                              "        \ nr + 1 + l:fname +
                              "        \ g:lightline_buffer_separator_right_icon_len
                              "    if nr == l:current_bufnr
                              "      let l:flensum +=
                              "          \ g:lightline_buffer_active_buffer_left_icon_len +
                              "          \ g:lightline_buffer_active_buffer_right_icon_len
                              "  endif
                              "endfor
                            
                              "echo l:names
   52   0.089916   0.001117   let l:strs = s:cat_buffer_names(l:names, l:current_bufnr, -1, -1)
   52              0.000201   let l:current_str = l:strs[0]
   52              0.000120   let l:before_str = l:strs[1]
   52              0.000102   let l:after_str = l:strs[2]
   52              0.000118   let l:visable_current_str = l:strs[3]
   52              0.000114   let l:visable_before_str = l:strs[4]
   52              0.000137   let l:visable_after_str = l:strs[5]
                              " debug only
                              "echo l:before_str . '[' . l:current_str . ']' . l:after_str
                            
   52   0.000984   0.000620   let l:visable_current_str_len = s:mb_str_len(l:visable_current_str)
   52   0.002332   0.001956   let l:visable_before_str_len = s:mb_str_len(l:visable_before_str)
   52   0.001005   0.000725   let l:visable_after_str_len = s:mb_str_len(l:visable_after_str)
                              "let l:flensum = l:visable_current_str_len + l:visable_before_str_len +
                              "    \ l:visable_after_str_len
                              "let g:lightline_buffer_status_info.info = l:flensum . ' ' . &columns
   52              0.000242   let g:lightline_buffer_status_info.count = len(l:names)
   52              0.000277   let g:lightline_buffer_status_info.current = l:current_str
   52              0.000340   if l:visable_before_str_len + l:visable_current_str_len + l:visable_after_str_len + g:lightline_buffer_reservelen > &columns
   32              0.000193     let l:max_part_len = (&columns - l:visable_current_str_len - g:lightline_buffer_reservelen) / 2
                            
                                " shorten
   32              0.000064     if l:visable_before_str_len <= l:max_part_len
    8              0.000036       let l:shorten_right_len = &columns - l:visable_current_str_len - l:visable_before_str_len - g:lightline_buffer_reservelen
                            
    8   0.019441   0.000182       let l:strs = s:cat_buffer_names(l:names, l:current_bufnr, -1, l:shorten_right_len)
    8              0.000026       let l:current_str = l:strs[0]
    8              0.000019       let l:before_str = l:strs[1]
    8              0.000019       let l:after_str = l:strs[2]
                                  "let l:visable_current_str = l:strs[3]
                                  "let l:visable_before_str = l:strs[4]
                                  "let l:visable_after_str = l:strs[5]
                            
    8              0.000030       let g:lightline_buffer_status_info.before = l:before_str
    8              0.000023       let g:lightline_buffer_status_info.after = l:after_str
                            
    8              0.000015       if 0 != g:lightline_buffer_debug_info
                                    let g:lightline_buffer_status_info.info .= '>' . &columns . '-' . g:lightline_buffer_reservelen
                                  endif
    8              0.000013     elseif l:visable_after_str_len <= l:max_part_len
   24              0.000106       let l:shorten_left_len = &columns - l:visable_current_str_len - l:visable_after_str_len - g:lightline_buffer_reservelen
                            
   24   0.040405   0.000458       let l:strs = s:cat_buffer_names(l:names, l:current_bufnr, l:shorten_left_len, -1)
   24              0.000072       let l:current_str = l:strs[0]
   24              0.000053       let l:before_str = l:strs[1]
   24              0.000043       let l:after_str = l:strs[2]
                                  "let l:visable_current_str = l:strs[3]
                                  "let l:visable_before_str = l:strs[4]
                                  "let l:visable_after_str = l:strs[5]
                            
   24              0.000100       let g:lightline_buffer_status_info.before = l:before_str
   24              0.000065       let g:lightline_buffer_status_info.after = l:after_str
                            
   24              0.000065       if 0 != g:lightline_buffer_debug_info
                                    let g:lightline_buffer_status_info.info .= '<' . &columns . '-' . g:lightline_buffer_reservelen
                                  endif
   24              0.000290     else
                                  let l:strs = s:cat_buffer_names(l:names, l:current_bufnr, l:max_part_len, l:max_part_len)
                            
                                  let l:current_str = l:strs[0]
                                  let l:before_str = l:strs[1]
                                  let l:after_str = l:strs[2]
                                  "let l:visable_current_str = l:strs[3]
                                  "let l:visable_before_str = l:strs[4]
                                  "let l:visable_after_str = l:strs[5]
                            
                                  let g:lightline_buffer_status_info.before = l:before_str
                                  let g:lightline_buffer_status_info.after = l:after_str
                            
                                  if 0 != g:lightline_buffer_debug_info
                                    let g:lightline_buffer_status_info.info = l:max_part_len
                                    let g:lightline_buffer_status_info.info .= '<>' . &columns . '-' . g:lightline_buffer_reservelen
                                  endif
                                endif
                            
   32              0.000020   else
   20              0.000071     let g:lightline_buffer_status_info.before = l:before_str
   20              0.000057     let g:lightline_buffer_status_info.after = l:after_str
                            
   20              0.000038     if 0 != g:lightline_buffer_debug_info
                                  let g:lightline_buffer_status_info.info = '=' . &columns . '-' . g:lightline_buffer_reservelen
                                endif
   20              0.000012   endif
                            
                              " debug only
                              "let g:lightline_buffer_status_info.info = l:visable_before_str_len . '+' .
                              "    \ l:visable_current_str_len . '+' . l:visable_after_str_len . '+' .
                              "    \ g:lightline_buffer_reservelen . '~' . &columns
                              "let g:lightline_buffer_status_info.before =
                              "    \ s:shorten_left(l:before_str, l:visable_before_str_len - 14,
                              "    \ l:visable_before_str_len, -1)
                              "let g:lightline_buffer_status_info.after =
                              "    \ s:shorten_right(l:after_str, l:visable_after_str_len - 14,
                              "    \ l:visable_after_str_len, -1)
   52              0.000398   let l:line = l:before_str . '[' . l:current_str . ']' . l:after_str
                            
                              " lazy recalc
                              "echo 'g:last_current_bufnr: ' . g:last_current_bufnr .
                              "    \ ', l:current_bufnr: ' . l:current_bufnr
                              "let g:last_current_bufnr = l:current_bufnr
                            
   52              0.000091   return l:line

FUNCTION  <SNR>176_StopCursorTimer()
Called 487 times
Total time:   0.008618
 Self time:   0.008618

count  total (s)   self (s)
  487              0.002078     if s:cursor_timer != -1
  484              0.002623         call timer_stop(s:cursor_timer)
  484              0.001959         let s:cursor_timer = -1
  484              0.000459     endif

FUNCTION  <SNR>172_OnCompleteDone()
Called 14 times
Total time:   0.020671
 Self time:   0.020671

count  total (s)   self (s)
   14              0.020640   exec s:python_command "ycm_state.OnCompleteDone()"

FUNCTION  necovim#get_complete_position()
Called 1 time
Total time:   0.000169
 Self time:   0.000099

count  total (s)   self (s)
    1   0.000144   0.000073   let cur_text = necovim#get_cur_text(a:input)
                            
    1              0.000008   if cur_text =~ '^\s*"'
                                " Comment.
    1              0.000001     return -1
                              endif
                            
                              let pattern = '\.\%(\h\w*\)\?$\|\%(' . g:necovim#keyword_pattern . '\)$'
                            
                              let [complete_pos, complete_str] = necovim#match_word(a:input, pattern)
                              if complete_pos < 0
                                " Use args pattern.
                                let [complete_pos, complete_str] = necovim#match_word(a:input, '\S\+$')
                              endif
                            
                              return complete_pos

FUNCTION  <SNR>171_is_skip_text()
Called 76 times
Total time:   0.028025
 Self time:   0.018927

count  total (s)   self (s)
   76   0.009218   0.000769   let input = deoplete#util#get_input(a:event)
                            
   76              0.007871   let lastchar = matchstr(input, '.$')
   76   0.001418   0.001048   let skip_multibyte = deoplete#custom#_get_option('skip_multibyte')
   76              0.000515   if skip_multibyte && len(lastchar) != strwidth(lastchar) && empty(get(b:, 'eskk', []))
                                return 1
                              endif
                            
                              " Note: Use g:deoplete#_context is needed instead of
                              " g:deoplete#_prev_completion
   76              0.000722   let prev_input = get(g:deoplete#_context, 'input', '')
   76              0.000294   if input ==# prev_input && a:event !=# 'Manual' && a:event !=# 'Async' && a:event !=# 'Update' && a:event !=# 'TextChangedP'
    2              0.000002     return 1
                              endif
   74              0.000189   if a:event ==# 'Update' && prev_input !=# '' && input !=# prev_input
                                return 1
                              endif
                            
   74              0.001066   if (exists('b:eskk') && !empty(b:eskk)     && !s:check_eskk_phase_henkan(input))
                                return 1
                              endif
                            
   74              0.000391   let displaywidth = strdisplaywidth(input) + 1
   74              0.002246   if &l:formatoptions =~# '[tca]' && &l:textwidth > 0     && displaywidth >= &l:textwidth
                                if &l:formatoptions =~# '[ta]' || !empty(filter(deoplete#util#get_syn_names(),                  "v:val ==# 'Comment'"))
                                  return 1
                                endif
                              endif
                            
   74   0.001116   0.000837   let skip_chars = deoplete#custom#_get_option('skip_chars')
                            
   74              0.000496   return (a:event !=# 'Manual' && input !=# ''     && index(skip_chars, input[-1:]) >= 0)

FUNCTION  <lambda>51()
Called 1 time
Total time:   0.003067
 Self time:   0.000034

count  total (s)   self (s)
    1   0.003065   0.000032 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  test#elm#elmtest#test_file()
Called 6 times
Total time:   0.000154
 Self time:   0.000154

count  total (s)   self (s)
    6              0.000130   return a:file =~# g:test#elm#elmtest#file_pattern

FUNCTION  <lambda>52()
Called 1 time
Total time:   0.004823
 Self time:   0.000026

count  total (s)   self (s)
    1   0.004822   0.000025 return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <SNR>172_OnInsertChar()
Called 53 times
Total time:   0.001763
 Self time:   0.000919

count  total (s)   self (s)
   53   0.000767   0.000325   if !s:AllowedToCompleteInCurrentBuffer()
                                return
                              endif
                            
   53              0.000177   call timer_stop( s:pollers.completion.id )
   53   0.000647   0.000245   call s:CloseCompletionMenu()

FUNCTION  <SNR>142_GetLinterNames()
Called 26 times
Total time:   0.000712
 Self time:   0.000712

count  total (s)   self (s)
   26              0.000287     let l:buffer_ale_linters = get(b:, 'ale_linters', {})
                            
                                " b:ale_linters can be set to 'all'
   26              0.000074     if l:buffer_ale_linters is# 'all'
                                    return 'all'
                                endif
                            
                                " b:ale_linters can be set to a List.
   26              0.000091     if type(l:buffer_ale_linters) is v:t_list
   24              0.000040         return l:buffer_ale_linters
                                endif
                            
                                " Try to get a buffer-local setting for the filetype
    2              0.000004     if has_key(l:buffer_ale_linters, a:original_filetype)
                                    return l:buffer_ale_linters[a:original_filetype]
                                endif
                            
                                " Try to get a global setting for the filetype
    2              0.000004     if has_key(g:ale_linters, a:original_filetype)
                                    return g:ale_linters[a:original_filetype]
                                endif
                            
                                " If the user has configured ALE to only enable linters explicitly, then
                                " don't enable any linters by default.
    2              0.000002     if g:ale_linters_explicit
                                    return []
                                endif
                            
                                " Try to get a default setting for the filetype
    2              0.000007     if has_key(s:default_ale_linters, a:original_filetype)
                                    return s:default_ale_linters[a:original_filetype]
                                endif
                            
    2              0.000001     return 'all'

FUNCTION  test#base#test_file()
Called 54 times
Total time:   0.025782
 Self time:   0.005969

count  total (s)   self (s)
   54   0.025691   0.005878   return test#{a:runner}#test_file(a:file)

FUNCTION  ale#sign#GetSignCommands()
Called 17 times
Total time:   0.009262
 Self time:   0.009072

count  total (s)   self (s)
   17              0.000115     let l:command_list = []
   17              0.000043     let l:is_dummy_sign_set = a:was_sign_set
                            
                                " Set the dummy sign if we need to.
                                " The dummy sign is needed to keep the sign column open while we add
                                " and remove signs.
   17              0.000076     if !l:is_dummy_sign_set && (!empty(a:sign_map) || g:ale_sign_column_always)
    8   0.000318   0.000175         call add(l:command_list, 'sign place '   .  g:ale_sign_offset   . s:GroupCmd()   . s:PriorityCmd()   . ' line=1 name=ALEDummySign '   . ' buffer=' . a:buffer)
    8              0.000016         let l:is_dummy_sign_set = 1
    8              0.000006     endif
                            
                                " Place new items first.
  202              0.000503     for [l:line_str, l:info] in items(a:sign_map)
  185              0.000148         if l:info.new_id
                                        " Save the sign IDs we are setting back on our loclist objects.
                                        " These IDs will be used to preserve items which are set many times.
  793              0.000758             for l:item in l:info.items
  608              0.000905                 let l:item.sign_id = l:info.new_id
  608              0.000697             endfor
                            
  185              0.000376             if index(l:info.current_id_list, l:info.new_id) < 0
                                            call add(l:command_list, 'sign place '   . (l:info.new_id)   . s:GroupCmd()   . s:PriorityCmd()   . ' line=' . l:line_str   . ' name=' . (l:info.new_name)   . ' buffer=' . a:buffer)
                                        endif
  185              0.000085         endif
  185              0.000115     endfor
                            
                                " Remove signs without new IDs.
  202              0.000231     for l:info in values(a:sign_map)
  370              0.000408         for l:current_id in l:info.current_id_list
  185              0.000195             if l:current_id isnot l:info.new_id
                                            call add(l:command_list, 'sign unplace '   . l:current_id   . s:GroupCmd()   . ' buffer=' . a:buffer)
                                        endif
  185              0.000291         endfor
  185              0.000071     endfor
                            
                                " Remove the dummy sign to close the sign column if we need to.
   17              0.000038     if l:is_dummy_sign_set && !g:ale_sign_column_always
    8   0.000157   0.000111         call add(l:command_list, 'sign unplace '   . g:ale_sign_offset   . s:GroupCmd()   . ' buffer=' . a:buffer)
    8              0.000006     endif
                            
   17              0.000022     return l:command_list

FUNCTION  <SNR>161_RunAsyncCommon()
Called 9 times
Total time:   0.031053
 Self time:   0.001122

count  total (s)   self (s)
    9              0.000039   if exists('s:jodid')
    2   0.000888   0.000093     call vista#util#JobStop(s:jodid)
    2   0.001031   0.000176     call s:DeleteTemp()
    2              0.000002   endif
                            
    9   0.028790   0.000510   let s:jodid = s:ApplyRunAsync(a:cmd)
                            
    9              0.000029   if !s:jodid
                                call vista#error#RunCtags(a:cmd)
                              endif

FUNCTION  <SNR>137_TempReadPost()
Called 2 times
Total time:   0.000098
 Self time:   0.000052

count  total (s)   self (s)
    2   0.000062   0.000016   if has_key(s:temp_files, s:cpath(a:file))
                                let dict = s:temp_files[s:cpath(a:file)]
                                if has_key(dict, 'filetype') && dict.filetype !=# &l:filetype
                                  let &l:filetype = dict.filetype
                                endif
                                setlocal foldmarker=<<<<<<<,>>>>>>>
                                if empty(mapcheck('q', 'n'))
                                  nnoremap <buffer> <silent> q    :<C-U>bdelete<Bar>echohl WarningMsg<Bar>echo "Temp file q is deprecated in favor of the built-in <Lt>C-W>q"<Bar>echohl NONE<CR>
                                endif
                                if !&modifiable
                                  call s:Map('n', 'gq', ":<C-U>bdelete<CR>", '<silent> <unique>')
                                endif
                              endif
    2              0.000001   return ''

FUNCTION  ale#handlers#languagetool#DefineLinter()
Called 1 time
Total time:   0.000458
 Self time:   0.000037

count  total (s)   self (s)
    1   0.000457   0.000036     call ale#linter#Define(a:filetype, {   'name': 'languagetool',   'executable': function('ale#handlers#languagetool#GetExecutable'),   'command': function('ale#handlers#languagetool#GetCommand'),   'output_stream': 'stdout',   'callback': 'ale#handlers#languagetool#HandleOutput',   'lint_file': 1,})

FUNCTION  <SNR>172_Complete()
Called 35 times
Total time:   0.003049
 Self time:   0.002564

count  total (s)   self (s)
                              " Do not call user's completion function if the start column is after the
                              " current column or if there are no candidates. Close the completion menu
                              " instead. This avoids keeping the user in completion mode.
   35              0.000446   if s:completion.start_column > col( '.' ) || empty( s:completion.candidates )
   21   0.000513   0.000260     call s:CloseCompletionMenu()
   21              0.000022   else
                                " <c-x><c-u> invokes the user's completion function (which we have set to
                                " youcompleteme#CompleteFunc), and <c-p> tells Vim to select the previous
                                " completion candidate. This is necessary because by default, Vim selects the
                                " first candidate when completion is invoked, and selecting a candidate
                                " automatically replaces the current text with it. Calling <c-p> forces Vim to
                                " deselect the first candidate and in turn preserve the user's current text
                                " until he explicitly chooses to replace it with a completion.
   14   0.000667   0.000435     call s:SendKeys( "\<C-X>\<C-U>\<C-P>" )
   14              0.000021   endif

FUNCTION  <lambda>2()
Called 23 times
Total time:   0.001231
 Self time:   0.000639

count  total (s)   self (s)
   23   0.001157   0.000565 return ale#Var(buffer, 'vim_vint_executable')

FUNCTION  sy#sign#parse_hunk()
Called 10 times
Total time:   0.002128
 Self time:   0.002128

count  total (s)   self (s)
   10              0.001918   let tokens = matchlist(a:diffline, '^@@ -\v(\d+),?(\d*) \+(\d+),?(\d*)')
   10              0.000191   return [ str2nr(tokens[1]), empty(tokens[2]) ? 1 : str2nr(tokens[2]), str2nr(tokens[3]), empty(tokens[4]) ? 1 : str2nr(tokens[4]) ]

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
Called 488 times
Total time:   0.073077
 Self time:   0.050047

count  total (s)   self (s)
  488              0.004398     let l:buffer = bufnr('')
                            
  488              0.002267     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
                                endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
  488              0.003147     if mode(1) isnot# 'n'
    1              0.000002         return
                                endif
                            
  487   0.016864   0.008245     call s:StopCursorTimer()
                            
  487              0.004655     let l:pos = getpos('.')[0:2]
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
  487              0.002181     if l:pos != s:last_pos
  484   0.021267   0.006855         let l:delay = ale#Var(l:buffer, 'echo_delay')
                            
  484              0.002268         let s:last_pos = l:pos
  484              0.004985         let s:cursor_timer = timer_start(   l:delay,   function('ale#cursor#EchoCursorWarning'))
  484              0.000543     endif

FUNCTION  ale#completion#GetCompletionPositionForDeoplete()
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000015     return match(a:input, '\k*$')

FUNCTION  <SNR>172_InvokeCompletion()
Called 19 times
Total time:   0.202482
 Self time:   0.188147

count  total (s)   self (s)
   19              0.187325   exec s:python_command "ycm_state.SendCompletionRequest(" . "vimsupport.GetBoolValue( 's:force_semantic' ) )"
                            
   19   0.014974   0.000640   call s:PollCompletion()

FUNCTION  <lambda>3()
Called 23 times
Total time:   0.005509
 Self time:   0.000589

count  total (s)   self (s)
   23   0.005487   0.000567 return ale#semver#RunWithVersionCheck(       buffer,       ale#Var(buffer, 'vim_vint_executable'),       '%e --version',       function('ale_linters#vim#vint#GetCommand'),   )

FUNCTION  <SNR>158_initialize_job()
Called 9 times
Total time:   0.003207
 Self time:   0.000310

count  total (s)   self (s)
    9   0.003179   0.000282   return s:wrap_cmd(a:bufnr, a:vcs, s:get_base_cmd(a:bufnr, a:vcs, g:signify_vcs_cmds))

FUNCTION  <SNR>207_uniq_by()
Called 1 time
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    1              0.000012   let list = map(copy(a:list), printf('[v:val, %s]', a:f))
    1              0.000001   let i = 0
    1              0.000001   let seen = {}
    2              0.000005   while i < len(list)
    1              0.000005     let key = string(list[i][1])
    1              0.000002     if has_key(seen, key)
                                  call remove(list, i)
                                else
    1              0.000003       let seen[key] = 1
    1              0.000001       let i += 1
    1              0.000001     endif
    1              0.000001   endwhile
    1              0.000004   return map(list, 'v:val[0]')

FUNCTION  ale#sign#ReadSigns()
Called 17 times
Total time:   0.002310
 Self time:   0.001910

count  total (s)   self (s)
   17              0.000114     redir => l:output
   17   0.001673   0.001273         silent execute 'sign place ' . s:GroupCmd() . s:PriorityCmd() . ' buffer=' . a:buffer
   17              0.000104     redir end
                            
   17              0.000357     return split(l:output, "\n")

FUNCTION  test#exists()
Called 3 times
Total time:   0.062651
 Self time:   0.000376

count  total (s)   self (s)
    3   0.062628   0.000353   return test#test_file(expand('%')) || test#test_file(s:alternate_file())

FUNCTION  <SNR>161_on_exit()
Called 8 times
Total time:   0.010577
 Self time:   0.000443

count  total (s)   self (s)
    8              0.000108     if !exists('t:vista') || v:dying
                                  return
                                endif
                            
                                " Second last line is the real last one in neovim
    8   0.000669   0.000173     call s:ExtractLinewise(self.stdout[:-2])
                            
    8   0.009753   0.000116     call s:ApplyExtracted()

FUNCTION  ale#job#Start()
Called 23 times
Total time:   0.087562
 Self time:   0.087281

count  total (s)   self (s)
   23   0.000728   0.000447     call ale#job#ValidateArguments(a:command, a:options)
                            
   23              0.000170     let l:job_info = copy(a:options)
   23              0.000078     let l:job_options = {}
                            
   23              0.000111     if has('nvim')
   23              0.000088         if has_key(a:options, 'out_cb')
   23              0.000204             let l:job_options.on_stdout = function('s:NeoVimCallback')
   23              0.000061             let l:job_info.out_cb_line = ''
   23              0.000021         endif
                            
   23              0.000070         if has_key(a:options, 'err_cb')
                                        let l:job_options.on_stderr = function('s:NeoVimCallback')
                                        let l:job_info.err_cb_line = ''
                                    endif
                            
   23              0.000065         if has_key(a:options, 'exit_cb')
   23              0.000148             let l:job_options.on_exit = function('s:NeoVimCallback')
   23              0.000019         endif
                            
   23              0.081099         let l:job_info.job = jobstart(a:command, l:job_options)
   23              0.000486         let l:job_id = l:job_info.job
   23              0.000075     else
                                    let l:job_options = {   'in_mode': l:job_info.mode,   'out_mode': l:job_info.mode,   'err_mode': l:job_info.mode,}
                            
                                    if has_key(a:options, 'out_cb')
                                        let l:job_options.out_cb = function('s:VimOutputCallback')
                                    endif
                            
                                    if has_key(a:options, 'err_cb')
                                        let l:job_options.err_cb = function('s:VimErrorCallback')
                                    endif
                            
                                    if has_key(a:options, 'exit_cb')
                                        " Set a close callback to which simply calls job_status()
                                        " when the channel is closed, which can trigger the exit callback
                                        " earlier on.
                                        let l:job_options.close_cb = function('s:VimCloseCallback')
                                        let l:job_options.exit_cb = function('s:VimExitCallback')
                                    endif
                            
                                    " Use non-blocking writes for Vim versions that support the option.
                                    if has('patch-8.1.350')
                                        let l:job_options.noblock = 1
                                    endif
                            
                                    " Vim 8 will read the stdin from the file's buffer.
                                    let l:job_info.job = job_start(a:command, l:job_options)
                                    let l:job_id = ale#job#ParseVim8ProcessID(string(l:job_info.job))
                                endif
                            
   23              0.000070     if l:job_id > 0
                                    " Store the job in the map for later only if we can get the ID.
   23              0.000337         let s:job_map[l:job_id] = l:job_info
   23              0.000031     endif
                            
   23              0.000217     return l:job_id

FUNCTION  <SNR>135_Debounce()
Called 6 times
Total time:   0.000158
 Self time:   0.000158

count  total (s)   self (s)
                                " Map function to its last execute time.
    6              0.000056     let s:DebounceMap = {}
    6              0.000026     let l:lastexectime = get(s:DebounceMap, a:f)
    6              0.000025     if l:lastexectime == 0 || reltimefloat(reltime(l:lastexectime)) < a:timeout
    6              0.000028         let s:DebounceMap[a:f] = reltime()
    6              0.000009         return v:true
                                else
                                    return v:false
                                endif

FUNCTION  <SNR>161_GetDefaultCmd()
Called 9 times
Total time:   0.002515
 Self time:   0.000963

count  total (s)   self (s)
                              " Refer to tagbar
    9              0.000057   let common_opt = '--format=2 --excmd=pattern --fields=nksSaf --file-scope=yes --sort=no --append=no'
                            
                              " Do not pass --extras for C/CPP in order to let uctags handle the tags for anonymous
                              " entities correctly.
    9   0.000624   0.000164   if t:vista.source.filetype() !=# 'c' && t:vista.source.filetype() !=# 'cpp'
    9              0.000045     let common_opt .= ' --extras= '
    9              0.000010   endif
                            
    9   0.001277   0.000185   let language_specific_opt = s:GetLanguageSpecificOptition(&filetype)
    9              0.000134   let cmd = printf(s:default_cmd_fmt, s:ctags, common_opt, language_specific_opt, a:file)
                            
    9              0.000027   return cmd

FUNCTION  <SNR>158_get_base_cmd()
Called 13 times
Total time:   0.003615
 Self time:   0.001454

count  total (s)   self (s)
   13              0.000368   let cmd = a:vcs_cmds[a:vcs]
   13   0.002379   0.000571   let cmd = s:replace(cmd, '%f', s:get_vcs_path(a:bufnr, a:vcs))
   13   0.000316   0.000127   let cmd = s:replace(cmd, '%d', s:difftool)
   13   0.000451   0.000289   let cmd = s:replace(cmd, '%n', s:devnull)
   13              0.000019   return cmd

FUNCTION  <SNR>161_GetCustomCmd()
Called 9 times
Total time:   0.000246
 Self time:   0.000246

count  total (s)   self (s)
    9              0.000159   if exists('g:vista_ctags_cmd') && has_key(g:vista_ctags_cmd, a:filetype)
                                return g:vista_ctags_cmd[a:filetype]
                              endif
    9              0.000017   return v:null

FUNCTION  ale#completion#HandleUserData()
Called 14 times
Total time:   0.000596
 Self time:   0.000596

count  total (s)   self (s)
   14              0.000364     let l:source = get(get(b:, 'ale_completion_info', {}), 'source', '')
                            
   14              0.000114     if l:source isnot# 'ale-automatic'&& l:source isnot# 'ale-manual'&& l:source isnot# 'ale-callback'
   14              0.000032         return
                                endif
                            
                                let l:user_data_json = get(a:completed_item, 'user_data', '')
                            
                                if empty(l:user_data_json)
                                    return
                                endif
                            
                                let l:user_data = json_decode(l:user_data_json)
                            
                                if type(l:user_data) isnot v:t_dict
                                    return
                                endif
                            
                                for l:code_action in get(l:user_data, 'codeActions', [])
                                    call ale#code_action#HandleCodeAction(l:code_action)
                                endfor

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
  903   3.132564             provider#python3#Call()
 5735   2.293631   1.143690  xray#drawing#DrawXray()
  488   1.092187   1.082873  <SNR>172_OnCursorMovedNormalMode()
   56   0.907402   0.007994  <SNR>149_NeoVimCallback()
   23   0.884933   0.003392  <SNR>146_ExitCallback()
   17   0.879664   0.002145  <SNR>145_HandleExit()
    1   0.792358   0.000064  <lambda>35()
    2   0.787626   0.285646  denite#util#rpcrequest()
   69   0.766275   0.155788  <SNR>172_OnTextChangedInsertMode()
 5735   0.715896   0.583292  xray#settings#ShouldIgnoreFiletype()
   56   0.713665   0.017385  lightline#buffer#bufferline()
   28   0.634773   0.023671  <SNR>150_line()
   56   0.607611   0.018563  <SNR>150_expand()
   14   0.605756   0.001208  lightline#tabline()
  203   0.584913   0.008627  <SNR>150_convert()
   42   0.576285   0.002966  <SNR>150_evaluate_expand()
   52   0.547255   0.167413  <SNR>151_generate_buffer_names()
   17   0.546345   0.191306  ale_linters#vim#vint#Handle()
    2   0.471826   0.003636  Prose()
    1   0.402110   0.000125  denite#helper#call_denite()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  903              3.132564  provider#python3#Call()
 5735   2.293631   1.143690  xray#drawing#DrawXray()
  488   1.092187   1.082873  <SNR>172_OnCursorMovedNormalMode()
 5735   0.715896   0.583292  xray#settings#ShouldIgnoreFiletype()
  213              0.401381  <SNR>172_Pyeval()
  647              0.392950  <SNR>118_Highlight_Matching_Pair()
   11   0.386879   0.386810  <SNR>172_OnBufferUnload()
   31   0.391994   0.360939  <SNR>172_OnFileReadyToParse()
  316   0.357389   0.353235  WebDevIconsGetFileTypeSymbol()
   32              0.350657  Mapkey()
  116              0.310297  <SNR>232_is_mkdCode()
    2   0.787626   0.285646  denite#util#rpcrequest()
   69              0.246508  <SNR>172_InsideCommentOrString()
    9   0.202868   0.199700  sy#sign#get_current_signs()
   17   0.546345   0.191306  ale_linters#vim#vint#Handle()
   19   0.202482   0.188147  <SNR>172_InvokeCompletion()
   17              0.180630  ale#util#GetMatches()
    1              0.170152  <SNR>172_OnVimLeave()
   52   0.547255   0.167413  <SNR>151_generate_buffer_names()
   69   0.766275   0.155788  <SNR>172_OnTextChangedInsertMode()

